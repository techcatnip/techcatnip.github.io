<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>openEuler安全配置基线 | 馒头馅儿大肉包</title><meta name="keywords" content="安全配置基线"><meta name="author" content="馒头馅儿大肉包"><meta name="copyright" content="馒头馅儿大肉包"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="openEuler安全配置基线"><meta name="application-name" content="openEuler安全配置基线"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="openEuler安全配置基线"><meta property="og:url" content="http://blog.techcat.cc/posts/ec805823.html"><meta property="og:site_name" content="馒头馅儿大肉包"><meta property="og:description" content="openEuler安全配置基线 v1.0   版本 修订说明 修订时间 访问链接    1.0 初始修订 2023年12月 本文档   1 初始部署1.1 文件系统1.1.1 禁止存在无属主或属组的文件或目录级别： 要求 适用版本： 全部 规则说明：  系统中不允许存在没有属主或属组的文件或目录，这"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s3.bmp.ovh/imgs/2023/08/27/70d5dea4dd88dfc1.webp?_r_=bb7c0e92-ec43-67b0-e72e-a37c058b5b71"><meta property="article:author" content="馒头馅儿大肉包"><meta property="article:tag" content="馒头馅儿大肉包,王大脑袋,Linux,kubernetes"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2023/08/27/70d5dea4dd88dfc1.webp?_r_=bb7c0e92-ec43-67b0-e72e-a37c058b5b71"><meta name="description" content="openEuler安全配置基线 v1.0   版本 修订说明 修订时间 访问链接    1.0 初始修订 2023年12月 本文档   1 初始部署1.1 文件系统1.1.1 禁止存在无属主或属组的文件或目录级别： 要求 适用版本： 全部 规则说明：  系统中不允许存在没有属主或属组的文件或目录，这"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://blog.techcat.cc/posts/ec805823"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://leafy-dasik-1bfebc.netlify.app/.netlify/functions/twikoo',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.techcat.cc"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文章距离最后一次更新已经过去了","messageNext":"天，文章内容可能已经变得不可靠或者版本不适配，请谨慎阅读。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 馒头馅儿大肉包","link":"链接: ","source":"来源: 馒头馅儿大肉包","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '馒头馅儿大肉包',
  title: 'openEuler安全配置基线',
  postAI: '',
  pageFillDescription: 'openEuler安全配置基线 v1.0, 1 初始部署, 1.1 文件系统, 1.1.1 禁止存在无属主或属组的文件或目录, 1.1.2 禁止存在空链接文件, 1.1.3 禁止存在隐藏的可执行文件, 1.1.4 确保全局可写目录已设置sticky位, 1.1.5 确保UMASK配置正确, 1.1.6 禁止存在全局可写的文件, 1.1.7 确保移除不需要的文件系统挂载支持, 1.1.8 确保无需修改的分区以只读方式挂载, 1.1.9 确保无需挂载设备的分区以nodev方式挂载, 1.1.10 确保无可执行文件的分区以noexec方式挂载, 1.1.11 确保可移动设备分区以noexec、nodev方式挂载, 1.1.12 确保无需SUIDx2FSGID的分区以nosuid方式挂载, 1.1.13 确保删除文件不必要的SUID和SGID位, 1.1.14 确保关键文件、目录权限最小化, 1.1.15 确保用户可打开文件数量配置正确, 1.1.16 确保软、硬链接文件保护配置正确, 1.1.17 避免使用USB存储, 1.1.18 应当分区管理硬盘数据, 1.1.19 确保LD_LIBRARY_PATH变量定义正确, 1.1.20 确保用户PATH变量被严格定义, 1.2 软件, 1.2.1 禁止安装FTP客户端, 1.2.2 禁止安装TFTP客户端, 1.2.3 禁止安装Telnet客户端, 1.2.4 禁止安装不安全的SNMP协议版本, 1.2.5 禁止安装python2, 1.2.6 确保yum源配置GPG校验, 1.2.7 禁止启用debug-shell服务, 1.2.8 禁止安装rsync服务, 1.2.9 禁止安装avahi服务, 1.2.10 禁止安装LDAP服务, 1.2.11 禁止安装打印服务, 1.2.12 禁止安装NIS服务端, 1.2.13 禁止安装NIS客户端, 1.2.14 禁止安装LDAP客户端, 1.2.15 禁止安装网络嗅探类工具, 1.2.16 禁止安装调测类工具, 1.2.17 禁止安装开发编译类工具, 1.2.18 避免安装X Window系统, 1.2.19 避免安装HTTP服务, 1.2.20 避免安装samba服务, 1.2.21 避免启用DNS服务, 1.2.22 避免启用NFS服务, 1.2.23 避免启用RPC服务, 1.2.24 避免启用DHCP服务, 2 安全访问, 2.1 账户, 2.1.1 禁止无需登录的账号设置登录能力, 2.1.2 禁止存在不使用的账号, 2.1.3 确保不同账号初始分配不同的组ID, 2.1.4 禁止存在UID为0的非root账号, 2.1.5 确保账号、组及口令文件权限正确, 2.1.6 确保账号拥有自己的Home目录, 2.1.7 确保x2Fetcx2Fpasswd中的组都存在, 2.1.8 确保UID唯一, 2.1.9 确保账号名唯一, 2.1.10 确保GID唯一, 2.1.11 确保组名唯一, 2.1.12 应当正确设置账号有效期, 2.1.13 避免Home目录下存在.forward文件, 2.1.14 避免Home目录下存在.netrc文件, 2.2 口令, 2.2.1 确保口令复杂度设置正确, 2.2.2 禁止使用历史口令, 2.2.3 确保用户修改自身口令时需验证旧口令, 2.2.4 确保口令中不包含账号字符串, 2.2.5 确保口令使用强Hash算法加密, 2.2.6 确保弱口令字典设置正确, 2.2.7 确保口令有效期设置正确, 2.2.8 禁止空口令登录, 2.2.9 确保Grub已设置口令保护, 2.2.10 确保单用户模式已设置口令保护, 2.2.11 确保账号在首次登录时强制修改口令, 2.3 身份认证, 2.3.1 确保登录失败一定次数后锁定账号, 2.3.2 确保会话超时时间设置正确, 2.3.3 确保Warning Banners包含合理的信息, 2.3.4 应当正确配置Banner路径, 2.4 访问控制, 2.4.1 限制历史命令记录数量, 2.4.2 应当启用enforce模式, 2.4.3 应当正确配置SELinux策略, 2.4.4 确保su受限使用, 2.4.5 确保普通用户通过sudo运行特权程序, 2.4.6 确保sudoers不能配置低权限用户可写的脚本, 2.4.7 确保普通用户不能借助pkexec配置提权root, 2.4.8 确保su命令继承用户环境变量不会引入提权, 2.4.9 避免root用户本地接入系统, 2.4.10 避免使用标签为unconfined_service_t的程序, 2.5 完整性, 2.5.1 应当启用IMA度量, 2.5.2 应当启用aide入侵检测, 2.6 数据安全, 2.6.1 应当启用haveged服务, 2.6.2 应当设置全局加解密策略配置不低于DEFAULT, 3 运行和服务, 3.1 网络, 3.1.1 避免使用不常见网络服务, 3.1.2 避免使用无线网络, 3.2 防火墙, 3.2.1 应当启用firewalld服务, 3.2.2 应当配置正确的默认区域, 3.2.3 应当确保网络接口绑定正确区域, 3.2.4 避免开启不必要的服务和端口, 3.2.5 应当启用iptables服务, 3.2.6 应当正确配置iptables默认拒绝策略, 3.2.7 应当正确配置iptables loopback策略, 3.2.8 应当正确配置iptables INPUT策略, 3.2.9 应当正确配置iptables OUTPUT策略, 3.2.10 应当正确配置iptables INPUT、OUTPUT关联策略, 3.2.11 应当启用nftables服务, 3.2.12 应当配置nftables默认拒绝策略, 3.2.13 应当配置nftables loopback策略, 3.2.14 应当正确配置nftables input策略, 3.2.15 应当正确配置nftables output策略, 3.2.16 应当正确配置nftables input、output关联策略, 3.3 SSH, 3.3.1 确保SSH服务版本配置正确, 3.3.2 确保SSH服务认证方式配置正确, 3.3.3 确保SSH密钥交换算法配置正确, 3.3.4 确保用户认证密钥算法配置正确, 3.3.5 确保PAM认证使能, 3.3.6 确保SSH服务MACs算法配置正确, 3.3.7 确保SSH服务密码算法配置正确, 3.3.8 禁止SSH服务配置加密算法覆盖策略, 3.3.9 确保禁用root用户通过SSH登录, 3.3.10 应当正确配置SSH服务日志级别, 3.3.11 应当正确配置SSH服务接口, 3.3.12 应当正确配置SSH并发未认证连接数, 3.3.13 应当正确配置单个SSH连接允许的并发会话数, 3.3.14 禁止使用X11 Forwarding, 3.3.15 应当正确配置MaxAuthTries, 3.3.16 禁止使用PermitUserEnvironment, 3.3.17 应当正确配置LoginGraceTime, 3.3.18 禁止SSH服务预设置authorized_keys, 3.3.19 禁止SSH服务预设置known_hosts, 3.3.20 禁止SSH服务配置弃用的选项, 3.3.21 确保禁用SSH的TCP转发功能, 3.3.22 应当正确配置认证黑白名单, 3.4 定时任务, 3.4.1 确保crontab执行的脚本非属主用户不可写, 3.4.2 确保cron守护进程正常启用, 3.4.3 确保at、cron配置正确, 3.5 内核, 3.5.1 确保内核ASLR已启用, 3.5.2 确保dmesg访问权限配置正确, 3.5.3 确保正确配置内核参数kptr_restrict, 3.5.4 确保内核SMAP已启用, 3.5.5 确保内核SMEP已启用, 3.5.6 禁止系统响应ICMP广播报文, 3.5.7 禁止接收ICMP重定向报文, 3.5.8 禁止转发ICMP重定向报文, 3.5.9 应当忽略所有ICMP请求, 3.5.10 确保丢弃伪造的ICMP报文不记录日志, 3.5.11 确保反向地址过滤已启用, 3.5.12 禁止IP转发, 3.5.13 禁止报文源路由, 3.5.14 确保TCP-SYN cookie保护已启用, 3.5.15 应当记录仿冒、源路由以及重定向报文日志, 3.5.16 避免开启tcp_timestamps, 3.5.17 确保TIME_WAIT TCP协议等待时间已配置, 3.5.18 应当正确配置SYN_RECV状态队列数量, 3.5.19 禁止使用ARP代理, 3.5.20 确保core dump配置正确, 3.5.21 禁止使用SysRq键, 3.5.22 应当正确配置内核参数ptrace_scope, 3.5.23 应当启用seccomp, 3.6 时间同步, 3.6.1 应当正确配置ntpd服务, 3.6.2 应当正确配置chronyd服务, 4 日志审计, 4.1 Audit, 4.1.1 确保auditd审计已启用, 4.1.2 确保审计日志rotate已启用, 4.1.3 应当配置登录审计规则, 4.1.4 应当配置账号信息修改审计规则, 4.1.5 应当配置提权命令审计规则, 4.1.6 应当配置内核模块变更审计规则, 4.1.7 应当配置管理员特权操作审计规则, 4.1.8 应当在启动阶段启用auditd, 4.1.9 应当正确配置audit_backlog_limit, 4.1.10 避免使用auditctl设置auditd规则, 4.1.11 确保日志大小限制配置正确, 4.1.12 应当正确配置硬盘空间阈值, 4.1.13 应当配置sudoers审计规则, 4.1.14 应当配置会话审计规则, 4.1.15 应当配置时间修改审计规则, 4.1.16 应当配置SELinux审计规则, 4.1.17 应当配置网络环境审计规则, 4.1.18 应当配置文件访问控制权限审计规则, 4.1.19 应当配置文件访问失败审计规则, 4.1.20 应当配置文件删除审计规则, 4.1.21 应当配置文件系统挂载审计规则, 4.2 Rsyslog, 4.2.1 确保rsyslog服务已启用, 4.2.2 确保系统认证相关事件日志已记录, 4.2.3 确保cron服务日志已记录, 4.2.4 应当正确配置rsyslog默认文件权限, 4.2.5 应当正确配置各服务日志记录, 4.2.6 确保rsyslog转储journald日志已配置, 4.2.7 确保rsyslog日志rotate已配置, 4.2.8 应当配置远程日志服务器, 4.2.9 应当仅在指定的日志主机上接受远程rsyslog消息安全配置基线版本修订说明修订时间访问链接初始修订年月本文档初始部署文件系统禁止存在无属主或属组的文件或目录级别要求适用版本全部规则说明系统中不允许存在没有属主或属组的文件或目录这些文件或目录一般都是由于原属主账号被删除而文件未被删除导致这些文件存在安全隐患可能导致信息泄露占用不必要的磁盘空间和系统资源还可能影响正常业务运行需要注意在容器场景中容器和宿主机使用不同的这导致容器中的文件在宿主机中可能为无属主或属组的目录和文件对于容器的宿主机已有相应的保护措施宿主机上的的父目录已做了权限控制仅用户可以访问对于此情况的目录和文件可例外规则影响无检查方法通过如下两个命令在系统根目录下查找无属主或属组的目录和文件如果这两个命令没有返回值表示系统中不存在无属主或属组的目录和文件修复方法通过命令删除无属主或属组的文件此处需要注意删除前务必确认确实为无用的文件或目录否则可使用命令将目录或文件修改为正确的且实际存在的属主或属组方法如下或禁止存在空链接文件级别要求适用版本全部规则说明空链接文件一方面属于冗余文件浪费系统资源另一方面如果后续在链接目标位置安装或者创建了同名同路径的文件但却没有清理历史上的链接文件该目标文件就可以通过链接进行访问可能导致文件信息泄露甚至被篡改链接文件所指向的实际文件如果已经被删除那么链接文件本身也就失去了存在的必要务必同时删除确保系统中不存在空链接文件需要注意系统运行时部分目录下存在一些系统临时文件或链接这些是随进程动态变化的可以作为例外忽略这些目录常见的有规则影响无检查方法使用命令在全局或某个目录下查找空链接文件例如该命令如果返回输出为空表示在指定目录下没有找到空链接文件否则会返回空链接文件名如上面例子中的文件如果要排除某些目录不做搜索例如排除目录可使用如下命令可以搜索到目录下是空链接文件而部分系统目录被排除在外未被搜索也可以使用参数只搜索指定目录所在分区的文件系统对于其他通过挂载的目录不做搜索修复方法搜索到空链接文件后使用命令删除该文件禁止存在隐藏的可执行文件级别要求适用版本全部规则说明在系统中以为前缀的文件是隐藏文件除了当前目录和上层目录的系统中不允许存在可执行的隐藏文件这三个文件是系统在创建用户账号后账号登录登出时的脚本文件符合业界惯例可不删除其他隐藏的可执行文件必须删除或去除可执行权限规则影响无检查方法通过命令可以查找是否存在可执行的隐藏文件如下命令是在根文件系统下全局查找如果返回为空则表示未找到任何可执行的隐藏文件否则列出相应文件修复方法根据实际情况有三种修改方式使用命令删除隐藏的可执行文件使用命令将隐藏文件修改为普通文件使用命令去除可执行权限例如确保全局可写目录已设置位级别要求适用版本全部规则说明位又叫粘滞位普通文件的粘滞位会被内核忽略粘滞位被设置在目录的执行许可位置上用表示设置了该位后其它用户就不可以删除该目录下不属于他的文件和目录但是子目录不继承该权限要再设置才可使用对于全局可写的目录要求必须设置粘滞位如果用户对目录有写权限则可以删除其中的文件和子目录即使该用户不是这些文件的所有者而且也没有读或写许可规则影响无检查方法使用如下命令查找指定目录下有全局可写权限且未设置粘滞位的目录返回为空表示未找到举例中目录为全局可写目录但未设置粘滞位修复方法使用命令设置目录粘滞位其中第一位表示设置粘滞位设置完成以后可以通过命令查看是否已经设置成功如下例子中用户的位已经被设置为确保配置正确级别要求适用版本全部规则说明是默认文件或目录权限的掩码创建文件或目录的时候以权限按位减去的值如果是文件则还需要去掉可执行权限然后得到文件或目录的默认权限设置如果设置不合理可能导致新建文件权限过小或过大从而影响业务正常运行或导致安全风险考虑到社区版本在不同场景下的易用性发行版默认不配置请根据实际场景按需配置规则影响按规范要求将配置为后创建的文件默认权限为目录默认权限为会使属组及其他用户使用受限降低易用性检查方法检查配置文件中值是否正确可以添加多个目录同时检查例如下面代码中同时检查了和用户目录下文件获得值为使用用户登录创建文件或目录确认权限是否正确使用普通账号登录创建文件或目录确认权限是否正确修复方法可以在两个地方进行修改在文件中对字段进行修改该文件变化对全局所有用户下次登录有影响在文件中对字段进行修改或添加该文件变化只对当前用户下次登录时有影响如果该文件中的配置同不一致则以该文件为准禁止存在全局可写的文件级别要求适用版本全部规则说明全局可写意味着所有用户都可以对文件进行写操作通常情况下这种权限并不是必须的如果文件被不合理的设置了全局可写权限容易被攻击者篡改导致安全风险所以如果文件不得不存在全局可写的权限需要针对实际场景分析安全风险确保攻击者无法利用此文件进行攻击可以在根目录下搜索全局可写文件需要例外的是这两个系统目录在运行时存在大量的全局可写文件所以在检查时应排除这两个目录避免混淆规则影响无检查方法使用如下命令在根目录下进行搜索已排除了这两个目录返回全局可写文件列表如果返回为空表示无全局可写文件也可以使用参数只搜索指定目录所在分区的文件系统对于其他通过挂载的目录不做搜索修复方法对于不合理的权限使用命令进行修改去除全局可写例如确保移除不需要的文件系统挂载支持级别要求适用版本全部规则说明系统支持多种文件系统通过方式加载进内核作为通用操作系统平台会提供各种文件系统保存在目录下可以通过命令进行加载支持禁用不需要的文件系统的挂载支持可以缩小攻击面防止攻击者通过利用某些不常用文件系统的漏洞对系统进行攻击使用者应根据实际场景确定哪些文件系统是不需要被支持的并通过配置禁止这些文件系统被挂载这些文件系统通常包括规则影响移除的文件系统不再被支持检查方法使用如下命令检查输出结果例如其他文件系统类似如果输出表示该文件系统已经被禁止挂载如果输出表示该文件系统未被禁止挂载并列出所在目录如果上述命令没有回显再执行以下命令如果有输出则表示该文件系统已被挂载修复方法对已挂载的文件系统确定是实际场景不需要被支持的可通过如下命令移除例如其他文件系统类似在目录下添加一个任意文件名的并以为后缀的配置文件属主和属组均为权限并根据实际场景将需要被禁止挂载的文件系统按照如下格式填入确保无需修改的分区以只读方式挂载级别要求适用版本全部规则说明以只读方式挂载无需数据修改的文件系统可以避免无意或恶意的数据篡改行为减小攻击面规则影响文件系统一旦以只读方式挂载将无法对文件和目录进行创建修改删除动作用户需要根据实际场景进行配置操作系统运行必须的文件挂载可以忽略此项要求检查方法通过命令查看挂载的文件系统是否符合要求例如查看目录是否为只读挂载可以使用如下命令如果无返回数据说明该目录未被挂载或非只读挂载修复方法卸载对应挂载点重新以只读方式挂载如果硬盘或分区是通过配置文件进行挂载的那么通过修改该文件为指定挂载点添加挂载方式如确保无需挂载设备的分区以方式挂载级别要求适用版本全部规则说明表示不允许挂载设备文件用于减小攻击面增加安全性目录被挂载时如果设置了选项那么该目录下所有块设备字符设备等设备文件将被解析为普通文件无法按设备文件进行操作如果挂载时未设置将导致安全风险例如攻击者在盘上创建了一个文件系统并在其中创建了一个块设备文件自己的盘有相应的权限而这个块设备实际是指向之类的服务器硬盘或分区的如果攻击者有机会将盘插入到服务器上服务器又加载了这个盘那么攻击者可以通过这个块设备文件访问到相应硬盘数据如果将上述案例中的盘改为其他硬盘或分区也存在类似问题只要该硬盘或分区上存在恶意构造的设备文件就可以形成攻击系统中默认如下目录被挂载存在以下目录部分目录因硬盘分区部署平台而不同这些目录默认未被挂载实际场景中根据业务需要对不需要挂载设备的分区采用方式挂载规则影响无检查方法通过命令检查是否存在需要被设置但却未被设置的挂载点对返回数据进行分析确认未设置的挂载点是否正确此处举例中除了系统默认未使用挂载的目录外用户新增的挂载点未使用方式挂载修复方法卸载对应挂载点重新以方式挂载如果硬盘或分区是通过配置文件进行挂载的那么通过修改该文件为指定挂载点添加挂载方式如确保无可执行文件的分区以方式挂载级别要求适用版本全部规则说明数据盘只是用于保存系统运行过程中的数据并不需要在数据盘上执行相关命令对于这种情况该硬盘或分区必须以方式挂载提高安全性减少攻击面规则影响硬盘或分区如果以方式挂载那么该挂载点目录下的可执行文件无法直接运行检查方法通过命令查看指定挂载点目录是否以方式挂载修复方法卸载对应挂载点重新以方式挂载如果硬盘或分区是通过配置文件进行挂载的那么通过修改该文件为指定挂载点添加挂载方式如确保可移动设备分区以方式挂载级别要求适用版本全部规则说明可移动设备本身存在不确定性来源过往使用情况运输过程等都无法保证绝对安全因此可移动设备往往是病毒传播的主要宿主设备所以针对可移动设备要求必须以方式挂载提高安全性减少攻击面可以防止可移动设备上文件被直接执行如病毒文件攻击脚本等可以防止可移动设备上不正确的设备文件链接到服务器真实设备从而导致攻击行为常见的可移动设备如等规则影响可移动设备如果以方式挂载那么该挂载点目录下的可执行文件无法直接运行检查方法通过命令查看指定挂载点目录是否以方式挂载此处假设为可移动设备修复方法卸载对应挂载点重新以方式挂载确保无需的分区以方式挂载级别要求适用版本全部规则说明可执行文件设置位后即使执行该文件的用户并不是文件的属主在执行过程中该进程也会被暂时赋予文件属主的权限例如普通用户执行一个权限为属主为的程序那么如果该程序没有设置位进程就只有用户的权限如果被设置了执行过程中进程就拥有的权限是类似的功能只不过是拥有了文件属组的权限对于不需要有的分区采用的方式挂载这样可以使该分区带的文件的位失效防止通过该分区的可执行文件进行提权加强了分区的安全性用户需要根据实际场景规划各挂载硬盘和分区设置挂载项规则影响无检查方法通过命令检查文件系统是否以方式挂载该命令返回未使用方式挂载的硬盘或分区如下例中返回的挂载点均为系统默认挂载点部分目录因硬盘分区部署平台而不同均需要功能如果命令执行后存在与实际场景相关的目录需要具体分析该目录是否挂载正确修复方法卸载对应挂载点重新以方式挂载如果硬盘或分区是通过配置文件进行挂载的那么通过修改该文件为指定挂载点添加挂载方式如确保删除文件不必要的和位级别要求适用版本全部规则说明在中和是在和类操作系统中用于控制程序权限的特殊权限位确保文件不包含不必要的和位非常重要以提高系统的安全性这些位允许文件在执行时以文件所有者或文件所属组的权限运行可能会导致潜在的安全风险规则影响无检查方法可使用如下命令查找系统中的和文件如果无返回表示不存在该类文件修复方法找到或文件需要审查这些文件并确定是否确实需要这些权限通常只有一些特定的系统工具或程序需要或权限而绝大多数文件不需要如果确定某个文件不需要或权限可以将其文件删除或移除文件的和位执行命令行如下或确保关键文件目录权限最小化级别要求适用版本全部规则说明按照权限最小化要求系统中的关键文件特别是包含有敏感信息的文件必须设置正确的最小的访问权限只能有相应权限的用户可以访问目录也是同样要求文件或目录权限配置不正确可能导致包含敏感数据的文件信息泄露例如访问权限设置大于等于任何用户都可以访问甚至篡改只有用户可以执行的程序但却设置了的权限导致任何用户都可以执行引入提权风险常见的需要做访问权限控制的文件或目录类型有可执行文件二进制文件脚本存放可执行文件的目录如果权限配置不当可能会导致提权攻击配置文件密钥文件日志文件存储有敏感信息的数据文件系统运行时产生的临时文件静态文件等这些文件中可能会含有敏感数据隐私数据如果权限配置不当会增加信息泄露的风险权限控制基本原则如下文件类型设置值用户主目录程序文件含脚本文件库文件等程序文件目录配置文件配置文件目录日志文件记录完毕或者已经归档日志文件正在记录日志文件目录文件文件目录临时文件目录维护升级文件目录业务数据文件业务数据文件目录密钥组件私钥证书密文文件目录密钥组件私钥证书加密密文加解密接口加解密脚本鉴于进程权限最小化原则系统执行任务时一般使用非的普通用户该用户需要访问系统中必要的目录和文件所以对于系统本身运行依赖的系统目录配置文件可执行文件证书文件相应权限可适当放宽权限控制建议如下文件类型设置值目录程序文件含脚本文件库文件等配置文件证书文件无私钥常见的需要做访问权限控制的文件的建议权限如下文件名称设置值规则影响权限配置不能过大也不能过小例如有些系统配置文件如果将权限设置为或那么普通用户就无法读取相应的程序可能因为无权读取配置而无法执行检查方法使用命令或命令查看文件权限修复方法使用命令修改文件权限确保用户可打开文件数量配置正确级别要求适用版本全部规则说明在系统中可以打开的文件总数是有限制的如果全部资源被某个用户会话占用其他用户将无法正常打开文件默认限制每个用户会话最多打开文件句柄数为超过这个数会禁止打开新文件句柄用户可以修改当前会话的最大允许值但不能超过管理员设置的上限默认管理员可以修改该上限值没有限制用户可根据自身业务特点设置合理的数值防止单个用户会话的所有进程打开过多的文件句柄耗尽系统资源可以通过命令进行设置主要有两个参数该参数用于查看或设置上限最大值这个值对于普通用户会话而言一旦设定以后只能调小不能调大比如第一次设置为不能超过管理员设置的系统最大值比如那么后续设置只能为小于等于该参数用于查看或设置当前上限值这个值是实际用于打开句柄数判断的值这个值可以任意调大或调小但不能超过设置的上限最大值普通用户进行设置均只作用于当前会话规则影响设置过小可能导致用户在当前会话中无法打开必要的文件句柄设置过大可能导致系统资源耗尽检查方法查看当前限制值查看普通用户可修改的上限值修复方法可以通过修改文件配置每个用户默认的上限和上限最大值比如加入如下行用户名用户名可以在会话中使用命令进行临时设置普通用户设置上限普通用户设置上限最大值不能超过原上限最大值同时设置上限和上限最大值可以使用如下命令用户设置上限以及上限最大值的方法同普通用户一样但用户可以将上限最大值设置为大于默认值确保软硬链接文件保护配置正确级别要求适用版本全部规则说明在系统中软硬链接文件是一个文件链接到另一个目标文件打开该链接文件其实就是打开目标文件所以攻击者以低权限用户伪造的软链接文件可以被高权限用户执行导致提权安全问题硬链接文件有同样问题本规则要求系统中对软硬链接进行加固如果目标文件和链接文件不是同属主的且链接文件属主无权执行目标文件的无论访问该链接的用户是谁均拒绝访问这里就会存在一种竞争风险如果一个高权限进程需要在目录一般在全局可写目录下创建的文件容易被利用攻击因为其他目录权限控制比较严格创建一个临时文件可能的操作是先判断文件是否存在如果不存在就创建并打开此时攻击者可以在判断之后创建之前利用这个时间间隙创建一个同临时文件同名的软链接文件到系统关键文件需要高权限管理员才能访问此时高权限进程创建并访问文件其实就相当于直接访问了文件原本攻击者对文件没有权限但利用高权限进程访问到了文件通过该进程可以对文件进行破坏篡改数据窃取可以看到在这个案例中原本文件和的属主应该都是但因为存在竞争攻击的属主变成了攻击者普通用户临时文件变成了链接文件依旧是属主结果只要高权限进程有文件的权限就可以通过这个软链接文件访问默认已经设置软硬链接保护规则影响无检查方法使用如下命令检查如果返回值为表示已经启用保护修复方法默认已经启用保护无需设置如果因实际场景需要启闭保护状态可使用如下命令临时设置重启后恢复默认值启用保护关闭保护可以通过修改文件添加如下代码并执行实现永久启闭保护状态启用保护关闭保护避免使用存储级别建议适用版本全部规则说明存储设备通常用于在服务器之间拷贝数据但由于存储设备上的数据一般情况下无法通过技术手段保护增加了被攻击的风险如果设备上存在病毒木马等攻击程序将可能导致服务器被感染破坏如果存储设备管理不善将导致数据泄露所以攻击者可以通过构造破坏存储数据再利用合法的管理人员在服务器上操作存储设备达到攻击服务器窃取数据的目的建议根据实际场景禁用存储规则影响无法使用存储数据检查方法使用如下命令检查输出结果如果输出表示存储设备已经被禁止使用如果输出表示未被禁止并列出所在目录修复方法在目录下添加一个任意文件名的并以为后缀的配置文件属主和属组均为权限按照如下格式填入代码即可禁用存储应当分区管理硬盘数据级别建议适用版本全部规则说明在安装操作系统时应根据实际场景特点将操作系统数据同业务数据分区管理避免将所有数据放在一个硬盘或分区下合理规划硬盘分区可以避免或降低如下风险日志文件过大导致业务或系统数据盘满普通账号目录过大导致系统或业务盘满系统分区不独立导致盘满后操作系统基础服务故障引起全面攻击不利于权限最小化控制不利于数据盘加密盘损坏后不利于系统或数据恢复作为通用操作系统默认安装单独分区建议根据实际场景确定其他目录的分区挂载以及大小规则影响无检查方法通过如下命令检查指定目录是否挂载合理具体目录清单可根据实际情况增减如果返回为空表示这些目录都没有单独挂载分区否则返回挂载列表修复方法根据实际使用场景对硬盘进行合理划分建议如下操作系统中的目录建议在系统安装部署时同根目录分开单独分区挂载并安装系统文件其中目录一般挂载为格式的临时内存文件系统如果关机后用户业务不需要保持目录下文件持久化可以不指定硬盘分区操作系统自动挂载文件系统业务数据目录建议单独分区或独立硬盘磁阵挂载本地转储或保存的日志建议单独分区或硬盘磁阵挂载合理分配各个分区的空间大小对于数据盘可以通过命令进行临时挂载例如也可以修改文件确保下次重启后自动挂载确保变量定义正确级别要求适用版本全部规则说明是的环境变量程序加载动态链接库时会优先从该环境变量指定的路径中获取通常情况下该环境变量不应该被设置如果被恶意设置为不正确的值程序在运行时就有可能链接到不正确的动态库导致安全风险注中配置也会影响动态库加载需要确保正确配置默认不设置该变量根据实际场景如果必须设置需确保在所有用户上下文中该值都是正确的规则影响无检查方法有多个配置文件可以永久设置值需要进行排查这些文件包括后两个文件为用户目录下的文件每个用户都有检查时务必不能遗漏使用命令进行检查举例中发现文件中设置了值检查当前用户上下文中是否存在值如果未设置则命令执行完以后打印为空否则打印出当前设置的值修复方法删除所有配置文件中配置项或将其设置为正确值确保用户变量被严格定义级别要求适用版本全部规则说明下变量定义的是当前用户上下文中可执行文件查找路径例如用户在任意目录下使用命令那么系统会在变量指定的目录下查找命令找到后执行所有用户上下文中的变量不能包含当前目录目录必须是在文件系统中真实存在并符合系统的设计期望的路径正确的值可以有效防止系统命令被恶意的指令替代确保系统命令能够安全执行所以变量应该被定义为正确的值系统默认设置为可以根据实际场景对进行修改但务必确保正确规则影响无检查方法通过命令可以打印出当前用户上下文中的值检查是否正确用户上下文中值如下普通用户上下文中值如下修复方法环境变量分为两部分一部分在文件中设置一部分在用户目录下或文件中设置前者影响所有用户后者只影响当前用户所以可以通过修改这两个文件中相关字段代码即可永久修改系统变量值例如如果只是临时修改当前会话的值可以执行如下命令会话关闭后失效或软件禁止安装客户端级别要求适用版本全部规则说明文件传输协议提供服务器同其他服务器桌面系统终端设备之间的文件传输功能协议本身不支持加密传输数据传输过程中容易被攻击者窃取所以禁止安装客户端并使用协议未安装客户端的设备无法对外通过协议进行传输如业务需要进行文件传输可以通过进行替代规则影响未安装客户端将无法同服务器进行协议连接检查方法可通过如下命令检查是否安装了软件如果命令返回为表示未安装修复方法对于已经安装了软件的系统可以通过或命令进行卸载或禁止安装客户端级别要求适用版本全部规则说明简单文件传输协议提供服务器同其他服务器桌面系统终端设备之间的文件传输功能协议本身不支持认证和加密机制通信过程中容易被攻击者仿冒篡改以及窃取所以禁止安装客户端和服务未安装客户端和服务的设备无法对外提供服务也无法使用客户端同外界基于协议进行通信如业务需要进行文件传输可以通过服务进行替代规则影响依赖于服务的程序执行受限制检查方法可通过如下命令检查是否安装了软件如果命令返回表示未安装修复方法对于已经安装了软件的系统可以通过或命令进行卸载或禁止安装客户端级别要求适用版本全部规则说明是一种应用层协议常用于服务器的远程登录操作控制系统修改等传输数据未被加密用户名口令传输数据等容易被攻击者窃取所以应禁止安装和使用客户端工具可以使用基于协议的客户端工具进行替代规则影响依赖于服务的程序执行受限制检查方法可通过如下命令检查是否安装了客户端软件如果命令返回表示未安装修复方法对于已经安装了软件的系统可以通过或命令进行卸载或禁止安装不安全的协议版本级别要求适用版本全部规则说明简单网络管理协议是专门设计用于在网络中管理网络节点的一种标准协议该协议允许网元之间传递相关网络管理控制数据对于不需要的场景如果安装了则增加了系统资源消耗并扩大了攻击面特别是如果使用了协议将导致攻击者可以轻易窃取篡改伪造报文对各网元进行攻击安装镜像中提供了安装包但默认未安装规则影响依赖于服务的程序执行受限制检查方法可通过如下命令检查是否安装了软件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或禁止安装级别要求适用版本全部规则说明社区已经于年月日停止维护与改进继续使用该软件容易扩大系统攻击面增加系统漏洞和被攻击风险所以禁止使用若有使用的诉求建议使用主流版本以减小安全风险安装镜像中不提供相关软件包规则影响依赖于的程序执行受限制检查方法可通过如下命令检查是否安装了软件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或确保源配置校验级别要求适用版本全部规则说明安装包在网络传输或本地存储时存在被攻击者恶意篡改的可能若未对安装包进行完整性校验则可能安装了攻击者篡改后的软件导致服务器甚至整个网络集群遭受攻击如果使用源进行操作系统软件安装升级必须配置校验支持使用或命令从源下载安装或升级包通过目录下的文件进行源配置必须配置校验在系统中必须已安装公钥或者在源配置文件中指定公钥下载地址公钥是校验包合法性的关键请确保安装可信的公钥规则影响无的源无法正常使用检查方法检查系统中是否已经加载公钥如果返回为空表示未安装公钥如果有不同的源配置可能会有多个不同的公钥返回检查源配置文件中是否包含有字段如果有多个配置文件则每个配置文件都应该设置该字段检查源配置文件中是否已配置公钥下载地址如果系统中已经安装有对应源的公钥则不是必须配置源公钥地址修复方法所有商用发布的包都经过私钥签名通过命令进行安装时会校验签名是否合法如果校验不通过可以安装但会给出告警提示如下禁止通过添加等方式跳过签名和完整性校验通过源进行包安装时必须在源配置文件中添加字段开启校验并添加正确的公钥下载地址源地址源公钥地址如果配置文件中不包含公钥下载地址则必须通过命令安装对应源的公钥如果有多个源则每个源可能有不同的公钥需要分别安装禁止启用服务级别要求适用版本全部规则说明服务主要是用来定位系统引导过程中出现的问题该服务随安装而被安装开启服务后可以在系统启动过程中启动阶段按下攻击者不需要认证直接进入该过程安全风险很高攻击者可以通过篡改数据执行非法程序等手段破坏系统默认禁止启动服务规则影响无检查方法检查是否启动了服务如果命令返回为则表示服务未启动修复方法对于已安装组件的服务器可以禁用服务禁止安装服务级别要求适用版本全部规则说明服务可以用于在服务器之间或者服务器本地不同硬盘分区之间同步数据但由于使用不加密的传输协议存在信息泄露的风险若启用服务并且在不同服务器之间通过网络传输数据则攻击者可以通过监听服务器端口或者路由器交换机数据报文窃取数据安装镜像中提供了安装包要求在生产环境中不启动服务规则影响依赖于服务的程序执行受限制检查方法步骤检查是否安装了软件如果命令返回为空则表示未安装符合规范要求检查结束否则继续执行步骤步骤安装了软件时检查服务是否开启表示未启用服务符合规范要求修复方法对于已安装组件的服务器可以禁用服务禁止安装服务级别要求适用版本全部规则说明是一种零配置的网络实现包括用于多播服务的自动发现及自动广播例如用户可以将服务器接入网络并让自动广播其上运行的网络服务从而方便其他用户访问这些服务通常并不需要自动发现或者自动广播业务如果启用不必要的服务不仅浪费了系统资源还扩大了攻击面攻击者可以轻易获取服务器服务情况并进行针对性的攻击规则影响依赖于服务的程序执行受限制检查方法检查是否安装了软件如果命令返回为空则表示未安装注意由于其他组件依赖系统默认安装有同时可以通过命令检查是否安装服务如下返回表示未启动且未安装服务修复方法对于已安装组件的服务器可以通过或命令进行卸载或禁止安装服务级别要求适用版本全部规则说明轻型目录访问协议是一个轻量级的目录访问协议提供访问控制和维护分布式的目录信息系统提供服务会增加系统资源占用且扩大了攻击面如果用户业务场景不需要提供服务则禁止安装服务安装镜像中提供了安装包但默认未安装规则影响依赖于服务的程序执行受限制检查方法检查是否安装了软件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或禁止安装打印服务级别要求适用版本全部规则说明通用打印系统启用该服务的服务器为网络内其他设备提供打印服务提供服务会占用系统资源并扩大攻击面如果业务场景不需要提供打印服务则禁止安装打印服务安装镜像中提供了相关的安装包但默认未安装规则影响依赖于服务的程序执行受限制检查方法检查是否安装了软件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或禁止安装服务端级别要求适用版本全部规则说明网络信息服务以客户端服务器形式存在客户端从服务器获取分发的配置信息服务本质上是一个不安全的服务容易受到缓冲区溢出等攻击如果业务不涉及服务禁止安装服务端安装镜像中提供了服务端安装包但默认未安装规则影响依赖于服务的程序执行受限制检查方法检查是否安装了软件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或禁止安装客户端级别要求适用版本全部规则说明网络信息服务以客户端服务器形式存在客户端从服务器获取分发的配置信息服务本质上是一个不安全的服务容易受到缓冲区溢出等攻击如果业务不涉及服务禁止安装并使用客户端安装镜像中提供了安装包但默认未安装规则影响依赖于服务的程序执行受限制检查方法检查是否安装了软件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或禁止安装客户端级别要求适用版本全部规则说明轻型目录访问协议是一个轻量级的目录访问协议提供访问控制和维护分布式的目录信息系统提供客户端会造成系统资源浪费且扩大了攻击面如果业务场景不需要使用服务则禁止安装客户端安装镜像中提供了安装包但默认未安装规则影响依赖于服务的程序执行受限制检查方法检查是否安装了软件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或禁止安装网络嗅探类工具级别要求适用版本全部规则说明生产环境中如果包含有网络嗅探类工具容易被攻击者利用这些工具进行网络分析辅助网络攻击所以应在生产环境中禁止安装各类网络嗅探抓包分析类工具例如等规则影响无检查方法编写脚本工具在生产环境或镜像环境中通过关键字扫描来判断是否存在网络嗅探类工具脚本中可以包含如下命令查找相关包是否被安装用户可根据自身场景在此基础上添加需要检查的所有包名此处只是举例实际包名及范围由用户确定如果返回为空表示未安装否则返回已安装的包列表查找相关命令是否被安装用户可根据自身场景在此基础上添加需要检查的所有命令名此处只是举例实际命令名及范围由用户确定如果返回为空表示未安装否则返回已安装的命令列表修复方法如果用户业务环境中安装有网络嗅探类软件需通过命令查找并删除软件包例如删除或者通过命令手工删除命令文件但这种方式仅限于非包方式安装的网络嗅探工具且需确保删除所有相关文件禁止安装调测类工具级别要求适用版本全部规则说明业务环境中如果包含有调测类脚本工具容易被攻击者利用并攻击所以应在生产环境中严禁安装各类调测工具文件包括但不限于代码调试工具用于调测功能的提权命令脚本工具调试阶段使用的证书密钥用于性能测试的工具打点打桩工具用于等安全问题验证的攻击脚本工具脚本等常见的开源第三方调测类工具包括等规则影响无检查方法编写脚本工具在业务环境或镜像环境中通过关键字扫描来判断是否存在调测类工具脚本中可以包含如下命令查找相关包是否被安装用户可根据自身场景在此基础上添加需要检查的所有包名此处只是举例实际包名及范围由用户确定如果返回为空表示未安装否则返回已安装的包列表查找相关命令是否被安装用户可根据自身场景在此基础上添加需要检查的所有命令名此处只是举例实际命令名及范围由用户确定如果返回为空表示未安装否则返回已安装的命令列表修复方法如果用户业务环境中安装有调测类软件需通过命令查找并删除软件包例如删除或者通过命令手工删除命令文件但这种方式仅限于非包方式安装的调测工具且需确保删除所有相关文件禁止安装开发编译类工具级别要求适用版本全部规则说明业务环境中如果包含有编译工具容易被攻击者利用对环境内关键文件进行编辑篡改逆向分析从而实施攻击行为所以应在生产环境中严禁安装各类编译反编译二进制分析类工具包括但不限于编译工具反编译工具编译环境等常见的第三方开发编译类工具包括等如果业务环境在部署或运行过程中依赖等解释器则可以保留解释器运行环境规则影响无检查方法编写脚本工具在业务环境或镜像环境中通过关键字扫描来判断是否存在开发编译类工具脚本中可以包含如下命令查找相关包是否被安装用户可根据自身场景在此基础上添加需要检查的所有包名此处只是举例实际包名及范围由用户确定如果返回为空表示未安装否则返回已安装的包列表查找相关命令是否被安装用户可根据自身场景在此基础上添加需要检查的所有命令名此处只是举例实际命令名及范围由用户确定如果返回为空表示未安装否则返回已安装的命令列表修复方法如果业务环境中安装有开发编译类软件需通过命令查找并删除软件包例如删除或者通过命令手工删除命令文件但这种方式仅限于非包方式安装的开发编译工具且需确保删除所有相关文件避免安装系统级别建议适用版本全部规则说明在系统中提供图形界面供用户登录和操作通常情况下服务器场景无需图形界面管理员通过命令行即可对服务器完成配置修改图形界面扩大了攻击面不常用或相对小众的图形界面组件可能存在较多的软件缺陷容易被攻击者利用进而对系统进行破坏另外在无需图形界面的服务器上安装组件浪费了服务器资源增加了维护成本规则影响相关组件无法使用检查方法检查是否安装了相关组件如果命令返回为空则表示未安装修复方法对于已安装组件的服务器可以通过或命令进行卸载或避免安装服务级别建议适用版本全部规则说明代表超文本协议是一个简单的请求响应协议它通常运行在之上它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应请求和响应消息的头以形式给出而消息内容则具有一个类似的格式服务器允许客户端通常是浏览器通过协议请求网页图像文档等内容并将这些内容传送给客户端规则影响依赖于服务的程序执行受限制检查方法可通过如下命令检查是否安装了客户端软件如果命令返回表示未安装修复方法对于已经安装了软件的系统可以通过或命令进行卸载或避免安装服务级别建议适用版本全部规则说明守护进程允许系统管理员配置系统以与桌面共享文件系统和目录将通过服务器信息块协议公布文件系统和目录桌面用户将能够将这些目录和文件系统作为盘符挂载在系统上规则影响与系统进行文件共享或打印共享受限制检查方法可通过如下命令检查是否安装了软件如果命令返回表示未安装修复方法对于已经安装了软件的系统可以通过或命令进行卸载或避免启用服务级别建议适用版本全部规则说明域名系统是一种分层命名系统它将名称映射到计算机服务和其它联网资源的地址除非系统被专门指定用作服务器否则建议禁用以减少潜在的攻击面规则影响将无法作为域名服务器提供域名解析服务检查方法检查是否启动了服务如果命令返回为则表示服务未启动修复方法对于已安装组件的服务器可以禁用服务避免启用服务级别建议适用版本全部规则说明网络文件系统是环境中最早也是分布最广泛的文件系统之一它为系统提供了通过网络挂载其他服务器的文件系统的能力如果系统不导出共享建议禁用以减少远程攻击面规则影响禁用会影响到系统上依赖的服务和应用程序以及现有的挂载点在禁用之前应确保了解系统上的使用情况并考虑是否有替代方法来满足文件共享和数据访问的需求检查方法检查是否启动了服务如果命令返回为则表示服务未启动修复方法对于已安装组件的服务器可以禁用服务避免启用服务级别建议适用版本全部规则说明服务将远程过程调用服务映射到它们侦听的端口进程在启动时通知注册它们正在侦听的端口以及它们期望服务的程序编号然后客户端系统使用特定的程序号联系服务器上的服务将客户端重定向到正确的端口号以便它可以与请求的服务进行通信如果系统不需要基于的服务建议禁用以减少远程攻击面规则影响无检查方法检查是否启动了服务如果命令返回为则表示服务未启动修复方法对于已安装组件的服务器可以禁用服务避免启用服务级别建议适用版本全部规则说明动态主机配置协议是一项允许为机器动态分配地址的服务除非系统专门设置为充当否则建议禁用该服务以减少潜在的攻击面规则影响无检查方法检查是否启动了服务如果命令返回为则表示服务未启动修复方法对于已安装组件的服务器可以禁用服务安全访问账户禁止无需登录的账号设置登录能力级别要求适用版本全部规则说明通常情况下系统中存在多个账号而这些账号并不一定都是需要登录的例如等软件安装时会自带安装一些账号这些账号只是为了运行相关的服务进程对于无需进行登录的账号必须禁止其登录能力如果允许非登录账号有登录能力将扩大攻击面攻击者可以利用这些账号进行交互操作从而攻击系统注意属于特殊账号通常情况下不能将设置为或这几个账号在文件中口令设置为所以并不能直接登录默认满足无需登录的账号不具备登录能力规则影响无检查方法检查的目的是确认是否所有不该登录的账号都被设置了或或对应的口令被锁定使用如下命令查看文件中非登录账号是否都已经被设置正确命令执行后会列出所有设置了禁止登录的账号可根据业务场景对这些账号进行比对使用如下命令查看文件中所有允许登录的账号命令执行后会列出所有允许登录的账号可根据业务场景对这些账号进行比对如下命令执行后会列出所有口令被锁定的账号可根据业务场景对这些账号进行比对如下命令执行后会列出所有口令未被锁定的账号可根据业务场景对这些账号进行比对修复方法有两种方法可以锁定和解锁用户账号通过命令修改文件将指定账号的登录设置为或该方法不仅可以防止用户登录还可以防止使用命令切换为指定用户账号优先推荐该方法操作如下为账号名锁定或解锁修改文件在指定账号的第二个字段中添加感叹号或锁定口令可通过如下命令操作为账号名如果账号并未设置口令则会提示操作失败锁定或解锁或使用命令锁定的口令可以使用命令进行解锁反之亦然锁定或解锁后可以通过如下命令检查状态表示口令已经锁定表示口令未设置表示口令已被设置且未锁定或或禁止存在不使用的账号级别要求适用版本全部规则说明如果系统中存在业务无关的账号容易被攻击者利用该账号进行攻击行为系统应该只保留业务所必须的账号其他用于安装部署调试验证以及问题定位等的账号都必须被删除默认满足不存在不使用的账号规则影响无检查方法默认只保留系统运行必须的账号根据自身业务场景确定是否存在业务无关账号可以使用如下命令查找系统中所有账号按照以下步骤进行查询和判断在未部署业务的平台上使用上述命令获取所有账号信息在完整部署业务的平台上使用上述命令获取所有账号信息对比两者返回结果对差异部分进行分析是否符合业务设计修复方法如果存在业务无关账号可通过如下步骤进行删除查找所有该账号为属主的文件并通过命令手工删除这些文件如下为账号名目录在删除账号时可通过参数自动删除表示需要被删除的文件或目录删除账号包括目录确保不同账号初始分配不同的组级别要求适用版本全部规则说明不同用户账号的初始登录组必须不同如果某个用户账号需要访问其他组的文件则需要通过命令明确指定加入该组在大多数情况下文件权限设置为文件夹设置为那么同组用户账号是可以对文件进行访问的所以如果两个不相干的用户账号被设置为同一个组存在文件被意外读取甚至篡改的可能默认满足不同账号初始分配不同的组规则影响无检查方法检查文件中各个账号所属的组是否不同可执行如下命令如果没有相同组则命令执行后无输出否则输出组号以及相同组的账号数量如下面例子中输出表示有两个账号的用户组为注意上面命令中过滤了用户组因为等系统账号都属于组属于例外场景在本规范中不做要求修复方法添加新账号时不使用参数指定而是让系统直接自动分配新的组此处参数表示需要创建新用户组默认可以不加或如果新账号需要被加入其它组则可以通过参数指定该命令为账号新建一个的组作为账号默认登录组另外会将账号加入用户组通过如下命令检查同的默认登录组不同通过如下命令可以看到账号同时被加入了组账号登录后或者切换可以通过命令切换到组命令执行后当前已经变成组的了但这并不会改变中的组如果是已有账号需要加入其他组则可以通过如下命令操作执行后账号被加入到组查看结果如下禁止存在为的非账号级别要求适用版本全部规则说明为的账号是系统中的超级管理员账号账号名业界约定俗成为系统中不允许存在非账号的等于如果将账号改为其他值而其他账号的改为那么就会导致账号拥有超级管理员权限主要有以下几个问题业界通用的安全扫描工具会认为账号设置了非法增加管理成本如果用户在使用账号时没有意识到是超级管理员可能因疏忽的缘故导致系统被破坏默认满足不存在为的非账号规则影响无检查方法通过如下命令检查文件中是否存在为的非账号如下例子中命令执行后返回表示账号的是如果没有为的非账号命令无返回输出修复方法直接修改对应账号的字段然后重启系统需要确保修改的不能同其他账号重复注意命令可以修改账号但如果被修改的账号原先为则会报错因为为的账号会被号进程使用所以只能通过手工方式直接修改文件确保账号组及口令文件权限正确级别要求适用版本全部规则说明操作系统中用户账号口令用户组等认证相关信息都记录在目录下的配置文件中这些文件需要设置合理的访问权限否则容易被攻击者窃取或篡改这些文件属主和属组必须为和组对应的访问权限必须为文件设置值如果权限配置比表格中更加严格则普通用户登录时可能无法读取或配置文件中的信息导致登录或者执行操作失败如果权限配置比表格中更加宽松则可能导致配置文件信息被攻击者窃取或篡改规则影响无检查方法使用如下命令进行检查如果返回信息同上表不符则表示未满足权限要求修复方法如果文件权限不符合规范要求可以通过和命令进行修改确保账号拥有自己的目录级别要求适用版本全部规则说明每个用户账号必须有自己的目录用来存放账号相关的数据该目录的属主必须是用户自身如果目录属主不是自身那么可能无法对该目录进行读写或者该目录下保存的用户数据可以被其他用户如属主读取或篡改如果没有目录则用户账号登录后将无法获取到自身的环境配置数据默认满足每个账户拥有自己的目录规则影响无检查方法使用如下脚本进行检查如果无返回输出则表示所有用户账号均有目录目录属主正确修复方法删除相应的用户账号使用命令添加用户账号同时自动创建目录确保中的组都存在级别要求适用版本全部规则说明要求在中涉及到的用户组都必须在文件中真实存在如果管理员通过手工方式修改这两个文件则可能因为人为错误而导致用户组不正确如果中的用户组在中不存在那么将导致用户组权限管理风险规则影响无检查方法使用如下脚本进行检查如果无返回输出则表示所有用户组设置正确修复方法分析两个文件不匹配的原因可以有两种修复方式通过删除账号重新添加的方式进行修复通过删除或添加组的方式进行修复其中表示的值确保唯一级别要求适用版本全部规则说明要求在中涉及到的用户账号唯一系统中根据来判断账号权限如果多个账号使用同一个则会导致这些账号拥有一样的权限可以相互访问目录以及各自创建的文件导致越权以及信息泄露通常情况下使用等命令添加用户账号不会存在重复问题但如果管理员操作失误直接修改文件则可能导致问题规则影响无检查方法使用如下命令进行检查如果无返回输出则表示所有设置正确且唯一否则列出和对应的复用次数如这个被两个账号使用修复方法分析被重复使用的原因然后删除出现问题的账号并重新添加确保账号名唯一级别要求适用版本全部规则说明要求在中涉及到的账号名唯一如果中的账号名重复则实际只有文件中第一个该账号的有效通常情况下使用等命令添加用户账号不会存在账号名重复问题但如果管理员操作失误直接修改文件则可能导致问题规则影响无检查方法使用如下命令进行检查如果无返回输出则表示所有账号名唯一否则列出账号名和对应的复用次数如这个账号存在重复修复方法分析账号名被重复使用的原因然后手工删除文件中出现问题的账号并按需确定是否使用命令重新添加正确的账号确保唯一级别要求适用版本全部规则说明要求在中涉及到的用户组唯一系统中根据来判断用户组权限如果多个用户组使用同一个则会导致这些用户组拥有一样的权限可以相互访问拥有组权限的目录导致越权以及信息泄露通常情况下使用等命令添加用户账号用户组不会存在重复问题但如果管理员操作失误直接修改文件则可能导致问题规则影响无检查方法使用如下命令进行检查如果无返回输出则表示所有唯一否则列出和对应的复用次数如这个被两个用户组使用修复方法分析被重复使用的原因然后删除出现问题的用户组注意修复时需按照实际场景先删除属于该用户组的用户账号确保组名唯一级别要求适用版本全部规则说明要求在中涉及到的用户组名唯一如果中的用户组名重复则实际只有文件中第一个该用户组的有效通常情况下使用等命令添加用户账号用户组不会存在用户组名重复问题但如果管理员操作失误直接修改文件则可能导致问题规则影响无检查方法使用如下命令进行检查如果无返回输出则表示所有用户组名唯一否则列出组名和对应的复用次数如这个组名存在重复修复方法分析用户组名被重复使用的原因然后手工删除文件中出现问题的用户组并按需确定是否使用命令重新添加正确的组名应当正确设置账号有效期级别建议适用版本全部规则说明账号应该根据自身的应用场景进行生命周期管理例如临时创建的管理维护账号定期业务所需要的账号业务生命周期结束账号生命周期也结束了对于这类账号应该在生命周期结束时就直接删除但由于管理原因往往容易遗忘所以建议管理员在创建账号的过程中同时设定账号的过期时间注系统账号可根据业务实际情况设置系统账号通常用于系统服务及程序运行不具备登录条件不需要关注有效期如果账号已经不再需要但并没有被删除也没有被禁用那么由于该账号相关管理疏漏有可能导致口令泄露或者账号被非法使用例如原本用于日志维护的临时账号应该在个月后过期但到期后并没有被禁用那么相应的管理人员在后续的时间内依旧可以使用该账号登录系统导致安全风险规则影响过期账号无法正常登陆检查方法检查文件中除默认账号及无法登陆的账号外所有的账号的第个字段是否有值这个值是从年月日开始计算的天数累加值例如这个值如果是表示账号有效期到年月日点过期可以通过如下命令检查如果设置了过期时间则直接返回该值否则无返回数据为需要检查的账号修复方法通过命令设置账号的过期时间如为需要被设置的账号为过期时间避免目录下存在文件级别建议适用版本全部规则说明文件可以配置一个地址当用户收到邮件时会自动转发到该地址如无相关邮件转发场景建议删除文件如果存在文件可能导致携带有敏感信息的用户邮件被自动转发到高风险的邮箱规则影响无检查方法使用如下脚本进行检查如果无返回输出则表示所有目录下无文件修复方法使用命令将检查方法找到文件删除避免目录下存在文件级别建议适用版本全部规则说明文件保存用于登录远端服务器的口令如无相关场景建议删除文件文件中存储的口令是明文的容易被攻击者窃取从而导致服务器敏感数据泄露甚至服务器遭受攻击规则影响服务器自动登录受限制检查方法使用如下脚本进行检查如果无返回输出则表示所有目录下无文件修复方法使用命令将检查方法找到文件删除口令确保口令复杂度设置正确级别要求适用版本全部规则说明口令设置过于简单容易被猜测太短的口令纯数字或纯字母的口令容易被暴力破解工具猜测出来在系统设置口令时应强制用户使用复杂口令对于高安全要求的业务场景可参考业界最佳实践比如口令长度设置为位或更长对于四种字符组合建议每种字符至少出现一次保证口令不会被轻易破解要求设置口令复杂度如下口令长度至少个字符口令必须包含如下至少种字符的组合至少一个小写字母至少一个大写字母至少一个数字至少一个特殊字符和空格考虑到在不同场景下的易用性默认不配置和值请根据实际场景按需配置规则影响口令规则太过复杂又会影响系统的易用性给用户的正常使用造成不便所以可以根据实际需求和使用场景设计符合安全要求的口令复杂度检查方法方法和分别提供该功能项的配置不同应用程序或者服务对应的配置项需根据各自的配置文件而定以上只列举部分显示结果从以上结果可知和的账号认证采用文件中的配置后续以为例进行说明在文件中检查设置口令复杂度的配置情况方法在文件中检查设置口令复杂度的配置情况此处仅列举本规范关注的配置项修复方法方法口令复杂度的设置可以通过修改和文件实现以文件为例具体配置字段如下方法在文件中配置如下字段配置项参数字段说明如下表配置项说明口令长度至少包含个字符说明建议配置更长的口令最小长度口令至少包含大写字母小写字母数字和特殊字符中的任意种口令包含任意个大写字母口令包含任意个小写字母口令包含任意个数字口令包含任意个特殊字符每次修改最多可以尝试次本设置对账号同样有效禁止使用历史口令级别要求适用版本全部规则说明频繁使用相同的历史口令容易造成口令泄露而被攻击者攻击为了用户账号的安全需要配置禁用历史口令功能根据业务实际场景合理的设置禁用历史口令次数但不得小于次考虑到社区版本在不同场景下的易用性发行版默认不配置禁用历史口令请根据实际场景按需配置规则影响禁止历史口令次数设置过大易增加口令管理成本检查方法和都各自提供该功能项的配置不同应用程序或者服务对应的配置项需根据各自的配置文件而定在文件中检查禁用历史口令的配置情况检查配置值是否不小于在文件中检查禁用历史口令的配置情况检查配置值是否不小于修复方法禁用历史口令的设置可以通过修改和文件实现在文件配置如下字段在文件配置如下字段配置项参数字段说明如下表配置项说明口令不能修改为过去次使用过的旧口令本设置对账号同样有效确保用户修改自身口令时需验证旧口令级别要求适用版本全部规则说明为了防止第三方恶意修改其他账户口令用户修改自身口令时需验证旧口令按照业界通用做法账号修改自身口令时不需要验证旧口令账号可以直接修改和文件在修改自身口令时验证旧口令无实质的安全提升所以遵循业界通常做法账号在修改口令时无需验证旧口令而普通账号需要验证通过旧口令后才能进行新口令的设置否则会引发安全风险例如普通账号的所有者在登录系统后未锁定屏幕而直接离开座位附近的攻击者可以在终端上修改该普通账号的口令该规则为模块默认支持无需额外配置规则影响普通用户如果忘记旧口令则无法自行修改口令降低易用性检查方法账号更改口令情况如下普通账号如更改口令修复方法该规则为模块默认支持无需配置确保口令中不包含账号字符串级别要求适用版本全部规则说明为了用户账号的安全要求配置口令中不包含账号字符串功能口令跟账号名字符相同或者是账号名字符逆序容易被攻击者猜测而且口令中包含账号名字符也增加了口令被破译的风险账号名小于等于个字符的情况下不作要求但建议实际场景中设置长度合理的账号名账号名大于个字符时其口令不能是如下字符账号名称账号名称逆序包含账号名称字符规则影响无法设置包含账号字符串的口令检查方法和分别提供该功能项的配置不同应用程序或者服务对应的配置项需根据各自的配置文件而定以上只列举部分显示结果从以上结果可知和的账号认证采用文件中的配置后续以为例进行说明在文件中检查口令中不包含账号字符串的配置情况不应包含字段修复方法是一个执行口令质量检测的模块默认支持口令中不包含账号字符串该功能所以配置文件中包含该模块且未配置即可实现对应的功能反之则无法实现通过修改和文件实现以文件为例如果配置中存在字段则删除具体配置字段如下确保口令使用强算法加密级别要求适用版本全部规则说明出于系统安全考虑口令不允许明文存储在系统中应该加密保护在不需要还原口令的场景必须使用不可逆算法加密如果加密算法强度过低攻击者可以通过加大算力在口令被更新前强行计算出相同结果的原始字符串无论该字符串是否同原口令一致均可用以登录对应账号目前业界已知的等弱算法均可在有限算力情况下碰撞出相同密文的两段不同原文对用户账号的口令使用强算法进行加密能有效加大口令被碰撞破解的难度从而降低口令泄漏的风险可根据实际需求进行口令加密算法配置但是配置的算法强度不得低于目前口令加密默认采用算法已满足安全要求规则影响无检查方法和分别提供该功能项的配置不同应用程序或者服务对应的配置项需根据各自的配置文件而定以上只列举部分显示结果从以上结果可知和的账号认证采用文件中的配置后续以为例进行说明在文件中检查口令使用强算法加密的配置情况修复方法口令使用强算法加密的设置可以通过修改和文件实现以文件为例具体配置字段如下确保弱口令字典设置正确级别要求适用版本全部规则说明若用户口令是弱口令就很容易被攻击者猜测到或者在较短时间内通过字典攻击法进行破解弱口令字典是一个包含强度不够容易被猜测到的口令的集合弱口令包括系统默认的口令过去曾被泄露的口令等提供口令字典检查功能在创建修改口令的时候检查如果命中则禁止使用该口令弱口令字典可更新可扩展可根据实际业务场景设定适合本业务的弱口令字典在升级场景中需要注意历史版本是否启用了弱口令字典检查或者新版本是否新增了弱口令清单规则影响原系统中可以使用的口令在新版本中可能被认定为弱口令导致口令无法设置成功检查方法方法和分别提供该功能项的配置不同应用程序或者服务对应的配置项需根据各自的配置文件而定以上只列举部分显示结果从以上结果可知和的账号认证采用文件中的配置后续以为例进行说明在文件中检查设置弱口令字典的配置情况如果没有配置则默认为开启无需手动配置使用如下命令导出字典库到文件中方法在文件中检查弱口令字典的配置情况如果没有配置则默认开启无需手动配置修复方法是一个执行口令质量检测的模块默认支持设置弱口令字典功能使用如下操作可以更新弱口令字典库使用如下命令导出字典库到文件中将弱口令字典导出并修改后可执行如下命令进行字典库更新可在原字典库基础上新增其他字典内容如确保口令有效期设置正确级别要求适用版本全部规则说明如果口令长期不修改则通过暴力破解等方法容易增加口令被破解的可能性从而影响系统安全但该值如果设置过小则导致口令频繁修改增加管理成本且容易导致用户因长时间未登录而无法再次登录所以在设置该值时需要根据实际业务场景进行判断口令需要设置有效期口令过期后用户重新登录时提示口令过期并强制修改否则无法进入系统口令最大有效期应为天或者更短口令过期前天或更长时间应开始提示用户修改口令两次修改口令的最小间隔时间建议设置为天可根据业务场景调整由于是最高权限账号如果长期未登录导致口令过期或者因为频繁修改导致遗忘系统将无法登录存在管理风险建议根据实际业务场景决定是否设置口令过期时间对于需要频繁登录账号的场景建议设置较短的过期时间对于日常管理使用非账号的建议设置相对较长的过期时间考虑到社区版本在不同场景下的易用性发行版默认不配置口令有效期和两次修改口令的最小间隔时间请根据实际场景按需配置规则影响口令有效期设置过长会降低安全性增加被暴力破解的概率设置过短会增加口令的管理复杂度口令过期前提醒设置过长会过早提醒降低用户体验设置过短会导致用户错过修改口令时间两次修改口令的最小间隔时间设置过短用户可以频繁更改口令以规避历史口令防重用检查机制检查方法检查文件中是否已经配置相关字段检查文件中指定账号的配置是否正确修复方法有两种设置方法修改文件中的默认配置对后续新建账号口令默认生效修改文件中具体某个账号的口令有效期新增的账号口令的默认有效期同文件中定义一致对应的值会写到文件中例如文件中每一行记录一个账号的口令信息通过冒号划分为个字段如上举例中第字段表示两次修改口令的最小间隔时间默认为表示不作限制第字段表示口令最大有效期自设置之日起默认天设置成表示永不过期第字段表示口令过期前几天开始提醒默认天第个字段表示口令修改有效期过期后几天内允许用户修改时间段内用户登录时强制要求修改口令超过这个时间直接拒绝用户登录默认值是天管理员可通过命令进行修改设置两次口令修改最小间隔时间设置口令最大有效期设置口令过期前提醒时间设置口令修改有效期无法通过设置默认值禁止空口令登录级别要求适用版本全部规则说明空口令登录是指在用户账号登录时不输入口令的情况下也能成功登录系统若允许空口令登录会增加空口令账号本身被攻击或被用来作为攻击账号的风险规则影响无检查方法检查中是否配置了禁止空口令登录的字段修复方法在中配置禁止空口令登录并重启服务确保已设置口令保护级别要求适用版本全部规则说明是的默认引导程序通过引导程序可以设置系统的启动模式而设置口令可以防御攻击者通过修改设置进入单用户模式如果没有设置口令攻击者可以轻易进入编辑菜单通过修改启动参数进行攻击行为例如进入单用户模式修改口令窃取数据和是两种不同的引导方式对应的配置文件路径会存在差异的配置路径为的配置路径为规则影响需要验证口令后才能进入编辑菜单检查方法模式下方法查看配置文件是否存在相关配置是定义在文件中的口令密文表示密文内容方法查看配置文件是否存在相关配置模式下方法查看配置文件是否存在相关配置是定义在文件中的口令密文表示密文内容方法查看配置文件是否存在相关配置修复方法在安装阶段通过人工方式在图形界面设置口令建议用户首次登录时修改口令并定期更新避免口令泄露后启动选项被篡改导致系统启动异常在终端输入后根据提示输入明文口令后生成加密的口令密文表示密文内容模式下将新口令密文输出到文件中模式下将新口令密文输出到文件中系统下次重启时如果需要进入菜单将需要验证新口令确保单用户模式已设置口令保护级别要求适用版本全部规则说明编辑启动菜单在启动命令行添加或命令可以进入单用户模式单用户模式属于紧急救援模式可以对系统进行修改例如修改口令所以要求在进入单用户模式时验证口令系统默认已经加固进入单用户模式必须输入口令规则影响如果管理员忘记口令将无法通过单用户模式进入系统修改检查方法通过命令检查和服务中是否使用登录修复方法在文件中修改项为在文件中修改项为确保账号在首次登录时强制修改口令级别要求适用版本全部规则说明对于非用户本人设置的口令如管理员重置的口令如果在业务环境上没有被及时修改极易引起低成本的攻击事件所以要求用户在首次登录账号时强制修改口令口令除外规则影响无检查方法检查文件中指定账号的配置是否正确此处以冒号分割的第个字段如果是表示此账号对应口令已被强制设置为过期修复方法管理员在重置账号口令后通过如下命令可以将该口令立即过期该账号下次登录时会被要求强制口令修改此种方式过期的口令不受口令修改有效期默认天的约束为举例的账号身份认证确保登录失败一定次数后锁定账号级别要求适用版本全部规则说明用户使用账号登录系统如果连续登录失败一定次数后系统会锁定该账号登录即一定时间内不允许该账号继续登录防止恶意的破解系统口令账号锁定期间任何输入被判定为无效锁定时间不因用户的再次输入而重新计时解锁后错误输入记录被清空通过上述设置可以有效防范口令暴力破解增强系统的安全性系统默认设定的连续登录失败次数为次登录失败后默认锁定的时间为考虑到社区版本在不同场景下的易用性发行版默认不提供该项安全功能用户应根据实际应用场景和需求对默认的失败次数和锁定时间进行配置规则影响失败次数数值设置过小和锁定时间的数值设置过大会影响使用体验检查方法和分别提供该功能项的配置不同应用程序或者服务对应的配置项需根据各自的配置文件而定以上只列举部分显示结果从以上结果可知和的账号认证采用文件中的配置后续以为例进行说明在文件中检查连续失败登录次数的配置情况在文件中检查锁定时间的配置情况修复方法可以通过修改和中所有和字段后的数来分别完成对连续失败登录次数和锁定时间的配置以文件为例具体配置字段如下确保会话超时时间设置正确级别要求适用版本全部规则说明设置合理的会话超时时间可以降低因管理员人为原因而导致系统被攻击者攻击的风险考虑到社区版本在不同场景下的易用性发行版默认不配置会话超时时间请根据实际场景按需配置规则影响会话超时时间设置过长甚至永不超时当管理员离开时没有退出登录其他人员就可以直接在终端上以管理员权限进行操作如果设置过短则频繁锁定增加管理员输入口令次数降低用户体验的同时也容易引入安全风险管理员周边人员有较多的机会可以窥探到输入的口令检查方法修复方法修改文件字段根据业务场景修改为合理的值使用命令使之生效确保包含合理的信息级别要求适用版本全部规则说明包含有系统登录界面添加的警告信息为所有登录系统的用户标识出本系统的安全警告安全警告可以根据业务场景包括系统所属的组织登录行为所受到的监视或者记录非授权登录或者入侵会受到的法律制裁等内容不合适的安全警告信息可能增加系统被攻击的风险或触犯当地法律法规不应将系统版本应用服务器类型功能等暴露给用户避免攻击者获取到系统信息实施攻击除此之外还需要正确配置文件所有权否则未经授权的用户可能会使用不正确或误导性信息来修改文件规则影响无检查方法通过命令查看三个文件中警告信息是否合理是否存在系统版本应用服务器类型功能等信息通过命令查看三个文件权限是否为修复方法通过命令修改三个文件中的告警信息通过命令修改三个文件的权限为应当正确配置路径级别要求适用版本全部规则说明路径指向一个文件文件中包含有用户登录前在客户端给出的提示信息用户可根据实际业务场景配置该文件中的内容如果不配置则默认没有显示规则影响无检查方法使用命令查看配置如果返回为空表示未配置修复方法修改文件配置字段指向的文件重启服务修改指向文件中的内容访问控制限制历史命令记录数量级别建议适用版本全部规则说明是一个环境变量用于控制命令历史记录的大小具体来说定义了命令历史记录中可以存储的命令条目数量通过设置的值可以限制或增加命令历史记录的大小从而控制在命令行终端中可用的以前输入的命令数量例如设置将限制命令历史记录最多存储条命令一旦命令历史记录达到这个限制新的命令将会覆盖最旧的命令以保持历史记录的大小不超过指定的值作用较小的历史记录可以减少敏感信息如密码在历史记录中被保留的风险建议系统限制查看历史命令的数量建议或规则影响限制的值设置过小会导致历史使用的命令不可见易用性下降检查方法查看环境变量设置的值查看文件设置的值如果检测中输出为范围且检测中等于号之后输出的值为的范围说明通过检查否则检测未通过修复方法查看文件中环境变量的值运行以下命令设置历史命令记录数量为范围内的值并生效即可应当启用模式级别建议适用版本全部规则说明是发行版中内置的安全模块通过细粒度的访问控制机制实现应用程序对资源的访问控制从而提高系统的安全性的运行模式有三种强制模式当访问无权限时阻止资源访问并记录日志宽容模式当访问无权限时仅记录日志不阻止资源访问禁用模式关闭功能只有工作在模式时才能有效启用并保护系统若工作在其它模式则无法对系统提供保护而系统中的进程会默认有较大的权限尤其是以身份运行的进程可能会给系统带来安全风险规则影响系统开启模式会拒绝部分高风险操作依赖于策略配置易用性降低检查方法输入命令查看当前系统运行模式是否为使用如下命令查看系统默认运行模式是否为修复方法使用命令设置当前系统的运行模式设置文件中的参数重启操作系统后生效应当正确配置策略级别建议适用版本全部规则说明的策略分为两种系统基础策略和自定义策略基础策略定义在基础策略包中的策略包括等自定义策略用户修改或添加的策略可以实现进程级别的强制访问控制通过根据最小权限原则配置合理的策略限制系统中关键应用和关键资源的行为可以提高系统的安全性如果未对应用程序配置合理的策略可能产生两种影响如果未对应用程序配置策略应用程序有可能运行在或其他权限较大的域若被攻击可能对系统或业务造成较大影响如果为应用程序配置了不合理的策略有可能影响应用程序的正常运行规则影响无检查方法运行以下命令查看当前系统策略建议配置为运行以下命令输出为空表示无异常规则和异常访问行为若不为空需要分析被禁止的访问行为是否为正常访问行为如果为正常访问行为则需要修改策略修复方法设置基础策略包为策略包安装目标基础策略包设置文件中的参数以修改系统基础策略包在根目录下创建文件用于系统重启后刷新文件标签重启操作系统若应用程序运行异常需要为应用程序配置合理的策略确保受限使用级别要求适用版本全部规则说明命令可以使一个普通用户拥有超级用户或其他用户的权限它经常被用于从普通用户账号切换到系统账号命令为用户变更身份提供了便捷的途径但如果不加约束的使用命令会给系统带来潜在的风险通过对用户使用访问账号的权限进行限制仅对部分账号进行使用授权可以提高系统账号使用的安全性默认仅允许组中的普通用户具有的使用权限规则影响非组用户无法使用检查方法检查中是否配置了非组用户账号禁止使用修复方法修改配置文件配置非组用户账号禁止使用确保普通用户通过运行特权程序级别要求适用版本全部规则说明可以使设定的普通用户以权限执行某些特定的程序大部分系统管理命令都需要使用权限执行对于系统管理员来说适当地对其他用户授权可以减轻系统管理员负担但直接授予普通用户口令会带来安全风险使用则可以规避这一问题系统中需要以账号运行的特权程序可以使用机制避免使用账号登录使用代替用户运行特权程序不仅可以减轻系统管理员负担同时由于使用时无需输入口令这提高了安全性规则影响无检查方法检查中是否配置了普通用户执行说明示例中为可以使用执行的程序实际上具体的程序由用户根据业务场景进行配置修复方法修改配置文件对需要以执行指定特权的用户配置权限上一行配置一共包含四个字段如上举例中第一个字段为用户账号实际配置时还可以指定为某一用户组这样该用户组内的所有用户账号均可按后边的规则执行第二个字段意思是在任何主机名下都适用第三个字段表明第一个字段所设定的用户账号或用户组可以切换到下执行特权程序第四个字段中即为指定的特权程序多个特权程序用逗号隔开确保不能配置低权限用户可写的脚本级别要求适用版本全部规则说明可以使设定的普通用户以权限执行某些特定的程序与之对应的配置文件为管理员用户可以配置相应的规则使某些脚本或二进制文件以的权限运行所以配置的脚本应该只有可写不能配置低权限用户可写的脚本若配置了低权限用户可写的脚本则该用户可以通过修改该脚本实现提权操作规则影响无检查方法检查配置文件检查特权程序是否为低权限用户可写修复方法例如一个配置文件中的脚本为低权限用户可写则用户需要根据实际的业务场景进行修复修复方法修改配置文件中的脚本的文件权限去除掉低特权用户的可写权限以防止该用户实现提权操作修复方法修改配置文件删除低权限用户可配置的脚本文件防止低权限用户实现提权操作确保普通用户不能借助配置提权级别要求适用版本全部规则说明命令可以使一个普通用户拥有超级用户或其他用户的权限当验证通过后便会以超级用户的权限来执行相应的程序为用户变更身份提供了便捷的路径但是如果不加约束的使用命令会给系统带来潜在的安全风险通过对用户使用访问账号的权限进行限制限制了其他账号的使用可以提高系统账号使用的安全性默认配置使用需要验证口令且仅有可获得系统管理员权限规则影响普通用户不能使用检查方法检查中是否配置了仅用户可以使用修复方法修改配置文件仅用户可以使用确保命令继承用户环境变量不会引入提权级别要求适用版本全部规则说明命令可以使一个普通用户拥有超级用户或其他用户的权限它经常被用于从普通用户账号切换到系统账号命令为用户变更身份提供了便捷的途径但如果不加约束的使用命令会给系统带来潜在的风险命令切换用户时不会自动为用户设置如果通过切换用户后系统会自动初始化环境变量则可以有效防范由于继承环境变量而导致的提权问题默认设置完成后会自动初始化规则影响无检查方法检查中是否配置了自动初始化环境变量即修复方法修改配置文件添加如下配置使切换用户后系统会自动初始化环境变量避免用户本地接入系统级别建议适用版本全部规则说明是系统中的超级特权用户具有所有系统资源的访问权限如果允许直接使用账号登录系统对系统进行操作会带来很多潜在的安全风险为了规避由此带来的风险应禁止直接使用帐号登录操作系统仅在必要的情况通过其他技术手段如或间接的使用账号由于账号拥有最高权限直接使用登录存在如下风险高危误操作可能直接导致服务器瘫痪例如误删除修改系统关键文件如果有多人需要权限操作则口令将有多人保管容易导致口令泄露同时增加了口令维护成本默认不进行配置如果实际场景中不存在需要使用账号在本地登录的情况建议禁用账号本地登录规则影响账号无法本地接入系统检查方法检查文件中是否添加了类型的模块且该模块必须在控制行之前加载并且检查文件中是否设置对用户登录的限制使用串口尝试登录账号确认是否拒绝登录如果拒绝登录串口打印信息如下修复方法在文件中添加了类型的模块且该模块必须在控制行之前加载在文件中添加对用户登录的限制避免使用标签为的程序级别建议适用版本全部规则说明设置标签的目的是使一些未配置策略的第三方服务进程不受约束地运行默认情况下运行标签为或一般位于等目录下的第三方应用程序时产生的进程标签为与其他高权限标签如等的区别是只有极少的域转换规则这意味着即使进程运行那些已经配置过策略的应用程序新进程的标签也依然为进程配置的策略也不会生效如果被攻击会对系统造成较大的影响规则影响标签为的程序运行受限制检查方法运行以下命令若返回值为空表示当前系统中没有标签为的进程修复方法为应用程序配置合理的策略并添加域转换规则使其被执行时转换到配置策略的进程标签完整性应当启用度量级别建议适用版本全部规则说明完整性度量架构是内核提供的完整性保护功能开启时可基于用户自定义的策略为系统中的重要文件提供完整性度量度量结果可被用于本地以及远程完整性证明系统未开启度量功能时无法实时记录关键文件的摘要信息不能识别对文件内容或属性的篡改本地证明远程证明等保护系统完整性的功能依赖于度量提供的摘要值因此也无法使用或者完整性保护不全全局策略配置与具体环境相关通常情况下完整性保护只针对于不可变文件如可执行文件动态库等如果策略配置不当可能导致性能及内存开销过大建议用户根据自身情况决定是否开启并配置正确的策略注意由于只是全局完整性保护机制中的度量部分要完整使用需依赖及远程证明服务本规范仅对度量部分进行说明建议如果系统未集成及远程证明服务则不应启用度量功能度量不支持容器环境和虚拟机环境且要求启动不支持模式规则影响开启度量会导致系统启动时间和文件访问时间有轻微增加如果策略配置不当如对实时变化的日志文件临时文件等进行度量可导致度量日志增长过快占用系统内存过大且度量日志所占用内存在系统下次重启前不会被释放进而影响业务正常运行另外由于被度量文件一直在变化引发度量值变化而远程证明基线值无法同步更新导致远程证明失败失去完整性保护的意义检查方法首先确认当前内核启动参数中是否配置了如果查不到该参数则说明没有开启确认开启后查看文件中存储的度量记录数如果该值大于则表示已配置度量策略修复方法在文件中配置启动参数其中后两个参数可不配置并重启系统配置度量策略一共有两种方式在目录下添加策略文件该方式比较灵活可以在文件中自定义各自策略在启动参数中配置该方式使用系统默认的几种策略默认策略度量文件范围大请谨慎使用并重启系统应当启用入侵检测级别建议适用版本全部规则说明是一款入侵检测工具可以用来检查系统中文件和目录的完整性识别遭到恶意篡改的文件或目录其完整性检查的原理是先构造一个基准数据库该数据库包含文件或目录的一些属性如权限所属用户等在进行完整性检查时将当前系统的状态与基准数据库进行对比得出检查结果最后报告当前系统的文件或目录变更情况即检查报告启用入侵检测能有效识别恶意篡改文件或目录的行为从而提升系统完整性安全需要检查的文件或目录可以按需配置灵活性高用户只需要查询检查报告即可以判断是否存在恶意篡改行为规则影响需检查的文件越多检查过程所需时间越长如果用户启用应根据自身业务场景合理配置检查策略检查方法检查是否安装了软件包如果返回表示未安装检查文件中是否已经配置需要监控的文件或目录举例仅表示默认配置监控目录中的目录用户若自行配置了需要监控的文件或目录则确认相应的文件或目录已配置即可检查是否存在基准数据库修复方法如果未安装则使用或命令安装软件包或在配置文件中配置需要被监控的文件或目录中默认已经配置了部分需要监控的目录包括等重要目录用户可以根据需要自行添加需要监控的文件或目录生成基准数据库执行初始化命令后在目录下生成将其重命名即为基准数据库入侵检查执行检查的结果会在屏幕打印同时会保存到日志文件中更新基准数据库数据安全应当启用服务级别建议适用版本全部规则说明服务提供了一个易用的不可预测的随机数生成器生成的随机数用于补充系统熵池可解决某些情况下系统熵过低的问题建议在有加解密或生成密钥需求的场景下例如使用和都开启此服务如果服务没有开启需要生成强伪随机数的进程从取值时会因为取不到足够的值而陷入等待直至取到新的随机字节后才返回规则影响无检查方法检查环境中服务是否处于正常运行状态如果显示处于状态说明服务正在运行反之如果显示处于状态说明服务未开启修复方法开启服务如果要将其设置为随系统启动可以这样配置应当设置全局加解密策略配置不低于级别建议适用版本全部规则说明系统全局加解密策略用于指定加解密组件允许的算法通过修改配置文件可以改变预置的安全策略级别从而改变应用程序可使用的算法集系统默认配置策略提供可供选择建议用户设置不低于的策略级别即禁止设置模式策略可确保与旧系统的最大兼容性但是该策略的安全性较低该策略提供的安全级别至少为位策略是符合当前标准的默认策略该策略提供的安全级别至少为位策略是为即将发布的操作系统准备的策略该策略提供的安全级别至少为位注所需的签名和其他仍普遍使用的签名除外策略为安全级别较高的策略可以抵御近期大多数的攻击方式该策略提供的安全级别至少为位策略是符合要求的策略该策略提供的安全级别至少为位规则影响如果全局加解密策略设置过于宽松将允许使用不安全加解密算法降低系统整体安全性如果全局加解密策略设置过于严格则可能由于客户端不支持更加安全的加解密算法而导致存在兼容性问题如果业务程序未使用系统加解密模块而是自行调用第三方加解密算法库进行操作则不受影响检查方法检查环境中文件是否未配置模式如果返回信息为空或者仅返回位于注释信息中的字段表示未配置亦可通过如下方式检查当前配置的模式修复方法在文件中配置合适的策略运行和服务网络避免使用不常见网络服务级别建议适用版本全部规则说明一些不常见的协议往往使用场景较少社区发展较慢安全问题不易被快速解决如果未关闭这些并不使用的协议可能导致攻击者利用协议或代码漏洞进行攻击流控制传输协议是一种在网络连接两端之间同时传输多个数据流的协议提供的服务与和类似透明进程间通信是一种用于进程间通信的网络通信协议原本是为集群间通信特别设计的它允许设计人员能够创建可以和其它应用快速可靠通信的应用无须考虑其它需要通信的应用在集群环境中的位置如果业务场景不需要使用和等服务要求从内核中关闭支持减小攻击场景规则影响无检查方法使用命令检查如果输出表示已经被禁止使用如果输出表示未被禁止并列出所在目录如果输出表示不存在该文件可不用处理使用命令检查如果输出表示已经被禁止使用如果输出表示未被禁止并列出所在目录根据平台不同即使已经禁用命令执行后也可能会列出的依赖如和可不用处理如果输出表示不存在该文件可不用处理修复方法在目录下添加一个任意文件名并以为后缀的配置文件属主和属组均为权限按照如下格式填入内容即可禁用和协议避免使用无线网络级别建议适用版本全部规则说明如果硬件设备包含等无线模块且系统启用了则服务器存在通过无线连接网络的可能如果是不受控的连接则一方面可能导致网络不稳定另一方面增加了攻击面当不存在使用无线网络的场景建议用户根据实际情况关闭无线网络功能规则影响依赖于无线网络的程序运行受限制检查方法通过命令查看无线网络配置如果和为表示已启用无线网络例如修复方法通过命令可永久关闭和即使系统重启也依旧保持关闭状态防火墙应当启用服务级别建议适用版本全部规则说明防火墙作为一种网络或系统之间强制实行访问控制的机制是确保网络安全的重要手段针对不同的需求和应用环境可以量身定制出不同的防火墙系统如果系统中没有配置防火墙服务可能会导致系统被外部攻击内部数据被窃取或篡改大量无效流量浪费带宽访问一些存在安全风险或业务无关的网站导致信息泄露对于连接到网络上的系统来说防火墙是必不可少的防御机制它只允许合法的网络流量进出系统而禁止其它任何网络流量例如只限定允许的地址访问其服务因而可以定制防火墙配置来满足任何特定需求和任何安全性需求提供三种常用的防火墙服务配置界面其中底层实际调用或机制默认且建议启用服务并关闭服务三种防火墙服务建议只启用一种不建议同时启用多种如果多种防火墙规则设置不正确可能导致规则冲突防护混乱规则影响防火墙配置错误可能起不到防护作用还有可能会导致正常的业务无法通信检查方法通过如下命令检查服务已经启用并且和服务未被启用修复方法使用如下方法启用服务并配置永久生效使用如下方法关闭和服务并配置永久生效应当配置正确的默认区域级别建议适用版本全部规则说明服务通过区域概念允许将防火墙划分为几个独立的规则区域不同的接口或源地址可以绑定到不同的区域实现不同的控制逻辑一个区域可以配置许多不同的网络接口或源但反过来一个接口或源只能绑定到一个区域中避免报文进出时无法确定执行哪个区域的规则如果一个区域在处理接口或源的报文时发现并没有显式的规则匹配此时该区域可以决定如何处理该报文比如接收拒绝或者直接交由默认区域处理可以根据实际业务场景配置合适的默认区域所有未被显式划分到指定区域的接口源地址连接等网络资源都应该被分配到默认区域如果默认区域配置不合理则可能对未绑定到其他区域的网络资源产生非预期的影响如果所有网络资源都已经显式的绑定到其他区域且已经制定详尽的规则默认区域未配置任何规则则默认区域将不影响业务但这不是推荐的做法服务共提供种区域类型默认配置为规则影响无检查方法使用命令查询默认区域配置修复方法使用命令配置默认区域应当确保网络接口绑定正确区域级别建议适用版本全部规则说明不同的防火墙区域可以制定不同的过滤策略如果服务器网络比较复杂有多个接口且不同接口承担不同的业务功能建议将接口配置到不同的区域并制定不同的防火墙策略比如外网业务接口不允许访问而内网管理接口可以开放访问如果所有接口都配置到一个区域中防火墙策略不利于对不同接口进行不同配置增加管理复杂度降低防火墙安全防护的过滤效率因配置问题可能导致不该接收的报文未被拒绝或丢弃规则影响无检查方法检查各个区域配置的接口情况修复方法使用命令从指定区域移除接口使用命令往指定区域增加接口使用命令将当前防火墙配置固化到配置文件中使之永久生效避免开启不必要的服务和端口级别建议适用版本全部规则说明在区域中需要精确配置哪些接口服务端口等是要开启的哪些是必须关闭的正确配置后可以防止不被允许的报文被接收处理减少服务器暴露的端口减小攻击面如果配置不正确原本应该被禁止的接口或端口被开放出去攻击者就可以利用这些接口或端口实施攻击行为增加服务器和其他网元的风险规则影响无检查方法使用如下脚本查看所有状态的区域检查区域中接口服务端口等配置是否合理此处两个区域只是举例配置的接口服务端口等需要根据实际部署情况确定修复方法使用如下命令删除指定区域中对应的服务端口等使用命令将当前防火墙配置固化到配置文件中使之永久生效应当启用服务级别建议适用版本全部规则说明是操作系统提供的一套基于和过滤规则链的防火墙管理工具同时提供防火墙服务服务区分和所以需要分别配置策略和启闭服务默认且建议使用服务如果必须使用提供防火墙服务则必须关闭和服务如果未启用任何防火墙服务则将提高系统被攻击篡改的可能三种防火墙服务建议只启用一种不建议同时启用多种如果多种防火墙规则设置不正确可能导致规则冲突防护混乱规则影响如果启用多个防火墙服务可能导致因为策略配置不一致而造成业务中断检查方法通过如下方式检查服务已经被启用和服务未被启用检查服务是否已经启用修复方法使用如下方法启用服务并配置永久生效使用如下方法启用服务并配置永久生效使用如下方法关闭和服务并配置永久生效应当正确配置默认拒绝策略级别建议适用版本全部规则说明通常情况下策略配置可以分为白名单方式和黑名单方式两种建议通过白名单方式配置只要不符合白名单中规则的链接全部禁止所以可以先配置对链的或策略然后针对需要开放的端口和服务配置策略规则影响通过黑名单方式配置策略由于未被配置为或的链接都将被容易因为遗漏而导致安全风险检查方法使用如下命令检查的链默认是否为拒绝策略使用如下命令检查的链默认是否为拒绝策略修复方法使用如下命令配置链的默认策略为拒绝需要注意的是如果通过网络连接进行远程配置操作那么策略被修改后网络就会断开需要通过串口进行连接配置通过如下命令使当前配置的策略永久生效配置默认策略通过如下命令使当前配置的策略永久生效应当正确配置策略级别建议适用版本全部规则说明回环地址是服务器上一个特殊的地址以表示同网卡无关主要用于本机进程间通信不应该从网卡上收到源地址为的报文此类报文应该被丢弃如果回环地址策略设置不正确则可能导致本机进程间通信失败或者从网卡收到欺骗报文服务器需要设置策略允许接收和处理接口的回环地址报文但拒绝从网卡收到的报文规则影响无检查方法查看的链是否已经正确配置回环地址策略查看的链是否已经正确配置回环地址策略修复方法通过如下命令设置允许接收和处理接口报文拒绝源地址为的报文是按照顺序进行规则匹配的所以规则必须被添加在另外两条规则之后否则由于接口发出的报文源地址也是会被规则丢弃通过如下命令使当前配置的策略永久生效配置通过如下命令使当前配置的策略永久生效应当正确配置策略级别建议适用版本全部规则说明链的作用是对从外部接收的报文进行过滤任何对外提供的服务都需要配置对应的策略开启相关的端口外部客户端才能通过该端口访问该服务如果未配置由于默认策略配置为所有外部尝试访问相关业务的报文都将被丢弃规则影响无检查方法检查链配置的策略是否满足业务需要如下例子中开启了目标端口为的报文通道即协议的默认端口且不限制源目标地址检查修复方法通过如下命令新增策略到链例如通过如下命令使当前配置的策略永久生效配置例如通过如下命令使当前配置的策略永久生效应当正确配置策略级别建议适用版本全部规则说明服务器外发报文主要有两种情况一种是主机进程主动连接外部服务器比如访问或者外发数据到日志服务器等另一种是外部访问本机服务本机进行回复的报文如果未配置策略由于默认策略是服务器所有外发报文都将被丢弃规则影响无检查方法检查链配置的策略是否满足业务需要如下例子中开启了源端口为的报文通道即协议的默认端口且不限制源目标地址检查修复方法通过如下命令新增策略到链例如通过如下命令使当前配置的策略永久生效配置例如通过如下命令使当前配置的策略永久生效应当正确配置关联策略级别建议适用版本全部规则说明虽然可以通过配置协议和端口等将进出服务器的报文策略配置到和链但有些情况下会比较复杂比如客户端通过某端口访问服务器但服务器在返回响应报文时并不一定从原端口返回可能使用随机的源端口这种情况下通过参数很难配置准确的策略此时需要考虑使用关联链接的方式配置策略如果一个外发的报文属于一个已经存在的网络链接则直接放行如果一个接收的报文属于一个已经存在的网络链接也直接放行因为这些已经存在的链接必定是经过其他策略过滤和检查的否则无法建立如果不通过关联链接的方式配置策略则需要将所有可能的链接情况全部分析清楚并配置对应的策略如果配置过松可能导致安全风险如果配置过严可能导致业务中断规则影响无检查方法检查和链是否配置了关联策略检查修复方法通过如下命令配置链的和策略允许所有新建和已建立链接的报文外发配置链的和策略允许所有已建立链接的报文接收通过如下命令使当前配置的策略永久生效配置通过如下命令使当前配置的策略永久生效应当启用服务级别建议适用版本全部规则说明是内核的子系统提供对网络数据包的过滤和分类替换了的部分与相比更容易扩展到新协议将在未来替代另外不同于和操作系统默认未配置任何策略需要管理员手工配置需要注意的是默认且建议使用服务如果必须使用提供防火墙服务则必须关闭和服务如果未启用任何防火墙服务则将提高系统被攻击篡改的可能三种防火墙服务建议只启用一种不建议同时启用多种如果多种防火墙规则设置不正确可能导致规则冲突防护混乱规则影响如果启用多个防火墙服务可能导致因为策略配置不一致而造成业务中断检查方法通过如下方式检查服务已经被启用和服务未被启用修复方法使用如下方法启用服务并配置永久生效使用如下方法关闭和服务并配置永久生效应当配置默认拒绝策略级别建议适用版本全部规则说明从安全角度考虑基础链类似于需要配置所有报文的拒绝策略然后再在基础链中添加允许策略开放相关服务和端口如果没有配置基础链或没有指定基础链的规则报文将不会被捕捉到也就无法进行过滤处理规则影响如果基础链未配置或策略报文默认都将被容易因为遗漏拒绝策略而导致安全风险检查方法通过如下方法检查是否配置了和的策略注意举例中同时已经配置了的和策略如果不配置通过远程登录将断开修复方法首先创建然后通过如下方法在中配置基础链的策略注意配置后网络将可能断开通过如下方式将当前配置的规则保存到配置文件中以便系统重启后能够自动加载注意上述方式保存配置文件会覆盖原有配置内容亦可将当前规则导出到单独文件中或者直接在文件中编写新规则然后在配置文件中通过方式加载此种方式需要注意避免多个规则文件内有重复规则应当配置策略级别建议适用版本全部规则说明回环地址是服务器上一个特殊的地址以表示同网卡无关主要用于本机进程间通信不应该从网卡上收到源地址为的报文此类报文应该被丢弃如果回环地址策略设置不正确则可能导致本机进程间通信失败或者从网卡收到欺骗报文服务器需要设置策略允许接收和处理接口的回环地址报文但拒绝从网卡收到的报文规则影响无检查方法查看是否已经配置回环地址策略链需要配置从设备接收报文的策略配置从非设备接收且源地址为的报文的策略在链需要配置源地址为的报文的策略配置配置修复方法通过如下方法添加和链的策略配置链接口策略配置链策略链策略配置链策略链策略通过如下方式将当前配置的规则保存到配置文件中以便系统重启后能够自动加载注意上述方式保存配置文件会覆盖原有配置内容亦可将当前规则导出到单独文件中或者直接在文件中编写新规则然后在配置文件中通过方式加载此种方式需要注意避免多个规则文件内有重复规则应当正确配置策略级别建议适用版本全部规则说明链的作用是对从外部接收的报文进行过滤任何对外提供的服务都需要配置对应的策略开启相关的端口外部客户端才能通过该端口访问该服务如果未配置由于默认策略配置为所有外部尝试访问相关业务的报文都将被丢弃规则影响无检查方法检查链配置的策略是否满足业务需要如下例子中开启了目标端口为的报文通道即协议的默认端口且不限制源目标地址修复方法通过如下命令新增策略到链例如通过如下方式将当前配置的规则保存到配置文件中以便系统重启后能够自动加载注意上述方式保存配置文件会覆盖原有配置内容亦可将当前规则导出到单独文件中或者直接在文件中编写新规则然后在配置文件中通过方式加载此种方式需要注意避免多个规则文件内有重复规则应当正确配置策略级别建议适用版本全部规则说明服务器外发报文主要有两种情况一种是主机进程主动连接外部服务器比如访问或者外发数据到日志服务器等另一种是外部访问本机服务本机进行回复的报文如果未配置策略由于默认策略是服务器所有外发报文都将被丢弃规则影响无检查方法检查链配置的策略是否满足业务需要如下例子中开启了源端口为的报文通道即协议的默认端口且不限制源目标地址修复方法通过如下命令新增策略到链例如通过如下方式将当前配置的规则保存到配置文件中以便系统重启后能够自动加载注意上述方式保存配置文件会覆盖原有配置内容亦可将当前规则导出到单独文件中或者直接在文件中编写新规则然后在配置文件中通过方式加载此种方式需要注意避免多个规则文件内有重复规则应当正确配置关联策略级别建议适用版本全部规则说明虽然可以通过配置协议和端口等将进出服务器的报文策略配置到和链但有些情况下会比较复杂比如客户端通过某端口访问服务器但服务器在返回响应报文时并不一定从原端口返回可能使用随机的源端口这种情况下通过参数很难配置准确的策略此时需要考虑使用关联链接的方式配置策略如果一个外发的报文属于一个已经存在的网络链接则直接放行如果一个接收的报文属于一个已经存在的网络链接也直接放行因为这些已经存在的链接必定是经过其他策略过滤和检查的否则无法建立如果不通过关联链接的方式配置策略则需要将所有可能的链接情况全部分析清楚并配置对应的策略如果配置过松可能导致安全风险如果配置过严可能导致业务中断规则影响无检查方法检查和链是否配置了关联策略修复方法通过如下命令配置链的和策略允许所有新建和已建立链接的报文外发配置链的和策略允许所有已建立链接的报文接收通过如下方式将当前配置的规则保存到配置文件中以便系统重启后能够自动加载注意上述方式保存配置文件会覆盖原有配置内容亦可将当前规则导出到单独文件中或者直接在文件中编写新规则然后在配置文件中通过方式加载此种方式需要注意避免多个规则文件内有重复规则确保服务版本配置正确级别要求适用版本全部规则说明如果使用由于协议本身存在较多的未修复漏洞且社区已不作为主流协议进行长期维护容易使攻击者有机可乘造成信息泄露命令数据篡改等风险默认继承的组件使用协议进行远程控制或在服务器之间传递文件支持和协议其中协议简称由于安全原因不允许使用协议简称为目前无安全问题要求使用同互不兼容所以要求服务端在使用之后客户端也必须使用协议当前默认使用规则影响无检查方法通过如下命令查看返回是否为修复方法修改文件将字段后面的数字修改为重启服务确保服务认证方式配置正确级别要求适用版本全部规则说明配置合理的认证方式有利于确保用户及系统数据安全通常情况下对于人机账号账号口令方式比较合适对于非交互式的登录场景公私钥方式比较合适而对于高安全风险场景仅开启公私钥认证方式更合适如果使用基于主机的身份认证攻击者可通过域名污染或欺骗后无需口令直接入侵系统服务本身提供多种认证方式但出于安全考虑禁止使用基于主机的身份认证默认使用账号口令方式认证在安装系统时要求配置管理员口令允许公私钥方式认证允许交互式账号口令方式认证根据业务场景需要务必配置正确的认证方式规则影响无检查方法通过如下方法检查配置是否正确此处必须配置为必须配置为和至少有一个为修复方法启用账号口令认证方式配置文件开启选项重启服务如下启用公私钥认证方式配置文件开启选项并配置公钥存储路径重启服务例如客户端生成公私钥并把公钥拷贝到指定目录下即可如上例中目录启用交互式账号口令认证方式配置文件开启选项重启服务如下关闭基于主机的认证配置文件开启关闭重启服务如下确保密钥交换算法配置正确级别要求适用版本全部规则说明密钥交换是密码学中双方交换密钥以允许使用某种加密算法的过程通过安全的密钥交换算法双方可以安全地交换密钥从而允许使用加密算法对要发送的消息进行加密并对接收到的消息进行解密设置密钥交换算法限制密钥交换这一阶段所能使用的算法要注意的是若配置的算法不安全则会增加使用风险因为弱算法在业界已经或者即将被破解推荐的安全算法如下按优先级排序已默认配置可以根据实际业务场景进行修改配置但所选择的算法必须符合业界安全标准规则影响如果客户端不支持服务端配置的密钥交换算法客户端将无法连接到服务端检查方法检查中是否配置了正确的密钥交换算法的字段字段设置可用的密钥交换算法用户根据需要进行设置修复方法修改在该文件中设置密钥交换算法下面给出密钥交换算法示例用户在设置的时候应根据需要进行设置设置好密钥交换算法后需重启服务确保用户认证密钥算法配置正确级别要求适用版本全部规则说明如果采用公私钥认证方式则需要限制客户端公私钥算法避免使用已经被业界淘汰的不安全算法推荐的安全算法如下按优先级排序已默认配置中定义的公钥算法使用了进行哈希运算因此禁止使用规则影响如果客户端不支持服务端配置的公私钥算法客户端将无法连接到服务端检查方法通过如下方法检查配置修复方法修改文件的字段的算法列表不同算法间通过逗号分隔重启服务例如确保认证使能级别要求适用版本全部规则说明是平台上可插拔的认证模块提供了一系列的开源共享库文件通过配置参数可以灵活控制相关认证过程通过配置认证可以基于系统的用户认证管理模块完成远程登录用户的认证授权和管理相对比较方便和统一否则需要对认证过程进行管理例如认证失败次数控制账号是否锁定等配置容易遗漏或无法达到管理的效果默认使用认证规则影响无检查方法使用命令查看配置修复方法修改文件将设置为重启服务确保服务算法配置正确级别要求适用版本全部规则说明消息认证算法密码学中通信实体双方使用的一种验证机制保证了消息数据完整性若配置的算法不安全则会增加使用风险因为弱算法在业界已经或者即将被破解推荐的安全算法如下按优先级排序已默认配置规则影响如果客户端不支持服务端配置的算法客户端将无法连接到服务端检查方法使用命令查看配置如果返回为空表示未配置修复方法修改文件在该文件中设置消息认证算法下面给出消息认证算法示例用户在设置的时候应根据需要进行设置设置好消息认证算法后需重启服务使之生效确保服务密码算法配置正确级别要求适用版本全部规则说明随着密码技术的发展以及计算能力的提升一些密码算法已不再适合现今的安全领域例如算法该算法已经于年由山东大学王小云教授的团队予以破解人为构造出两个具有相同值的信息并且在年由密码学家进一步扩展和改进该攻击实现了数字证书伪造其安全性已非常低下因此不应用于所有密码学安全用途包括用于数字签名口令单向保护密钥派生等但是对于校验线路错误校验介质损坏引起的比特跳变等非密码学安全用途使用不受本规范约束又比如算法因为密码学分析技术的发展和计算能力提升导致对其进行暴力破解成为可能现有的暴力破解设备能将破解的时间减少到一天以内这些算法统称为不安全密码算法如果继续使用这些不安全的密码算法有可能为数据带来风险强密码算法是指当前被业界普遍认可在其适合的应用场景下安全强度相对该场景下的其它加密算法有相对优势在合理的安全假设下具有可证明安全性或对其实施破解在计算上显著不可行的密码算法密码算法用于加密解密数据若配置的算法不安全则会增加使用风险因为弱算法在业界已经或者即将被破解规则影响如果客户端不支持服务端配置的加密算法客户端将无法连接到服务端检查方法使用命令查看配置如果返回为空表示未配置修复方法修改文件在该文件中设置密码算法下面给出密码算法示例用户在设置的时候应根据需要进行设置设置好密码算法后需重启服务使之生效禁止服务配置加密算法覆盖策略级别要求适用版本全部规则说明服务加密算法的配置文件为当服务正在运行中用户可以编辑文件从而覆盖加密算法策略如果配置加密算法覆盖策略将允许用户配置安全性较低的加密算法消息认证算法密钥交换算法等降低了系统的安全性攻击者可以利用这些不安全的算法破解系统信息增加了安全风险默认不配置加密算法覆盖策略规则影响无检查方法检查配置文件如果字段为空或该行被注释则说明没有配置加密算法覆盖策略反之则说明配置了加密算法覆盖策略修复方法编辑服务配置文件删除加密算法策略或注释掉该行重新加载配置方案删除加密算法策略方案注释该行确保禁用用户通过登录级别要求适用版本全部规则说明配置文件中的参数指定用户是否可以使用登录不允许用户通过登录要求系统管理员使用自己的个人账户进行登录然后通过或提升权限到这样可在发生安全事件时提供清晰的审计线索在对此项安全建议进行配置前应确认还有其他可用的系统管理员用户账号否则在配置生效后将可能导致无法进行远程管理规则影响配置生效后用户不能通过远程登录检查方法执行以下命令验证的配置是否正确同时满足如下两个命令行的检查修复方法修改文件将字段修改为重启服务应当正确配置服务日志级别级别建议适用版本全部规则说明提供多种日志输出级别日志级别设置越高例如打印的日志信息越少有利于节约硬盘空间但不利于管理员对事件进行审计追溯反之例如日志打印量大消耗硬盘空间多记录的事件比较详细默认设置为建议根据实际场景设置合理的日志级别不建议设置及以下级别容易导致日志量过多规则影响无检查方法使用命令查看日志级别配置如下例中配置为修复方法修改文件将设置为相应的级别重启服务应当正确配置服务接口级别建议适用版本全部规则说明通常情况下服务器存在多个网卡多个地址地址应该进行相关的规划哪些用于业务哪些用于管理所以并不是每个地址都需要侦听连接可以通过配置限制只有指定地址才能进行连接减小攻击面未配置的地址无法通过连接到服务器作为平台无法确定现网场景默认不配置建议根据实际情况规划和配置规则影响无检查方法如果已经配置侦听的地址通过命令可以查询对应的配置为实际已配置的地址返回打印为空表示未配置修复方法修改文件在字段后设置相应的地址如果有多个可以设置多行重启服务如应当正确配置并发未认证连接数级别建议适用版本全部规则说明攻击者在不知道口令的情况下可以通过建立大量的未完成认证的并发连接来消耗系统资源默认不配置建议根据实际场景配置上限值规则影响如果正在进行认证的连接数达到上限则新连接将被直接拒绝检查方法使用命令查看配置如果返回为空表示未配置修复方法修改文件配置字段配置值为用冒号分隔的个字段其中第一个字段和最后一个字段分别表示连接数下限和上限中间字段表示丢弃连接的比例如表示未完成认证的连接数达到个以后开始丢弃的连接申请如果此时继续累积未完成认证的连接数达到个那么拒绝所有新增连接修改本配置需要重启服务生效应当正确配置单个连接允许的并发会话数级别建议适用版本全部规则说明允许支持多路复用的客户端基于一个网络连接可以建立多个会话限制每个网络连接允许建立的并发会话数可以防止系统资源被单个或少数连接无限制的占用导致拒绝服务攻击设置为将禁用会话多路复用即一个连接仅允许一个会话而将其设置为将阻止所有连接会话默认不在配置文件中配置代码中会取默认值建议根据实际场景在配置文件中配置上限值规则影响如果单个客户端连接建立的会话数已经达到最大连接数新建会话将被拒绝检查方法使用命令查看配置如果返回为空表示未配置修复方法修改文件配置字段该字段后面配置的数字表示限制的连接会话数重启服务例如说明假设设置为修改配置并重新启动服务后对已经存在的会话不参与计数也就是在该通道还可以新建个会话如果修改配置后重新启动服务器则一个通道只能存在个会话禁止使用级别要求适用版本全部规则说明的功能允许在本地主机上执行远程主机的程序启用功能则扩大了攻击面存在被服务器端其他用户攻击的可能如果业务场景中不需要则必须禁止该功能默认关闭功能规则影响依赖于的程序执行受限制检查方法使用命令查看配置修复方法修改文件配置字段将该字段设置为重启服务应当正确配置级别建议适用版本全部规则说明值用于表示系统允许单次连接过程中用户认证失败的次数超过上限则自动断开连接建议设置该值小于等于如果该值配置比较大则单次连接过程中客户端可以尝试多次认证失败降低了攻击开销如果该值未在配置文件中显式配置系统默认为规则影响认证失败次数超过上限自动断开连接检查方法使用命令查看配置如果返回为空表示未配置修复方法修改文件配置字段该字段后面配置的数字表示限制的尝试次数重启服务禁止使用级别要求适用版本全部规则说明允许用户设置环境变量该设置可能导致攻击者通过修改环境变量进行相应攻击如果配置为则攻击者可以通过修改环境变量绕过安全机制或者执行攻击代码该配置必须关闭规则影响无检查方法使用命令查看配置修复方法修改文件配置字段为重启服务应当正确配置级别建议适用版本全部规则说明用于限制用户登录的时间如果用户在限定的时间内没有完成登录动作则自动断开连接建议该值设置为小于或等于秒如果该值设置过大则攻击者可以利用大量未完成登录动作的连接来消耗服务器资源从而导致正常管理员登录失败如果该值未在配置文件中显式配置系统默认为秒规则影响无检查方法使用命令查看配置修复方法修改文件配置的值该字段后面配置的数字表示限制的时间单位秒配置后重启服务禁止服务预设置级别要求适用版本全部规则说明为远程主机的公钥用户可以将该公钥存放于主目录文件中用于公钥认证便可以直接登录系统如果系统中预设并且服务端开启了公私钥认证的登录方式攻击者便可以绕过认证直接登录到指定的系统中对其进行攻击所以系统中不能预设置默认不预设置注意本规则仅对初始系统预设置进行约束对于运行期间按业务要求必须使用公钥认证的场景可以例外规则影响无检查方法使用命令查看配置如果返回为空表示未预设置修复方法删除被检测到的预设置如文件禁止服务预设置级别要求适用版本全部规则说明为主机已经访问过的计算机的公钥用户成功登录其他计算机后会自动将公钥信息保存在中当下次访问相同计算机时会校验公钥如果校验失败则拒绝建立连接所以系统中不能预设置当系统中预设时如果主机公钥正确则在与目标主机建立连接的过程中不会发出警告增加了安全风险如果主机公钥错误则无法建立连接到目标主机默认不预设置规则影响无检查方法使用命令查看配置如果返回为空表示未预设置修复方法删除被检测到的文件如文件禁止服务配置弃用的选项级别要求适用版本全部规则说明目前服务通讯协议主要分为第一代和第二代不同版本的通讯协议服务的配置项并不兼容而且某些低版本的配置项在新版本中已经被废除了服务端配置文件存放在中当前配置选项均为第二代通信协议的配置选项如果强行配置旧版本的配置项会导致服务进行自检时报错且配置项并不生效所以应禁止配置已经弃用的选项默认不配置已经弃用的选项规则影响无检查方法使用服务自检命令进行检查如果返回为空表示未出现错误反之则说明配置了不兼容的选项修复方法编辑服务配置文件删除已经废除的配置项重启服务确保禁用的转发功能级别要求适用版本全部规则说明将设置为的作用是禁止客户端进行端口转发端口转发是通过隧道在本地主机和远程主机之间传输数据的功能通过禁用这一功能可以限制用户在会话中的数据传输和访问范围从而增强系统的安全性配置后具体影响如下限制数据传输禁用端口转发可以防止用户在会话中传输数据从而降低了可能的数据泄露风险减少攻击面开启端口转发可能会引入一些安全风险如允许攻击者绕过网络安全措施或访问受限制的服务禁用这一功能可以减少系统的攻击面避免资源滥用端口转发可能占用服务器资源和带宽禁用它可以避免资源被滥用符合安全最佳实践在某些情况下如高度安全性要求的环境禁用端口转发可能是安全最佳实践之一规则影响禁用端口转发可能会影响某些应用和用例例如需要远程访问受限服务的情况检查方法执行以下命令验证的配置是否正确同时满足如下两个命令行的检查修复方法编辑配置文件修改参数或添加以下代码对参数进行配置应当正确配置认证黑白名单级别建议适用版本全部规则说明提供了黑白名单功能可以设置账号或用户组的清单允许或禁止某些账号或用户组的用户登录默认不配置相关字段如下是空格分割的允许登录的账号不支持可以是格式和将被单独检查限制特定账号从特定主机上登录名称里面可使用通配符和配置后将自动禁止系统其他非授权账号登录服务是空格分隔的允许登录的用户组名称不支持是空格分隔的拒绝登录的账号不支持是空格分隔的拒绝登录的用户组名称不支持建议直接删除不使用的用户账号或用户组而不是通过进行拒绝登录如果针对某个账号只允许或拒绝在某些客户端登录可以通过方式配置或规则或规则如果同时设置则取并集也就是说如果设置了规则那么被允许的用户账号或用户组之外的都不允许登录同时设置了规则那么在遵循规则后允许登录的用户账号或用户组范围内再匹配是否符合规则排除以后剩下的才是可以登录的规则影响配置规则被允许的用户账号或用户组之外的都不允许登录配置规则拒绝登录的用户账号或用户组将无法登录检查方法使用命令检查是否存在配置如果无返回信息则表示没有任何配置否则返回配置内容修复方法根据业务实际场景在文件中添加相关或字段重启服务例如定时任务确保执行的脚本非属主用户不可写级别要求适用版本全部规则说明是系统用来执行定时任务的配置文件配置文件路径为管理员会根据实际的业务需要定义定时任务操作系统会自动执行该任务所以配置文件中配置的执行脚本程序应该只有该脚本程序的属主可写不能配置其他低权限用户可写的脚本否则其他用户可以通过修改该脚本实现提权操作规则影响无检查方法检查配置文件检查执行脚本程序是否为其他低权限用户可写修复方法如果配置文件中的执行脚本程序为其他低权限用户可写则需要根据实际的业务场景进行修复修复方法修改配置文件中的执行脚本程序的文件权限去除掉其他低特权用户的可写权限以防止提权操作修复方法修改配置文件删除该执行脚本程序的配置项防止提权操作确保守护进程正常启用级别要求适用版本全部规则说明守护进程用于在系统上执行批处理作业即使操作系统目前可能没有需要运行的用户作业也会有系统作业需要运行其中就可能包括安全监控等重要作业而守护进程就是用来执行这些作业的守护进程未正常启用的影响定时任务无法运行最直接的影响是配置在中的定时任务将无法自动运行这可能会导致一些计划性的任务未能按时执行如日志清理备份系统维护等计划性任务延迟如果定时任务未能按时执行可能会导致任务的延迟这对于某些关键任务来说可能会影响系统的正常运行和性能系统维护和自动化受阻自动化任务通常用于监视系统状态应用程序的运行情况等如果这些任务未能按时执行系统可能会错过对潜在问题的检测和处理日志分析受影响许多系统管理员使用定时任务来执行日志分析报告生成等任务如果这些任务无法运行可能会错过对系统运行情况的重要洞察备份延误许多备份任务都是通过定时任务实现的如果定时任务未运行备份可能会受到影响导致数据备份不及时或不完整规则影响无检查方法执行以下命令来确定守护进程是否正常启用如结果为则视为通过此项检查修复方法执行以下命令来启用进程确保配置正确级别要求适用版本全部规则说明服务用于进行简单的一次性任务执行服务用于执行系统中的周期性定时任务是命令的黑名单配置文件是命令的白名单配置文件默认不存在白名单出现时黑名单失效只有账号和写在白名单中的账号可以使用命令如果使用黑名单机制管理定时任务有可能在添加了新账号之后忘记将其加入黑名单中增大了系统潜在的安全攻击面如果相关配置文件属主不为或者允许和用户访问可能导致系统管理员以外的用户进行配置带来系统安全隐患如果系统无需启用配置此配置项无需检查规则影响无检查方法首先要确保系统中服务已经启用请确认返回结果是确认文件和目录的和都是且不允许和用户访问确认黑名单文件和不存在确认白名单文件和设置了正确的权限即和都是且不允许和用户访问修复方法如果没有启用服务使用以下命令启用设置文件和目录的及权限删除和文件创建和文件并设置正确的权限内核确保内核已启用级别要求适用版本全部规则说明通过每次将栈的起始位置函数库和程序本身移至略微不同的位置使得缓冲溢出攻击无法猜测正确的位置导致攻击无法成功实施内核中分为三级通过文件配置查看各级对应的效果不存在随机化表示一切都将位于静态地址中只有共享函数库栈内存以及堆是随机的完全随机化使用进行的旧式内存配置也将是随机的进程中栈的地址被随机化降低缓冲溢出攻击的风险规则影响无检查方法输入以下命令并检查相应的命令返回是否为修复方法修改值为确保访问权限配置正确级别要求适用版本全部规则说明限制访问信息权限无特权的用户无法查看系统信息从而可以避免任何人从系统信息获取敏感信息进而对系统进行攻击的行为仅允许具有能力的进程查看内核日志信息从而控制关键信息的最小权限保障系统更加安全规则影响无检查方法检查文件中是否已经配置相关字段表示已经设置的访问限制修复方法打开文件设置为确保正确配置内核参数级别要求适用版本全部规则说明的作用是保护内核符号地址保护等级低时普通用户可以访问得到内核符号地址容易被攻击者利用增加了攻击面降低了系统安全性当前可以选择如下参数普通用户和带有特权的用户均可以读取读取地址为内核符号地址经哈希运算后的值只有带有特权的用户有读取权限读取地址为内核符号实际地址普通用户读取后内核符号地址打印为全零普通用户及带有特权的用户均无权限读取读取后内核符号地址打印为全零考虑到易维护性可定位性发行版默认配置参数为请根据实际场景按需配置规则影响普通用户无法获取内核符号地址检查方法输入以下命令并检查相应的命令返回值是否为修复方法建议设置的值为或者修改文件添加或修改配置并执行确保内核已启用级别要求适用版本全部规则说明内核参数管理模式访问保护开启后禁止内核访问用户空间的数据若不开启内核参数攻击者可以利用通过内核态代码重定向的方式访问用户空间数据增加了攻击面降低了系统安全性默认开启规则影响内核不能访问用户空间数据检查方法输入以下命令并检查是否有返回值如果有返回值则说明支持反之则说明不支持注仅架构支持特性物理机虚拟机均支持其他架构可忽略该项通过检查启动参数检验是否开启若有返回值则说明未开启反之则说明开启修复方法若关闭了选项需要编辑文件在启动参数中删除选项确保内核已启用级别要求适用版本全部规则说明内核参数管理模式执行保护开启后禁止内核执行用户空间代码若不开启内核参数攻击者可以利用通过内核态代码重定向的方式执行用户空间代码增加了攻击面降低了系统安全性默认开启规则影响内核不能执行用户空间代码检查方法输入以下命令并检查是否有返回值如果有返回值则说明支持反之则说明不支持注仅架构支持特性物理机虚拟机均支持其他架构可忽略该项通过检查启动参数检验是否开启若有返回值则说明未开启反之则说明开启修复方法若关闭了选项需要编辑文件在启动参数中删除选项禁止系统响应广播报文级别要求适用版本全部规则说明是网络控制消息协议主要用于传递查询报文与差错报文通过设置是否接受广播报文对报文攻击进行防护该参数决定设备是否要回应消息和时间戳请求对这些消息和请求来说目的地址就是广播地址无论是哪台设备发送的报文报文都会发送到网络上的每一台设备上去如果源地址是伪造的就可能会导致网络上所有的设备发送恶意的报文给受害者被伪造地址的设备规则影响系统不响应广播报文检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示系统禁止响应报文如果参数返回值为表示系统未禁止响应报文其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法输入命令禁止系统响应广播报文修改文件添加或修改配置禁止接收重定向报文级别要求适用版本全部规则说明重定向消息是传递路由信息并告诉系统通过备用路径发送数据包这是一种允许外部路由设备更新系统路由表的方法通过将和设置为系统不会接受任何重定向报文通过将和设置为系统不会从网关接收重定向报文无此配置项攻击者可以利用伪造的重定向消息恶意更改系统路由表使它们向错误的网络发送数据包从而获取相应的敏感数据规则影响系统不接收重定向报文检查方法首先检查当前系统内核参数的设置输入命令查看返回值是否为其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法输入命令禁止接收重定向报文修改文件添加或修改配置禁止转发重定向报文级别要求适用版本全部规则说明重定向用于向其他主机发送路由信息由于主机本身不充当路由器因此没有必要转发重定向数据包攻击者可以利用受到攻击的主机向其他路由器设备发送无效的重定向试图破坏路由并让用户访问错误的系统规则影响系统不转发重定向报文检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示系统转发重定向报文如果参数返回值为表示系统不转发重定向报文其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法输入命令禁止转发重定向报文修改文件添加或修改配置应当忽略所有请求级别建议适用版本全部规则说明通过忽略所有请求禁止外界通过命令访问系统攻击者可以通过命令的返回来感知系统所处的网址位置规则影响系统忽略所有请求检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示系统忽略所有请求如果参数返回值为表示系统响应请求其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为建议用户在配置文件中添加正确配置修复方法输入命令禁止转发重定向报文修改文件添加或修改配置确保丢弃伪造的报文不记录日志级别要求适用版本全部规则说明将设置为可以防止内核记录广播重复数据包的响应从而避免文件系统填充无用的日志信息一些攻击者会发送违反的报文并试图用大量无用的错误信息填充日志文件系统规则影响系统丢弃伪造的报文不记录日志检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示系统忽略错误响应如果参数返回值为表示系统处理错误响应其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法输入丢弃伪造的报文规则的命令修改文件添加或修改配置确保反向地址过滤已启用级别要求适用版本全部规则说明将和设置为强制内核对接收到的数据包使用反向路径过滤检查报文源地址的合法性如果反查源地址的路由表发现源地址下一跳的最佳出接口并不是收到报文的入接口则将报文丢弃攻击者可以实施地址欺骗在目前网络攻击中使用比较多通过反向地址过滤在收到数据包时取出源地址然后查看该路由器的路由表中是否有该数据包的路由信息如果路由表中没有其用于数据返回的路由信息那么极有可能是某人伪造了该数据包于是路由便把它丢弃规则影响无检查方法首先检查当前系统内核参数的设置执行以下命令检查参数的返回值是否为其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法输入启用反向地址过滤的命令修改文件添加或修改配置禁止转发级别要求适用版本全部规则说明如果该结点不作为网关服务器则应禁用转发功能否则攻击者可将此系统作为路由器使用对于容器场景如果容器内部需要通过宿主机转发网络报文则可以例外规则影响系统不允许转发检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示禁用转发如果参数返回值为表示启用转发其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为无任何输出无任何输出修复方法输入禁止转发的命令并修改配置文件禁止报文源路由级别要求适用版本全部规则说明在网络中源路由允许发送方部分或全部指定数据包通过网络的路由而常规路由中网络中的路由器根据数据包的目的地确定路径大量报文被篡改后通过指定路由则可以对内部网络进行定向攻击可导致指定路由器负载过高正常业务流量中断攻击者可以伪造一些合法的地址通过合适的设置源路由选项及合法的路由器蒙混进入网络另外如果允许源路由数据包则通过构造中间路由地址可以用于访问专用地址系统如果攻击者对原始报文截取并利用源路由进行地址欺骗则可以强制指定回传的报文都通过攻击者的设备进行路由返回这样攻击者就可以成功接收到双向的数据包所以应禁用报文源路由减小攻击面规则影响系统禁用报文源路由检查方法输入以下命令并检查相应的命令返回如果返回值不为建议修改修复方法输入禁止报文源路由的命令修改文件添加或修改配置确保保护已启用级别要求适用版本全部规则说明保护减轻了系统在遭受攻击时受到的影响攻击者使用泛洪攻击时快速耗尽内核中半开连接队列阻止合法连接但启用即使受到拒绝服务攻击仍允许系统继续接受合法连接规则影响无检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示启用保护机制如果参数返回值为表示未启用保护机制其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法启用保护可使用如下命令临时设置重启后恢复默认值修改文件添加或修改配置并执行使其永久生效应当记录仿冒源路由以及重定向报文日志级别要求适用版本全部规则说明记录欺骗的包源路由包和发给系统的重定向包有助于发现攻击源与制定防护措施规则影响开启后会记录带有不允许的地址的数据到内核日志中存在冲日志风险检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示开启记录仿冒源路由以及重定向报文日志如果参数返回值为表示系统关闭记录机制其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为建议用户在配置文件中添加正确配置修复方法打开记录可使用如下命令临时设置重启后恢复默认值修改文件添加或修改配置并执行使其永久生效避免开启级别要求适用版本全部规则说明用于记录数据包的发送时间可用于测量和保护序号绕回是一个双向的选项只有在客户端和服务端同时启用时才使能启用该选项可能遭受拒绝服务攻击规则影响关闭此项会影响在极端情况下超时重传的可靠性检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示开启机制如果参数返回值为表示关闭机制其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置默认值为建议用户在配置文件中添加正确配置修复方法关闭可使用如下命令临时设置重启后恢复默认值修改文件添加或修改配置并执行使其永久生效确保协议等待时间已配置级别要求适用版本全部规则说明是协议等待连接销毁的时间设置过长会导致存在大量未关闭的连接导致遭受拒绝服务攻击建议配置不大于规则影响时间设置过长会导致遭受拒绝服务攻击检查方法首先检查当前系统内核中值的设置执行以下命令并检查参数的返回值其次执行如下命令如果返回值与内核参数不一致建议根据需求进行修改如果返回值为空表示系统使用默认配置默认值为修复方法设置协议等待时间建议不大于可使用如下命令临时设置重启后恢复默认值修改文件添加或修改配置并执行使其永久生效应当正确配置状态队列数量级别要求适用版本全部规则说明队列保存尚未获得对方确认的连接请求值越大表示可以容纳更多等待连接的网络连接数如果配置值太小容易被泛洪攻击导致正常连接被拒绝服务配置太大则会消耗更多系统资源建议队列数量设置为规则影响从安全角度建议配置较大值以消减泛洪攻击但配置太大则会消耗更多系统资源对内存较小环境可能会影响正常业务检查方法首先检查当前系统内核中队列数量的设置执行以下命令并检查参数的返回值其次执行如下命令如果返回值与内核参数不一致建议根据需求进行修改如果返回值为空表示系统使用默认配置默认值为修复方法设置状态队列数量可使用如下命令临时设置重启后恢复默认值修改文件添加或修改配置并执行使其永久生效禁止使用代理级别要求适用版本全部规则说明代理允许系统代表连接到某个接口的主机向另一个接口上的请求发送响应禁用代理不仅可以防止未经授权的信息共享还可以防止连接的网络区段之间寻址信息泄露所以应关闭代理以避免报文攻击对系统造成影响默认禁止使用代理用户可根据业务需求进行配置规则影响依赖于代理的程序执行受限制检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值如果参数返回值为表示开启代理如果参数返回值为表示禁止使用代理其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法关闭代理的命令可使用如下命令临时设置重启后恢复默认值修改文件添加或修改配置并执行使其永久生效确保配置正确级别要求适用版本全部规则说明是当程序运行过程中异常终止或崩溃时把内存状态记录下来的行为有助于事后定位但可能会包含进程内存里的敏感信息有时用户需要开启功能记录当时产生问题的原因对于需要开启功能的用户需对日志输入的路径进行限制同时需限制路径只允许特定用户访问启用有助于程序异常终止或崩溃的事后定位但容易泄露内存中的敏感信息默认打开用户需要根据业务场景关闭或对日志输入的路径和访问用户进行限制规则影响关闭后程序异常时缺少日志记录不利于问题定位检查方法禁用场景的检查方法输入以下命令并检查相应的命令返回或者检查文件是否包含配置行限制场景的检查方法执行以下脚本成功返回无内容输出表示已限制了目录修复方法禁用方法使用如下命令对当前会话禁止系统支持生成修改文件添加或修改配置使其永久生效限制使用方法不为比如设置日志文件保存位置和文件格式通过修改可以控制日志文件保存位置和文件格式下例为将所有的日志文件生成到目录下绝对路径文件名的格式为命令名时间戳修改文件添加或修改配置建议为建立独立分区禁止目录占用系统分区或业务分区避免因为日志文件过多导致分区满而影响系统运行或业务运行限制目录访问权限可根据业务需要限制目录的访问用户范围限制单个用户比如访问使用粘滞位保护技术限制同组用户比如访问使用粘滞位保护技术限制所有用户访问注粘滞位对目录的作用使得目录下用户不能访问用户的文件除非用户的文件权限允许用户访问建议禁止的应用支持生成使用如下命令对当前运行系统禁止的应用支持生成修改文件添加或修改配置使其永久生效禁止使用键级别要求适用版本全部规则说明使得具有物理访问的用户能够访问计算机中危险的系统级命令需要对的功能使用进行限制如果没有禁用键则可以通过键盘触发的调用可能造成直接发送命令到内核对系统造成影响默认禁止使用键规则影响系统下相关命令无法使用检查方法首先检查当前系统内核参数的设置执行以下命令如果参数返回值为表示禁用键否则表示配置不正确建议修改配置文件内容其次执行如下命令如果返回值不为表示配置不正确建议修改配置文件内容如果返回值为空表示系统使用默认配置值为修复方法禁用可使用如下命令临时设置重启后恢复默认值或修改文件添加或修改配置并执行使其永久生效应当正确配置内核参数级别建议适用版本全部规则说明是一种系统调用用于进程跟踪提供了父进程可以观察并控制子进程的能力以及更高版本支持完全限制或禁用功能根据可以选择如下参数进程可以将传递给任何其他进程只要它是可转储的即没有转换没有特权启动或没有调用进程如果要调用必须有预先的定义关系默认情况下满足上述条件时预定义的关系仅为子进程的关系若要改变关系子进程可以调用调整这种关系只有具有的进程通过或通过子进程调用才能使用任何进程都不能将与一起使用也不能通过使用默认参数为用户可根据实际使用场景进行配置建议配置值为规则影响该参数的配置将影响的使用当配置参数为时只有的进程才能使用这样会有效防止攻击者恶意提权但同时会导致用户部分功能受到影响检查方法首先检查当前系统内核参数的设置执行以下命令并检查参数的返回值与业务场景需求是否一致其次执行如下命令如果返回值不为建议修改配置文件内容如果返回值为空表示系统使用默认配置值为建议用户在配置文件中添加正确配置修复方法设置的值可使用如下命令临时设置重启后恢复默认值或修改文件添加或修改配置并执行使其永久生效应当启用级别建议适用版本全部规则说明全称在刚引入内核时将进程可用的系统调用限制为四种最初的这种白名单方式除了已打开的文件描述符允许的四种系统调用如果尝试其他系统调用内核就会使用或终止该进程白名单方式由于限制太强实际作用并不大在实际应用中需要更加精细的限制为了解决此问题引入了和规则的结合它允许用户使用可配置的策略过滤系统调用该策略使用规则实现它可以对任意系统调用及其参数进行过滤内核默认已经提供功能支持同时提供了外围包帮助用户态程序可以方便的设置规则规则影响并不能全局设置启闭或规则而是针对于每一个进程的也就是进程可以自己设置启用作用于自身以及所有子线程但不影响其他进程如果进程启用了在进行系统调用时会有性能损失用户需要根据实际业务场景确定性能损失是否可接受检查方法检查目标进程是否启用了模式此处以检查进程为例首先确定进程号根据获取的号查询进程是否启用了功能若返回值为代表未开启功能代表开启模式则代表该进程启用了模式如果用户需要开启模式则建议用户根据实际业务场景设置合理的规则修复方法可以在业务进程中通过调用接口进行相关规则的配置具体配置方法可以参考的开源帮助文档时间同步应当正确配置服务级别建议适用版本全部规则说明集群场景下服务器时间是否准确是否一致比较关键例如当时间不一致时可能会导致不同服务器间产生的数据在根据时间进行排序或比较时产生的结果不准确即使我们在初始时使用命令把所有服务器时间配置成一致的随着时间的推移服务器的时间还是会出现不准确不一致所以为保证环境中所有机器的时间同步且准确必须有一个可以同步的时间服务器网络内的其他服务器都向该服务器进行时间同步当使用服务实现时间同步时如果没有正确配置服务则服务器时间可能不准确导致不同服务器间的时间可能不一致服务器时间不准确时对于类似财务订单等时间敏感的数据会有很大问题例如因为时间不准确可能导致一笔记账数据落在了错误的财务周期从而导致资产负债表期末余额不平服务器之间的时间不一致时每个主机产生的报文的时间就存在偏差如果多个服务器间数据流存在一定处理顺序后一个环节的服务器时间小于前一个服务器的时间时可能会导致收到的报文因为时间大于本地时间而丢弃规则影响无检查方法检查服务是否启动字段返回表示服务已经启动返回表示未启动通过命令查看中的配置获取权限控制配置通过命令查看中的配置表示具体的服务器或域名获取服务器配置修复方法将本机配置为时间源在文件中增加权限控制配置权限控制的地址可以是表示所有可以是不带的某一个具体地址例如也可以是表示某一段地址例如表示至的所有地址的服务器都可以连接本服务器获取服务权限控制的具体参数例如表示允许所有地址的服务器与本机时间源进行时间同步但不允许在此系统上查询或修改服务本机作为客户端配置时间源服务器为远端时间源服务器地址在文件中增加配置在进行前两项配置后可以同时配置既作为客户端从远端服务器获取授时也作为服务端给其他服务器授时使用命令重启服务应当正确配置服务级别建议适用版本全部规则说明授时服务器配置不正确可能导致本地服务器时间同周边其他服务器不同步同标准时间不同步对于一些强依赖于时间同步的服务如市场交易等可能造成业务中断错误甚至被攻击者利用时间差进行数据篡改伪造是一个开源的自由软件同传统服务一样它能保持系统时钟与授时服务器同步让时间保持精确由两个程序组成和是一个后台运行的守护进程用于调整内核中运行的系统时钟和授时服务器同步它确定计算机增减时间的比率并对此进行补偿提供了一个用户界面用于监控性能并进行多样化的配置它可以在运行服务的计算机上工作也可以在一台不同的远程计算机上工作如果根据业务场景选择使用作为时间同步服务需正确配置远端授时服务器并启用服务同可互相替换默认启用服务规则影响无检查方法使用命令查看文件中是否正确配置了授时服务器地址使用命令查看是否已启动服务如果返回进程表示已经启动修复方法修改文件在或字段添加正确的授时服务器地址如果有多个授时服务器可以按照优先顺序配置多条使用命令启动服务并查看服务启动状态日志审计确保审计已启用级别要求适用版本全部规则说明组件是审计框架的用户空间组件组件提供了三个程序完成审计和查看日志功能配置审计规则是通过程序完成的该程序启动时从读取这些规则后台程序本身可以通过设置文件来进行定制其他两个组件分别是和用于给其他应用发送事件通知而则通过与类似的方式对系统调用进行追踪系统中一些文件是非常重要的是不可以轻意修改的对于这类文件使用组件对其进行审计是非常有必要的默认要求启用审计功能规则影响审计系统提供了一种记录系统安全信息的方法为系统管理员在用户违反系统规则时提供及时的警告信息但启用后对性能有一定影响检查方法执行如下命令查看服务默认状态是否为执行如下命令查看服务当前是否已经启动修复方法使能并启动确保审计日志已启用级别要求适用版本全部规则说明用于配置日志文件到达大小上限时该如何处理默认配置表示单个文件写满后会重新创建日志文件进行记录不会删除原先的日志文件表示基于机制最多可以创建多少个日志文件如果日志文件数量达到上限则会依次覆盖最早创建的文件默认配置为取值范围为其中和表示不做一共有种可选配置项表示忽略日志文件大小上限继续在该文件上记录日志同类似只是达到上限时会记录一条日志达到日志文件大小上限服务进程停止日志记录达到日志文件大小上限新建日志文件继续记录如果文件数达到则覆盖旧文件同类似只是不受限制会一直新建文件规则影响会按照配置在日志文件达到写入上限之后依次覆盖最早创建的文件检查方法使用如下命令检查当前配置修复方法修改文件中和字段的值重启服务使配置生效应当配置登录审计规则级别建议适用版本全部规则说明用户成功登录时会在文件中刷新记录所以只要对该文件进行审计监控就可以记录用户登录事件如果不配置登录审计管理员无法从日志中追溯登录事件默认不配置登录审计规则建议用户根据实际业务场景配置相应规则规则影响配置登录审计由于在文件操作时需要记录审计日志对性能有轻微影响但由于登录动作本身不应快速频繁发生用户无感知检查方法通过执行如下指令检查用户登录的审计规则修复方法在目录下新建规则文件例如在文件中添加审计规则重启服务使规则生效应当配置账号信息修改审计规则级别建议适用版本全部规则说明通常情况下业务部署完成后用户账号用户组已经固定不会变更口令由于有效期的缘故会定期修改但也不频繁建议对这些认证授权关键数据进行审计监控如果有变更事后也可进行追溯修改账号用户组口令等行为在攻击行为中比较常见建议配置审计规则以便事后追溯默认不配置账号信息修改审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在操作对应配置文件时需要进行审计日志记录对性能有轻微影响但对用户账号用户组以及口令的修改应不频繁实际对用户无感知检查方法通过如下命令检查修改账号信息的审计规则修复方法在目录下新建规则文件例如在文件中添加审计规则重启服务使规则生效应当配置提权命令审计规则级别建议适用版本全部规则说明普通用户通过调用提权命令设置了可以获得超级管理员权限所以提权命令的使用具有较高风险往往被攻击者利用用于对系统进行攻击行为建议对提权命令进行审计监控以便事后追溯默认不配置提权命令审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在使用提权命令时需要进行审计日志记录对性能有轻微影响如果用户业务存在大量频繁调用提权命令的场景则可能存在累积效果检查方法使用如下脚本检查提权命令的审计规则如果系统中提权命令已经配置策略则该脚本执行后打印出对应策略行如果未配置则打印出字样如下修复方法通过如下方法查找系统中所有可提权命令并按照配置格式输出到文件中此处是文件中的值上可设置为重启服务使规则生效应当配置内核模块变更审计规则级别建议适用版本全部规则说明通常情况下业务部署完成后内核模块挂载已经固定不会变更如果发生变更可能存在攻击行为建议对内核模块变更进行审计监控事后也可进行追溯默认不配置内核模块变更审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在内核模块挂载卸载时需要进行审计日志记录对性能有轻微影响但内核模块挂载卸载相关操作应不频繁实际对用户无感知检查方法如果是位系统通过如下命令检查内核模块变更的审计规则如果是位系统还需有如下配置修复方法如果是位系统在目录下新建规则文件例如在文件中添加审计规则如果是位系统需要再添加相关配置考虑兼容性位系统中相关配置必须保留重启服务使规则生效应当配置管理员特权操作审计规则级别建议适用版本全部规则说明系统中提取命令操作日志默认记录在日志文件中该文件中还记录有其他认证相关的安全日志如果用户希望对提取命令进行审计建议将相关日志单独记录输出到中然后再对日志文件进行审计监控提权属于高危操作在攻击行为中比较常见建议配置审计规则以便事后追溯默认不配置管理员特权操作审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在进行任何提权操作时都需要进行审计日志记录对性能有轻微影响如果用户业务场景中存在大量频繁的操作对性能影响有累积效果检查方法通过如下命令检查管理员特权操作的审计规则其中输出日志路径根据实际配置情况可能有变化修复方法修改文件配置日志独立记录到文件中在目录下新建规则文件例如在文件中添加审计规则此处审计的文件必须是中配置的日志输出文件重启服务使规则生效应当在启动阶段启用级别建议适用版本全部规则说明在启动阶段启用可以对操作系统启动过程中服务完成启动前的事件进行审计启动过程中如果不启用审计如果攻击者在启动过程中添加一些攻击行为可能就无法被审计到默认不配置建议用户可根据实际场景确定是否在内核启动参数中添加字段以便在操作系统启动阶段使能审计功能规则影响无检查方法执行如下命令查看内核启动参数中是否已经添加修复方法修改文件直接在对应内核启动参数后面添加需要注意的是文件所在目录根据系统安装配置会有不同大部分情况存在于或目录下或者修改配置文件在字段添加然后重新生成文件修改后重启系统生效应当正确配置级别建议适用版本全部规则说明用于限制事件在发往服务进行处理之前在内核中的缓存队列的大小该值默认为如果队列满则开始丢弃事件并打印告警日志提示队列满如果该值配置过小则可能导致事件丢失如果在操作系统启动阶段已经配置了启用则建议将适当配置为较大值因为内核启动过程中服务尚未启动此时所有事件都是通过队列缓存的默认不配置建议用户根据实际场景设置参数的大小规则影响无检查方法执行如下命令查看内核启动参数中是否已经添加修复方法修改文件直接在对应内核启动参数后面添加需要注意的是文件所在目录根据系统安装配置会有不同大部分情况存在于或目录下或者修改配置文件在字段添加然后重新生成文件修改后重启系统生效避免使用设置规则级别建议适用版本全部规则说明服务规则可以在目录下的规则文件中配置后重启服务器生效也可以通过命令设置并立即生效目录权限为而权限为所以禁止通过命令修改服务规则可以缩小攻击面防止低权限攻击者通过命令行修改规则并立即实施攻击行为默认不禁止通过命令修改服务规则建议用户根据业务场景禁用方式设置规则影响无检查方法通过命令检查目录下是否存在特定的文件包含有字段修复方法在目录下新建以为后缀的规则文件可随意命名添加字段重启服务使规则生效确保日志大小限制配置正确级别要求适用版本全部规则说明日志文件需要配置大小限制达到限制后通过机制新建日志文件重新记录可以防止单个文件过大问题便于管理和追溯配置上限过大容易导致单个日志文件过大不利于管理配置上限过小则容易导致过多的日志文件或者日志文件因机制被频繁覆盖不利于事后追溯默认配置用户可根据实际场景修改配置规则影响无检查方法使用如下命令查看当前配置修复方法修改文件中字段的值单位是重启服务使配置生效应当正确配置硬盘空间阈值级别建议适用版本全部规则说明在记录日志过程中如果硬盘空间被写满可能导致业务无法正常执行所以需要提前设置相关配置项确保硬盘在即将写满或已经写满的情况下不至于引起更加严重的系统问题配置文件的如下相关项已配置默认值用户可根据业务场景修改配置项默认值说明配置硬盘空间下限告警动作阈值如低于则触发定义的告警动作硬盘空间低于时触发告警事件可选默认设置为表示不会阻止继续记录日志但会通过记录一次告警配置硬盘空间下限管理动作阈值如低于则触发定义的操作动作设置值不能大于的值硬盘空间低于时触发管理事件可选默认设置为表示服务停止向硬盘输出日志记录表示如果系统检测到硬盘已经写满则触发处理动作可选默认设置为表示服务停止向硬盘输出日志记录表示如果在记录日志时检测到硬盘错误则触发处理动作可选默认设置为表示服务停止向硬盘输出日志记录如果告警阈值和管理阈值配置过大则可能硬盘还有较大空间时日志就无法正常输出如果配置过小则会因为日志输出而将硬盘空间耗尽影响正常业务所以建议一方用户根据实际场景配置合理值另一方面建议将日志输出到单独分区避免日志过大影响业务规则影响无检查方法通过如下方法检查文件是否配置正确修复方法修改文件配置对应字段内容重启服务使配置生效应当配置审计规则级别建议适用版本全部规则说明命令允许普通用户提权执行管理员权限相关的操作属于高危操作攻击者一般无法直接获取权限但通过命令提权相对比较容易建议配置对文件以及目录审计记录读写操作的审计日志从而追溯是否有配置修改或读取操作提权操作需要读取配置如果不配置审计发生非法提权操作时不利于追溯默认不配置审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在文件操作时需要记录审计日志对性能有轻微影响检查方法通过如下方法检查是否存在针对文件以及目录的审计规则修复方法在目录下新建规则文件例如在文件中添加审计规则重启服务使规则生效应当配置会话审计规则级别建议适用版本全部规则说明建议对三个文件进行审计监控文件记录了当前所有的登录事件信息文件记录了所有的登录登出关机重启事件信息记录了登录失败事件信息如果不配置会话审计管理员无法从日志中追溯登录登出等事件或可追溯信息不够默认不配置会话审计规则建议用户根据实际业务场景进行配置规则影响配置会话审计由于在文件操作时需要记录审计日志对性能有轻微影响但由于登录登出动作本身不应快速频繁发生用户无感知检查方法通过如下方法检查是否存在针对文件的审计规则修复方法在目录下新建规则文件例如在文件中添加审计规则重启服务使规则生效应当配置时间修改审计规则级别建议适用版本全部规则说明系统时间是否准确影响着业务的正常运行除了通过时间同步服务器确保时间同步之外还需要关注管理员通过手工命令方式修改系统时间后者往往伴随着攻击风险如攻击者通过修改系统时间使某些保护策略失效例如口令过期达成攻击目的建议通过审计系统调用对系统时间修改进行日志记录同时对文件进行审计记录时区变更日志如果不配置时间修改审计管理员无法从日志中追溯时间变更事件默认不配置时间修改审计规则建议用户根据实际业务场景配置相应规则规则影响配置时间变更审计由于在文件操作或系统调用时需要记录审计日志对性能有轻微影响但由于时间变更动作本身不应快速频繁发生用户无感知检查方法如果是位系统通过如下命令检查配置如果是位系统还需有如下配置修复方法如果是位系统在目录下新建规则文件例如在文件中添加审计规则如果是位系统需要再添加相关配置考虑兼容性位系统中相关配置必须保留重启服务使规则生效应当配置审计规则级别建议适用版本全部规则说明是平台提供的强制访问控制功能组件用于对进程文件等进行细粒度的权限控制建议对配置文件策略文件等配置审计记录修改日志如果不配置审计如果发生非法策略修改不利于追溯默认不配置审计规则建议用户根据实际业务场景进行配置规则影响配置审计由于在策略文件操作时需要记录审计日志对性能有轻微影响检查方法通过如下命令检查相关审计配置修复方法在目录下新建规则文件例如在文件中添加审计规则重启服务使规则生效应当配置网络环境审计规则级别建议适用版本全部规则说明攻击者可能通过修改系统域名主机名等实施攻击行为比如主机欺骗等建议用户通过设置对系统调用的审计以及文件的审计监控系统域名主机名的修改通过设置对文件的审计监控登录提示信息的修改如果不配置相关审计如果发生非法修改不利于追溯默认不配置网络环境审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在文件操作时需要记录审计日志对性能有轻微影响但由于域名主机名以及登录提示信息不应被频繁修改实际对用户无感知检查方法如果是位系统通过如下命令检查配置如果是位系统还需有如下配置修复方法如果是位系统在目录下新建规则文件例如在文件中添加审计规则如果是位系统需要再添加相关配置考虑兼容性位系统中相关配置必须保留重启服务使规则生效应当配置文件访问控制权限审计规则级别建议适用版本全部规则说明文件访问权限控制是中基础的权限管理不同用户被授权可以访问不同的文件防止用户之间敏感信息泄露或文件数据被篡改也可以防止普通用户越权访问系统高权限文件或配置建议对操作系统中修改文件权限文件属主的系统调用进行审计监控如果不配置相关审计如果发生非法修改不利于追溯默认不配置文件访问控制权限审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在文件权限属主修改时需要记录审计日志对性能有轻微影响但由于此类操作不应被频繁执行实际对用户无感知检查方法如果是位系统通过如下命令检查配置如果是位系统还需有如下配置修复方法如果是位系统在目录下新建规则文件例如在文件中添加审计规则此处是文件中为通过方式添加用户用户的最小值上默认是如果是位系统需要再添加相关配置考虑兼容性位系统中相关配置必须保留重启服务使规则生效应当配置文件访问失败审计规则级别建议适用版本全部规则说明通过对等系统调用进行审计监控如果这些系统调用返回或错误则表示文件无权访问需要记录审计日志由于权限问题导致文件访问失败的场景在攻击行为中比较常见建议配置审计规则以便事后追溯默认不配置文件访问失败审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在文件访问失败时需要进行审计日志记录对性能有轻微影响但在实际场景中文件访问失败的场景较少影响有限检查方法如果是位系统通过如下命令检查配置如果是位系统还需有如下配置修复方法如果是位系统在目录下新建规则文件例如在文件中添加审计规则此处是文件中的值上默认是如果是位系统需要再添加相关配置考虑兼容性位系统中相关配置必须保留重启服务使规则生效应当配置文件删除审计规则级别建议适用版本全部规则说明操作系统中文件删除操作一般都属于高危操作管理员误操作或者攻击者攻击行为都可能导致严重的系统故障建议通过对等系统调用进行审计监控记录删除操作日志删除系统或业务文件在攻击行为中比较常见建议配置审计规则以便事后追溯默认不配置文件删除审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在文件删除时需要进行审计日志记录对性能有轻微影响如果实际业务场景存在大量文件删除操作则累积影响可能较大检查方法如果是位系统通过如下命令检查配置如果是位系统还需有如下配置修复方法如果是位系统在目录下新建规则文件例如在文件中添加审计规则此处是文件中的值上默认是如果是位系统需要再添加相关配置考虑兼容性位系统中相关配置必须保留重启服务使规则生效应当配置文件系统挂载审计规则级别建议适用版本全部规则说明通常情况下业务部署完成后文件系统挂载已经固定不会变更如果发生变更可能存在攻击行为建议对这些文件系统挂载进行审计监控如果有变更事后也可进行追溯默认不配置文件系统挂载审计规则建议用户根据实际业务场景配置相应规则规则影响配置审计由于在文件系统挂载时需要进行审计日志记录对性能有轻微影响但文件系统挂载相关操作应不频繁实际对用户无感知检查方法如果是位系统通过如下命令检查配置如果是位系统还需有如下配置修复方法如果是位系统在目录下新建规则文件例如在文件中添加审计规则此处是文件中的值上默认是如果是位系统需要再添加相关配置考虑兼容性位系统中相关配置必须保留重启服务使规则生效确保服务已启用级别要求适用版本全部规则说明当前系统日志默认存储在内存若不开启服务系统日志无法转储到持久性存储设备系统重启后会导致日志丢失服务用于转储分发系统日志具有以下特点多线程工作支持支持将日志存储到等多种关系数据库中支持日志信息过滤自定义输出格式规则影响无检查方法执行如下命令查看服务默认状态是否为执行如下命令查看服务是否已经启动成功修复方法执行如下命令使能或执行如下命令启动确保系统认证相关事件日志已记录级别要求适用版本全部规则说明必须记录系统认证相关的事件以便帮助分析用户登录权限使用以及监视系统的可疑动作等情况不记录系统认证相关事件日志会导致无法从日志上分析可疑的攻击动作例如攻击者尝试猜测管理员口令而进行的登录动作规则影响无检查方法检查文件中是否已经配置相关字段修复方法在文件添加如下设置执行如下命令重启服务使配置生效确保服务日志已记录级别要求适用版本全部规则说明系统计划任务一般由来承担由于可能会被黑客利用来加载恶意代码因此需要全部记录的日志信息以便跟踪系统异常状况不记录日志当出现攻击者恶意操作时将无法从日志信息中查看异常进而无法跟踪系统异常状况规则影响无检查方法检查文件中是否已经配置相关字段修复方法修改文件添加相关配置字段执行如下命令重启服务使配置生效应当正确配置默认文件权限级别建议适用版本全部规则说明日志文件记录了系统的行为日志工具能将日志记录到设定的文件中当设定的日志文件在系统中不存在时能创建新日志文件新创建的日志文件权限可在配置文件中进行配置通过设置默认文件权限以确保新创建的日志文件具有合理安全的权限若日志文件权限过大普通用户也能读取日志则增加了日志信息泄漏和被篡改的风险合理的日志文件权限确保敏感的日志数据能得到保护建议将日志权限设置为规则影响无检查方法检查或配置文件是否配置了合理的默认文件权限如果指令存在返回值且的值不为则说明系统日志信息存在泄露和被篡改的风险需对日志文件权限进行修复修复方法修改或为设置合理的权限中默认会包含中的配置因此配置任何一处即可执行如下命令重启服务使配置生效应当正确配置各服务日志记录级别建议适用版本全部规则说明配置日志记录这样系统的重要行为及安全相关的信息将使用进行记录配置文件及中可以指定记录日志的规则及哪些文件将用于记录特定类型的日志若不配置日志记录系统的行为无法记录在出现问题时无法进行问题定位及审计规则影响配置日志记录后如果不及时清理日志日志可能占满当前分区导致其他进程或系统故障风险检查方法检查及中是否配置了合理的日志记录规则例如修复方法在及中配置合理的日志记录规则以为例系统管理员在配置日志规则时按需进行合理配置以日志为例表示所有级别的日志意思是相关的日志记录到该文件中具体的日志配置规则可参考标准执行如下命令重启服务使配置生效确保转储日志已配置级别要求适用版本全部规则说明系统采用进行日志收集日志可能存在易失性存储设备上也有可能存储在持久性存储设备上存在日志丢失或者日志占满磁盘等问题及时对日志进行转储保障日志与系统更加安全规则影响日志如果存在易失性存储设备不及时对日志进行转储可能导致日志丢失如果存在持久性存储设备上日志量可能非常大不及时对日志进行转储有可能导致日志占满当前分区导致其他进程或系统故障风险检查方法检查文件中是否已经配置相关字段如果返回结果不为空表示已配置修复方法打开文件新增如下设置执行如下命令重启服务使配置生效确保日志已配置级别要求适用版本全部规则说明负责从系统中收集日志记录到文件中负责定期或定量对日志文件进行拷贝压缩以确保不会因为日志文件过大而导致占用过多的硬盘资源甚至日志文件不可维护如果不配置策略日志文件会一直增长最终可能导致日志所在硬盘分区空间耗尽轻则影响日志记录重则可能导致系统和业务无法继续正常执行默认已经在文件中配置的策略如下日志文件日志文件最大保留期限天日志文件最多保留个日志文件采用压缩方式保留日志文件达到进行操作规则影响无检查方法检查文件中是否已经配置相关字段此处是文件中配置的日志输出路径两者需要匹配一致修复方法在目录下创建配置文件比如文件检查并新增如下设置其中是文件中配置的日志输出路径两者需要匹配一致应当配置远程日志服务器级别建议适用版本全部规则说明日志服务可以将本地日志发送到远端日志服务器统一保存有利于组网环境下日志集中管理防止本地日志占用过多硬盘空间的同时也可以防止日志在本地被篡改如果不配置远程日志存储则日志会保存在本地文件中管理员正确配置日志存储路径以及参数的情况下对系统及业务无影响如果配置了远程日志存储就必须保证日志传输过程安全如传输日志前进行加密通过开启安全加密通道及更高版本等方法进行日志传输默认不配置远程日志存储建议用户根据实际业务场景进行配置规则影响配置远程日志存储则需要确保日志服务器有足够的硬盘空间用于存储组网环境下所有服务器上报的日志检查方法检查目录下配置文件中是否已经配置相关字段修复方法在目录下新建以为后缀的配置文件例如然后加入配置如下其中指将所有的日志都打印到服务器含义是日志类型日志级别就表示只将的日志打印到服务器表示使用协议表示使用协议如果是则添加如下配置执行如下命令重启服务使配置生效应当仅在指定的日志主机上接受远程消息级别建议适用版本全部规则说明默认情况下不会监听来自远程系统的日志消息需加载模块才能通过监听同理需要加载模块才能通过监听两者都需要指定监听的端口确保只在指定的日志主机上接收远程消息以便管理员集中管理但需要确保日志服务器有足够的硬盘空间用于存储组网环境下所有服务器上报的日志规则影响无检查方法运行如下命令检查及配置文件检查配置检查配置修复方法修改或配置接受远程消息并根据客户端单独存放在不同目录可以自定义指定目录修复配置修复配置执行如下命令重启服务使配置生效',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-25 18:01:07',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.techcat.cc/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://index.anheyu.com/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2748ef34.jpg" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">馒头馅儿大肉包</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=6681991756&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">八月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/" itemprop="url">Linux</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%BA%BF/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>安全配置基线</span></a></span></div></div><h1 class="post-title" itemprop="name headline">openEuler安全配置基线</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-25T09:21:30.000Z" title="发表于 2024-09-25 17:21:30">2024-09-25</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-09-25T10:01:07.327Z" title="更新于 2024-09-25 18:01:07">2024-09-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">78.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>291分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="openEuler安全配置基线"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s3.bmp.ovh/imgs/2023/08/27/70d5dea4dd88dfc1.webp?_r_=bb7c0e92-ec43-67b0-e72e-a37c058b5b71"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://blog.techcat.cc/posts/ec805823.html"><header><a class="post-meta-categories" href="/categories/Linux/" itemprop="url">Linux</a><a href="/tags/%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%BA%BF/" tabindex="-1" itemprop="url">安全配置基线</a><h1 id="CrawlerTitle" itemprop="name headline">openEuler安全配置基线</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">馒头馅儿大肉包</span><time itemprop="dateCreated datePublished" datetime="2024-09-25T09:21:30.000Z" title="发表于 2024-09-25 17:21:30">2024-09-25</time><time itemprop="dateCreated datePublished" datetime="2024-09-25T10:01:07.327Z" title="更新于 2024-09-25 18:01:07">2024-09-25</time></header><h1 id="openEuler安全配置基线-v1-0"><a href="#openEuler安全配置基线-v1-0" class="headerlink" title="openEuler安全配置基线 v1.0"></a>openEuler安全配置基线 v1.0</h1><table>
<thead>
<tr>
<th>版本</th>
<th>修订说明</th>
<th>修订时间</th>
<th>访问链接</th>
</tr>
</thead>
<tbody><tr>
<td>1.0</td>
<td>初始修订</td>
<td>2023年12月</td>
<td>本文档</td>
</tr>
</tbody></table>
<h2 id="1-初始部署"><a href="#1-初始部署" class="headerlink" title="1 初始部署"></a>1 初始部署</h2><h2 id="1-1-文件系统"><a href="#1-1-文件系统" class="headerlink" title="1.1 文件系统"></a>1.1 文件系统</h2><h3 id="1-1-1-禁止存在无属主或属组的文件或目录"><a href="#1-1-1-禁止存在无属主或属组的文件或目录" class="headerlink" title="1.1.1 禁止存在无属主或属组的文件或目录"></a>1.1.1 禁止存在无属主或属组的文件或目录</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>系统中不允许存在没有属主或属组的文件或目录，这些文件或目录一般都是由于原属主账号被删除，而文件未被删除导致。</p>
<p>这些文件存在安全隐患，可能导致信息泄露，占用不必要的磁盘空间和系统资源，还可能影响正常业务运行。</p>
<p>需要注意，在容器场景中，容器和宿主机使用不同的user namespace，这导致容器中的文件在宿主机中可能为无属主或属组的目录和文件。<br>对于容器的rootfs，宿主机已有相应的保护措施：宿主机上的rootfs的父目录，已做了权限控制，仅root用户可以访问。对于此情况的目录和文件可例外。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过如下两个命令，在系统根目录下查找无属主或属组的目录和文件，如果这两个命令没有返回值，表示系统中不存在无属主或属组的目录和文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find `df -l | sed -n &#x27;2,$p&#x27; | awk &#x27;&#123;print $6&#125;&#x27; ` -xdev -nouser 2&gt;/dev/null</span></span><br><span class="line"><span class="comment"># find `df -l | sed -n &#x27;2,$p&#x27; | awk &#x27;&#123;print $6&#125;&#x27; ` -xdev -nogroup 2&gt;/dev/null</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过rm命令删除无属主或属组的文件，此处需要注意，删除前务必确认确实为无用的文件或目录，否则可使用chown命令将目录或文件修改为正确的、且实际存在的属主或属组，方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm test -rf</span></span><br><span class="line">或</span><br><span class="line"><span class="comment"># chown test1:test1 test</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-禁止存在空链接文件"><a href="#1-1-2-禁止存在空链接文件" class="headerlink" title="1.1.2 禁止存在空链接文件"></a>1.1.2 禁止存在空链接文件</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>空链接文件一方面属于冗余文件，浪费系统资源，另一方面如果后续在链接目标位置安装或者创建了同名同路径的文件，但却没有清理历史上的链接文件，该目标文件就可以通过链接进行访问，可能导致文件信息泄露甚至被篡改。链接文件所指向的实际文件如果已经被删除，那么链接文件本身也就失去了存在的必要，务必同时删除，确保系统中不存在空链接文件。</p>
<p>需要注意，系统运行时，部分目录下存在一些系统临时文件或链接，这些是随进程动态变化的，可以作为例外忽略，这些目录常见的有：&#x2F;proc、&#x2F;run、&#x2F;var、&#x2F;sys、&#x2F;dev。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用find命令在全局或某个目录下查找空链接文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find ./ -type l -follow</span></span><br><span class="line">./testlink</span><br></pre></td></tr></table></figure>

<p>该命令如果返回输出为空，表示在指定目录下没有找到空链接文件，否则会返回空链接文件名，如上面例子中的testlink文件。</p>
<p>如果要排除某些目录不做搜索，例如排除&#x2F;proc、&#x2F;run、&#x2F;var、&#x2F;sys、&#x2F;dev目录，可使用如下命令，可以搜索到&#x2F;root目录下testlink是空链接文件，而部分系统目录被排除在外，未被搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -path /var -prune -o -path /run -prune -o -path /proc -prune -o -path /sys -prune -o -path /dev -prune -o -type l -follow</span></span><br><span class="line">/dev</span><br><span class="line">/proc</span><br><span class="line">/root/testlink</span><br><span class="line">/run</span><br><span class="line">/var</span><br><span class="line">/sys</span><br></pre></td></tr></table></figure>

<p>也可以使用-xdev参数，只搜索指定目录所在分区的文件系统，对于其他通过mount挂载的目录不做搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -xdev -type l -follow</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>搜索到空链接文件后，使用rm命令删除该文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find ./ -type l -follow</span></span><br><span class="line">./testlink</span><br><span class="line"><span class="comment"># rm ./testlink</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-禁止存在隐藏的可执行文件"><a href="#1-1-3-禁止存在隐藏的可执行文件" class="headerlink" title="1.1.3 禁止存在隐藏的可执行文件"></a>1.1.3 禁止存在隐藏的可执行文件</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>在linux系统中，以“.”为前缀的文件是隐藏文件（除了当前目录和上层目录的“.”、“..”），系统中不允许存在可执行的隐藏文件。</p>
<p>.bashrc、.bash_profile、.bash_logout这三个文件是系统在创建用户账号后，账号登录&#x2F;登出shell时的脚本文件，符合业界惯例，可不删除，其他隐藏的可执行文件必须删除，或去除可执行权限。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过find命令可以查找是否存在可执行的隐藏文件，如下命令是在根文件系统下全局查找，如果返回为空，则表示未找到任何可执行的隐藏文件，否则列出相应文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -type f -name &quot;\.*&quot; -perm /+x</span></span><br><span class="line">/etc/skel/.bashrc</span><br><span class="line">/etc/skel/.bash_profile</span><br><span class="line">/etc/skel/.bash_logout</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>根据实际情况，有三种修改方式：</p>
<ul>
<li><p>使用rm命令删除隐藏的可执行文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm .testfile</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用mv命令将隐藏文件修改为普通文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mv .testfile testfile</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用chmod命令去除可执行权限，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 644 .testfile</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-4-确保全局可写目录已设置sticky位"><a href="#1-1-4-确保全局可写目录已设置sticky位" class="headerlink" title="1.1.4 确保全局可写目录已设置sticky位"></a>1.1.4 确保全局可写目录已设置sticky位</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>sticky位，又叫粘滞位，普通文件的粘滞位会被内核忽略。粘滞位被设置在目录的执行许可位置上，用t表示，设置了该位后，其它用户就不可以删除该目录下不属于他的文件和目录。但是子目录不继承该权限，要再设置才可使用。对于全局可写的目录，要求必须设置粘滞位。</p>
<p>如果用户对目录有写权限，则可以删除其中的文件和子目录，即使该用户不是这些文件的所有者，而且也没有读或写许可。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令查找指定目录下有全局可写权限且未设置粘滞位的目录，返回为空表示未找到，举例中test目录为全局可写目录，但未设置粘滞位：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find ./ -type d -perm -0002 -a ! -perm -1000</span></span><br><span class="line">./test</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用chmod命令设置目录粘滞位，其中第一位“1”表示设置粘滞位，设置完成以后，可以通过ll命令查看是否已经设置成功，如下例子中，other用户的x位已经被设置为t：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 1777 test</span></span><br><span class="line"><span class="comment"># ll -d test</span></span><br><span class="line">drwxrwxrwt. 2 root root 4096 Nov  4 14:31 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-5-确保UMASK配置正确"><a href="#1-1-5-确保UMASK配置正确" class="headerlink" title="1.1.5 确保UMASK配置正确"></a>1.1.5 确保UMASK配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>UMASK是默认文件或目录权限的掩码，创建文件或目录的时候，以777权限按位减去UMASK的值，如果是文件，则还需要去掉可执行权限，然后得到文件或目录的默认权限设置。UMASK如果设置不合理，可能导致新建文件权限过小或过大，从而影响业务正常运行或导致安全风险。</p>
<p>考虑到社区版本在不同场景下的易用性，openEuler发行版默认不配置UMASK，请根据实际场景按需配置。</p>
<p><strong>规则影响：</strong></p>
<p>按规范要求将UMASK配置为077后，创建的文件默认权限为600，目录默认权限为700，会使属组及其他用户使用受限，降低易用性。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>检查配置文件中UMASK值是否正确，可以添加多个目录同时检查，例如下面代码中同时检查了&#x2F;etc&#x2F;bashrc和用户home目录下.bashrc文件，获得umask值为077：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^umask&quot; /etc/bashrc ~/.bashrc</span></span><br><span class="line">/etc/bashrc:<span class="built_in">umask</span> 0077</span><br><span class="line">/root/.bashrc:<span class="built_in">umask</span> 077</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用root用户登录，创建文件或目录，确认权限是否正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># touch test</span></span><br><span class="line"><span class="comment"># ll test</span></span><br><span class="line">-rw-------. 1 root root 0 Nov  4 17:36 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir testdir</span></span><br><span class="line"><span class="comment"># ll -d testdir</span></span><br><span class="line">drwx------. 2 root root 4096 Nov  4 17:36 testdir</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用普通账号test登录，创建文件或目录，确认权限是否正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> <span class="built_in">test</span></span><br><span class="line">$ ll <span class="built_in">test</span></span><br><span class="line">-rw-------. 1 <span class="built_in">test</span> <span class="built_in">test</span> 0 Nov  4 17:37 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">mkdir</span> testdir</span><br><span class="line">$ ll -d testdir</span><br><span class="line">drwx------. 2 <span class="built_in">test</span> <span class="built_in">test</span> 4096 Nov  4 17:37 testdir</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>可以在两个地方进行修改：</p>
<ul>
<li><p>在&#x2F;etc&#x2F;bashrc文件中对umask字段进行修改，该文件变化对全局所有用户下次登录有影响：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/bashrc</span></span><br><span class="line"><span class="built_in">umask</span> 0077</span><br></pre></td></tr></table></figure>
</li>
<li><p>在~&#x2F;.bashrc文件中对umask字段进行修改或添加，该文件变化只对当前用户下次登录时有影响，如果该文件中的配置同&#x2F;etc&#x2F;bashrc不一致，则以该文件为准：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /home/test/.bashrc</span><br><span class="line"><span class="built_in">umask</span> 0077</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-6-禁止存在全局可写的文件"><a href="#1-1-6-禁止存在全局可写的文件" class="headerlink" title="1.1.6 禁止存在全局可写的文件"></a>1.1.6 禁止存在全局可写的文件</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong><br>全局可写意味着所有用户都可以对文件进行写操作，通常情况下这种权限并不是必须的。如果文件被不合理的设置了全局可写权限，容易被攻击者篡改，导致安全风险。所以如果文件不得不存在全局可写的权限，需要针对实际场景分析安全风险，确保攻击者无法利用此文件进行攻击。</p>
<p>可以在根目录下搜索全局可写文件，需要例外的是：“&#x2F;sys”、“&#x2F;proc”这两个系统目录在linux运行时存在大量的全局可写文件，所以在检查时应排除这两个目录，避免混淆。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令在根目录下进行搜索（已排除了“&#x2F;sys”、“&#x2F;proc”这两个目录），返回全局可写文件列表，如果返回为空，表示无全局可写文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -path /proc -prune -o -path /sys -prune -o -type f -perm -0002 -exec ls -lg &#123;&#125; \;</span></span><br><span class="line">-rwxrwxrwx. 1 root 0 Dec  1 17:34 /root/test</span><br></pre></td></tr></table></figure>

<p>也可以使用-xdev参数，只搜索指定目录所在分区的文件系统，对于其他通过mount挂载的目录不做搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -xdev -type f -perm -0002 -exec ls -lg &#123;&#125; \;</span></span><br><span class="line">-rwxrwxrwx. 1 root 0 Dec  1 17:34 /root/test</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于不合理的权限，使用chmod命令进行修改，去除全局可写，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 755 test</span></span><br><span class="line"><span class="comment"># ll test</span></span><br><span class="line">-rwxr-xr-x. 1 root root 0 Dec  1 17:34 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-7-确保移除不需要的文件系统挂载支持"><a href="#1-1-7-确保移除不需要的文件系统挂载支持" class="headerlink" title="1.1.7 确保移除不需要的文件系统挂载支持"></a>1.1.7 确保移除不需要的文件系统挂载支持</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>Linux系统支持多种文件系统，通过ko方式加载进内核。openEuler作为通用操作系统平台，会提供各种文件系统ko，保存在&#x2F;lib&#x2F;modules&#x2F;(kernel version)&#x2F;kernel&#x2F;fs&#x2F;目录下，可以通过insmod&#x2F;modprobe命令进行加载支持。禁用不需要的文件系统的挂载支持，可以缩小攻击面，防止攻击者通过利用某些不常用文件系统的漏洞对系统进行攻击。</p>
<p>使用者应根据实际场景，确定哪些文件系统是不需要被支持的，并通过配置禁止这些文件系统被挂载，这些文件系统通常包括：</p>
<p>cramfs、freevxfs、jffs2、hfs、hfsplus、squashfs、udf、vfat、fat、msdos、nfs、ceph、fuse、overlay、xfs</p>
<p><strong>规则影响：</strong></p>
<p>移除的文件系统，不再被支持。</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令检查输出结果（例如cramfs，其他文件系统类似），如果输出“install &#x2F;bin&#x2F;true”，表示该文件系统已经被禁止挂载，如果输出“insmod &#x2F;lib&#x2F;modules&#x2F;(kernel version)&#x2F;kernel&#x2F;fs&#x2F;cramfs&#x2F;cramfs.ko”，表示该文件系统未被禁止挂载，并列出ko所在目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe -n -v cramfs | grep -E &#x27;(cramfs|install)&#x27;</span></span><br><span class="line">install /bin/true</span><br></pre></td></tr></table></figure>

<p>如果上述命令没有回显，再执行以下命令，如果有输出则表示该文件系统已被挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsmod | grep cramfs</span></span><br><span class="line">cramfs  135168  0</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对已挂载的文件系统，确定是实际场景不需要被支持的，可通过如下命令移除（例如cramfs，其他文件系统类似）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe -r cramfs</span></span><br></pre></td></tr></table></figure>

<p>在&#x2F;etc&#x2F;modprobe.d&#x2F;目录下，添加一个任意文件名的，并以.conf为后缀的配置文件，属主和属组均为root, 权限600，并根据实际场景将需要被禁止挂载的文件系统按照如下格式填入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/modprobe.d/test.conf</span></span><br><span class="line">install cramfs /bin/true</span><br><span class="line">install freevxfs /bin/true</span><br><span class="line">install jffs2 /bin/true</span><br><span class="line">install hfs /bin/true</span><br><span class="line">install hfsplus /bin/true</span><br><span class="line">install squashfs /bin/true</span><br><span class="line">install udf /bin/true</span><br><span class="line">install vfat /bin/true</span><br><span class="line">install fat /bin/true</span><br><span class="line">install msdos /bin/true</span><br><span class="line">install nfs /bin/true</span><br><span class="line">install ceph /bin/true</span><br><span class="line">install fuse /bin/true</span><br><span class="line">install overlay /bin/true</span><br><span class="line">install xfs /bin/true</span><br></pre></td></tr></table></figure>
<h3 id="1-1-8-确保无需修改的分区以只读方式挂载"><a href="#1-1-8-确保无需修改的分区以只读方式挂载" class="headerlink" title="1.1.8 确保无需修改的分区以只读方式挂载"></a>1.1.8 确保无需修改的分区以只读方式挂载</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>以只读方式挂载无需数据修改的文件系统，可以避免无意或恶意的数据篡改行为，减小攻击面。</p>
<p><strong>规则影响：</strong></p>
<p>文件系统一旦以只读方式挂载，将无法对文件和目录进行创建、修改、删除动作，用户需要根据实际场景进行配置，操作系统运行必须的文件挂载可以忽略此项要求。</p>
<p><strong>检查方法：</strong></p>
<p>通过mount命令查看挂载的文件系统是否符合要求，例如查看&#x2F;root&#x2F;readonly目录是否为只读挂载，可以使用如下命令，如果无返回数据，说明该目录未被挂载，或非只读挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount | grep &quot;\/root\/readonly&quot; | grep &quot;\&lt;ro\&gt;&quot;</span></span><br><span class="line">/dev/vda on /root/readonly <span class="built_in">type</span> ext4 (ro,relatime,seclabel)</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>卸载对应挂载点，重新以只读方式挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umount /root/readonly</span></span><br><span class="line"><span class="comment"># mount -o ro /dev/vda /root/readonly/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果硬盘或分区是通过&#x2F;etc&#x2F;fstab配置文件进行挂载的，那么通过修改该文件，为指定挂载点添加ro挂载方式，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/fstab</span></span><br><span class="line">/dev/vda /root/readonly ext4 ro 0 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-9-确保无需挂载设备的分区以nodev方式挂载"><a href="#1-1-9-确保无需挂载设备的分区以nodev方式挂载" class="headerlink" title="1.1.9 确保无需挂载设备的分区以nodev方式挂载"></a>1.1.9 确保无需挂载设备的分区以nodev方式挂载</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>nodev表示不允许挂载设备文件，用于减小攻击面，增加安全性。目录被挂载时，如果设置了nodev选项，那么该目录下所有块设备、字符设备等设备文件将被解析为普通文件，无法按设备文件进行操作。如果挂载时未设置nodev，将导致安全风险，例如攻击者在U盘上创建了一个文件系统，并在其中创建了一个块设备文件（自己的U盘，有相应的权限），而这个块设备实际是指向&#x2F;dev&#x2F;sda之类的服务器硬盘或分区的，如果攻击者有机会将U盘插入到服务器上，服务器又加载了这个U盘，那么攻击者可以通过这个块设备文件访问到相应硬盘数据。如果将上述案例中的U盘改为其他硬盘或分区，也存在类似问题，只要该硬盘或分区上存在恶意构造的设备文件，就可以形成攻击。</p>
<p>openEuler系统中默认如下目录被nodev挂载：&#x2F;sys、&#x2F;proc、&#x2F;sys&#x2F;kernel&#x2F;security、&#x2F;dev&#x2F;shm、&#x2F;run、&#x2F;sys&#x2F;fs&#x2F;cgroup、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd、&#x2F;sys&#x2F;fs&#x2F;pstore、&#x2F;sys&#x2F;fs&#x2F;bpf、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;files、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset、&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;rdma、&#x2F;sys&#x2F;kernel&#x2F;config、&#x2F;sys&#x2F;kernel&#x2F;debug、&#x2F;dev&#x2F;mqueue、&#x2F;tmp、&#x2F;run&#x2F;user&#x2F;0</p>
<p>openEuler存在以下目录（部分目录因硬盘分区，部署平台而不同），这些目录默认未被nodev挂载：&#x2F;dev、&#x2F;dev&#x2F;pts、&#x2F;、&#x2F;sys&#x2F;fs&#x2F;selinux、&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc、&#x2F;dev&#x2F;hugepages、&#x2F;boot、&#x2F;var&#x2F;lib&#x2F;nfs&#x2F;rpc_pipefs、&#x2F;boot&#x2F;efi、&#x2F;home。</p>
<p>实际场景中，根据业务需要，对不需要挂载设备的分区，采用nodev方式挂载。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过mount命令检查是否存在需要被设置nodev，但却未被设置的挂载点，对返回数据进行分析，确认未设置nodev的挂载点是否正确。此处举例中，除了系统默认未使用nodev挂载的目录外，用户新增的&#x2F;root&#x2F;nodev挂载点未使用nodev方式挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount | grep -v &quot;nodev&quot; | awk -F &quot; &quot; &#x27;&#123;print $3&#125;&#x27;</span></span><br><span class="line">/dev</span><br><span class="line">/dev/pts</span><br><span class="line">/</span><br><span class="line">/sys/fs/selinux</span><br><span class="line">/proc/sys/fs/binfmt_misc</span><br><span class="line">/dev/hugepages</span><br><span class="line">/boot</span><br><span class="line">/boot/efi</span><br><span class="line">/home</span><br><span class="line">/root/nodev</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>卸载对应挂载点，重新以nodev方式挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umount /root/nodev</span></span><br><span class="line"><span class="comment"># mount -o nodev /dev/vda /root/nodev/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果硬盘或分区是通过&#x2F;etc&#x2F;fstab配置文件进行挂载的，那么通过修改该文件，为指定挂载点添加nodev挂载方式，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/fstab</span></span><br><span class="line">/dev/vda /root/nodev ext4 nodev 0 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-10-确保无可执行文件的分区以noexec方式挂载"><a href="#1-1-10-确保无可执行文件的分区以noexec方式挂载" class="headerlink" title="1.1.10 确保无可执行文件的分区以noexec方式挂载"></a>1.1.10 确保无可执行文件的分区以noexec方式挂载</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>数据盘只是用于保存系统运行过程中的数据，并不需要在数据盘上执行相关命令，对于这种情况，该硬盘或分区必须以noexec方式挂载，提高安全性，减少攻击面。</p>
<p><strong>规则影响：</strong></p>
<p>硬盘或分区如果以noexec方式挂载，那么该挂载点目录下的可执行文件无法直接运行。</p>
<p><strong>检查方法：</strong></p>
<p>通过mount命令查看指定挂载点目录是否以noexec方式挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount | grep &quot;\/root\/noexec&quot; | grep &quot;noexec&quot;</span></span><br><span class="line">/dev/vda on /root/noexec <span class="built_in">type</span> ext4 (rw,noexec,relatime,seclabel)</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>卸载对应挂载点，重新以noexec方式挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umount /root/noexec</span></span><br><span class="line"><span class="comment"># mount -o noexec /dev/vda /root/noexec/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果硬盘或分区是通过&#x2F;etc&#x2F;fstab配置文件进行挂载的，那么通过修改该文件，为指定挂载点添加noexec挂载方式，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/fstab</span></span><br><span class="line">/dev/vda /root/noexec ext4 noexec 0 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-11-确保可移动设备分区以noexec、nodev方式挂载"><a href="#1-1-11-确保可移动设备分区以noexec、nodev方式挂载" class="headerlink" title="1.1.11 确保可移动设备分区以noexec、nodev方式挂载"></a>1.1.11 确保可移动设备分区以noexec、nodev方式挂载</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>可移动设备本身存在不确定性，来源、过往使用情况、运输过程等都无法保证绝对安全，因此可移动设备往往是病毒传播的主要宿主设备。所以针对可移动设备，要求必须以noexec、nodev方式挂载，提高安全性，减少攻击面。</p>
<p>noexec可以防止可移动设备上文件被直接执行，如病毒文件，攻击脚本等；</p>
<p>nodev可以防止可移动设备上不正确的设备文件链接到服务器真实设备，从而导致攻击行为；</p>
<p>常见的可移动设备如：CD&#x2F;DVD&#x2F;USB等。</p>
<p><strong>规则影响：</strong></p>
<p>可移动设备如果以noexec方式挂载，那么该挂载点目录下的可执行文件无法直接运行。</p>
<p><strong>检查方法：</strong></p>
<p>通过mount命令查看指定挂载点目录是否以noexec、nodev方式挂载，此处假设&#x2F;dev&#x2F;vda为可移动设备：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount | grep &quot;\/dev\/vda&quot;</span></span><br><span class="line">/dev/vda on /root/noexecdir <span class="built_in">type</span> ext4 (rw,nodev,noexec,relatime,seclabel)</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>卸载对应挂载点，重新以nodev、noexec方式挂载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umount /root/noexecdir</span></span><br><span class="line"><span class="comment"># mount -o nodev,noexec /dev/vda /root/noexecdir</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-12-确保无需SUID-SGID的分区以nosuid方式挂载"><a href="#1-1-12-确保无需SUID-SGID的分区以nosuid方式挂载" class="headerlink" title="1.1.12 确保无需SUID&#x2F;SGID的分区以nosuid方式挂载"></a>1.1.12 确保无需SUID&#x2F;SGID的分区以nosuid方式挂载</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>可执行文件设置SUID位后，即使执行该文件的用户并不是文件的属主，在执行过程中，该进程也会被暂时赋予文件属主的权限。例如普通用户test执行一个权限为755，属主为root的程序，那么如果该程序没有设置SUID位，进程就只有test用户的权限；如果被设置了SUID，执行过程中，进程就拥有root的权限。SGID是类似的功能，只不过是拥有了文件属组的权限。对于不需要有SUID&#x2F;SGID的分区采用nosuid的方式挂载，这样可以使该分区带SUID&#x2F;SGID的文件的S位失效，防止通过该分区的可执行文件进行提权，加强了分区的安全性。</p>
<p>用户需要根据实际场景，规划各挂载硬盘和分区，设置nosuid挂载项。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过mount命令检查文件系统是否以nosuid方式挂载，该命令返回未使用nosuid方式挂载的硬盘或分区，如下例中返回的挂载点均为系统默认挂载点（部分目录因硬盘分区，部署平台而不同），均需要suid功能，如果命令执行后存在与实际场景相关的目录，需要具体分析该目录是否挂载正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount | grep -v &quot;nosuid&quot;</span></span><br><span class="line">/dev/mapper/openeuler-root on / <span class="built_in">type</span> ext4 (rw,relatime,seclabel)</span><br><span class="line">selinuxfs on /sys/fs/selinux <span class="built_in">type</span> selinuxfs (rw,relatime)</span><br><span class="line">systemd-1 on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> autofs (rw,relatime,fd=33,pgrp=1,<span class="built_in">timeout</span>=0,minproto=5,maxproto=5,direct,pipe_ino=16986)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime,seclabel,pagesize=2M)</span><br><span class="line">/dev/sda2 on /boot <span class="built_in">type</span> ext4 (rw,relatime,seclabel)</span><br><span class="line">/dev/sda1 on /boot/efi <span class="built_in">type</span> vfat (rw,relatime,fmask=0077,dmask=0077,codepage=437,iocharset=ascii,shortname=winnt,errors=remount-ro)</span><br><span class="line">/dev/mapper/openEuler-home on /home <span class="built_in">type</span> ext4 (rw,relatime,seclabel)</span><br><span class="line">sunrpc on /var/lib/nfs/rpc_pipefs <span class="built_in">type</span> rpc_pipefs (rw,relatime)</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>卸载对应挂载点，重新以nosuid方式挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umount /root/nosuid</span></span><br><span class="line"><span class="comment"># mount -o nosuid /dev/vda /root/nosuid/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果硬盘或分区是通过&#x2F;etc&#x2F;fstab配置文件进行挂载的，那么通过修改该文件，为指定挂载点添加nosuid挂载方式，如：</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/fstab</span></span><br><span class="line">/dev/vda /root/nosuid ext4 nosuid 0 0</span><br></pre></td></tr></table></figure>
<h3 id="1-1-13-确保删除文件不必要的SUID和SGID位"><a href="#1-1-13-确保删除文件不必要的SUID和SGID位" class="headerlink" title="1.1.13 确保删除文件不必要的SUID和SGID位"></a>1.1.13 确保删除文件不必要的SUID和SGID位</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>在Linux中，SUID（Set User ID）和 SGID（Set Group ID）是在UNIX和类UNIX操作系统中用于控制程序权限的特殊权限位，确保文件不包含不必要的SUID和SGID位非常重要，以提高系统的安全性。这些位允许文件在执行时以文件所有者或文件所属组的权限运行，可能会导致潜在的安全风险</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>可使用如下命令查找系统中的SUID和SGID文件，如果无返回，表示不存在该类文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l &#123;&#125; \;</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>找到SUID或SGID文件，需要审查这些文件并确定是否确实需要这些权限。通常，只有一些特定的系统工具或程序需要SUID或SGID权限，而绝大多数文件不需要。</p>
<p>如果确定某个文件不需要SUID或SGID权限，可以将其文件删除或移除文件的SUID和SGID位，执行命令行如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm -rf /path/to/file</span></span><br><span class="line">或</span><br><span class="line"><span class="comment"># chmod u-s,g-s /path/to/file</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-14-确保关键文件、目录权限最小化"><a href="#1-1-14-确保关键文件、目录权限最小化" class="headerlink" title="1.1.14 确保关键文件、目录权限最小化"></a>1.1.14 确保关键文件、目录权限最小化</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>按照权限最小化要求，系统中的关键文件，特别是包含有敏感信息的文件，必须设置正确的最小的访问权限，只能有相应权限的用户可以访问，目录也是同样要求。文件或目录权限配置不正确，可能导致包含敏感数据的文件信息泄露，例如访问权限设置大于等于644，任何用户都可以访问，甚至篡改；只有root用户可以执行的程序，但却设置了755的权限，导致任何用户都可以执行，引入提权风险。</p>
<p>常见的需要做访问权限控制的文件或目录类型有：</p>
<ul>
<li><p>可执行文件（二进制文件、脚本），存放可执行文件的目录。如果权限配置不当可能会导致提权攻击。</p>
</li>
<li><p>配置文件、密钥文件、日志文件、存储有敏感信息的数据文件、系统运行时产生的临时文件、静态文件等。这些文件中可能会含有敏感数据、隐私数据，如果权限配置不当会增加信息泄露的风险。</p>
</li>
</ul>
<p>权限控制基本原则如下：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>设置值</th>
</tr>
</thead>
<tbody><tr>
<td>用户主目录</td>
<td>750（rwxr-x—）</td>
</tr>
<tr>
<td>程序文件(含脚本文件、库文件等)</td>
<td>550（r-xr-x—）</td>
</tr>
<tr>
<td>程序文件目录</td>
<td>550（r-xr-x—）</td>
</tr>
<tr>
<td>配置文件</td>
<td>640（rw-r—–）</td>
</tr>
<tr>
<td>配置文件目录</td>
<td>750（rwxr-x—）</td>
</tr>
<tr>
<td>日志文件(记录完毕或者已经归档)</td>
<td>440（r–r—–）</td>
</tr>
<tr>
<td>日志文件(正在记录)</td>
<td>640（rw-r—–）</td>
</tr>
<tr>
<td>日志文件目录</td>
<td>750（rwxr-x—）</td>
</tr>
<tr>
<td>Debug文件</td>
<td>640（rw-r—–）</td>
</tr>
<tr>
<td>Debug文件目录</td>
<td>750（rwxr-x—）</td>
</tr>
<tr>
<td>临时文件目录</td>
<td>750（rwxr-x—）</td>
</tr>
<tr>
<td>维护升级文件目录</td>
<td>770（rwxrwx—）</td>
</tr>
<tr>
<td>业务数据文件</td>
<td>640（rw-r—–）</td>
</tr>
<tr>
<td>业务数据文件目录</td>
<td>750（rwxr-x—）</td>
</tr>
<tr>
<td>密钥组件、私钥、证书、密文文件目录</td>
<td>700（rwx——-）</td>
</tr>
<tr>
<td>密钥组件、私钥、证书、加密密文</td>
<td>600（rw——-）</td>
</tr>
<tr>
<td>加解密接口、加解密脚本</td>
<td>500（r-x——）</td>
</tr>
</tbody></table>
<p>鉴于进程权限最小化原则，系统执行任务时一般使用非root的普通用户，该用户需要访问Linux系统中必要的目录和文件，所以对于系统本身运行依赖的系统目录、配置文件、可执行文件、证书文件，相应权限可适当放宽权限控制，建议如下：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>设置值</th>
</tr>
</thead>
<tbody><tr>
<td>目录</td>
<td>755（rwxr-xr-x）</td>
</tr>
<tr>
<td>程序文件（含脚本文件、库文件等）</td>
<td>755（rwxr-xr-x）</td>
</tr>
<tr>
<td>配置文件</td>
<td>644（rw-r–r–）</td>
</tr>
<tr>
<td>证书文件（无私钥）</td>
<td>444（r–r–r–）</td>
</tr>
</tbody></table>
<p>常见的需要做访问权限控制的文件的建议权限如下：</p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>设置值</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;passwd</td>
<td>0644（-rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;group</td>
<td>0644（-rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shadow</td>
<td>0000（———-）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;gshadow</td>
<td>0000（———-）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;passwd-</td>
<td>0644（-rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shadow-</td>
<td>0000（———-）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;group-</td>
<td>0644（-rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;gshadow-</td>
<td>0000（———-）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;ssh&#x2F;sshd_config</td>
<td>0600（-rw——-）</td>
</tr>
</tbody></table>
<p><strong>规则影响：</strong></p>
<p>权限配置不能过大，也不能过小，例如有些系统配置文件，如果将权限设置为600或640，那么普通用户就无法读取，相应的程序可能因为无权读取配置而无法执行。</p>
<p><strong>检查方法：</strong></p>
<p>使用ll命令或ls -l命令查看文件权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l test</span></span><br><span class="line">-rwxr-sr-t. 1 root root 33 Nov  5 14:44 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用chmod命令修改文件权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 750 test</span></span><br><span class="line"><span class="comment"># ll test</span></span><br><span class="line">-rwxr-x---. 1 root root 33 Nov  5 14:44 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-15-确保用户可打开文件数量配置正确"><a href="#1-1-15-确保用户可打开文件数量配置正确" class="headerlink" title="1.1.15 确保用户可打开文件数量配置正确"></a>1.1.15 确保用户可打开文件数量配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>在Linux系统中可以打开的文件总数是有限制的，如果全部资源被某个用户会话占用，其他用户将无法正常打开文件。</p>
<p>openEuler默认限制每个用户会话最多打开文件句柄数为1024，超过这个数会禁止打开新文件句柄。用户可以修改当前会话的最大允许值，但不能超过管理员设置的Hard上限（openEuler默认524288），root管理员可以修改该上限值，没有限制。用户可根据自身业务特点，设置合理的数值，防止单个用户会话的所有进程打开过多的文件句柄，耗尽系统资源。<br>可以通过ulimit命令进行设置，主要有两个参数：</p>
<ul>
<li>-Hn，该参数用于查看或设置上限最大值，这个值对于普通用户会话而言，一旦设定以后，只能调小，不能调大，比如第一次设置为3000（不能超过管理员设置的系统最大值，比如524288），那么后续设置只能为小于等于3000；</li>
<li>-Sn，该参数用于查看或设置当前上限值，这个值是实际用于打开句柄数判断的值，这个值可以任意调大或调小，但不能超过-Hn设置的上限最大值。</li>
</ul>
<p>普通用户进行设置，均只作用于当前会话。</p>
<p><strong>规则影响：</strong></p>
<p>设置过小，可能导致用户在当前会话中无法打开必要的文件句柄，设置过大可能导致系统资源耗尽。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>查看当前限制值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -Sn</span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看普通用户可修改的上限值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -Hn</span></span><br><span class="line">524288</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>可以通过修改&#x2F;etc&#x2F;security&#x2F;limits.conf文件配置每个用户默认的上限和上限最大值，比如加入如下行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名 hard nofile 10000</span><br><span class="line">用户名 soft nofile 2000</span><br></pre></td></tr></table></figure></li>
<li><p>可以在会话中使用ulimit命令进行临时设置。</p>
<p>普通用户设置上限2000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ulimit</span> -Sn 2000</span><br></pre></td></tr></table></figure>

<p>普通用户设置上限最大值5000（不能超过原上限最大值）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ulimit</span> -Hn 5000</span><br></pre></td></tr></table></figure>

<p>同时设置上限和上限最大值，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ulimit</span> -n 3000</span><br></pre></td></tr></table></figure>

<p>root用户设置上限以及上限最大值的方法同普通用户一样，但root用户可以将上限最大值设置为大于openEuler默认值524288：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -Hn 1000000</span></span><br><span class="line"><span class="comment"># ulimit -Hn</span></span><br><span class="line">1000000</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-16-确保软、硬链接文件保护配置正确"><a href="#1-1-16-确保软、硬链接文件保护配置正确" class="headerlink" title="1.1.16 确保软、硬链接文件保护配置正确"></a>1.1.16 确保软、硬链接文件保护配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>在Linux系统中，软、硬链接文件是一个文件链接到另一个目标文件，打开该链接文件其实就是打开目标文件。所以，攻击者以低权限用户伪造的软链接文件，可以被高权限用户执行，导致提权安全问题。硬链接文件有同样问题。</p>
<p>本规则要求系统中对软、硬链接进行加固，如果目标文件和链接文件不是同属主的，且链接文件属主无权执行目标文件的，无论访问该链接的用户是谁，均拒绝访问。</p>
<p>这里就会存在一种竞争风险，如果一个高权限进程需要在&#x2F;tmp目录（一般在全局可写目录下创建的文件容易被利用攻击，因为其他目录权限控制比较严格）创建一个临时文件A，可能的操作是先判断文件是否存在，如果不存在，就创建并打开。此时，攻击者可以在判断之后，创建之前，利用这个时间间隙创建一个同临时文件A同名的软链接文件到系统关键文件B（需要高权限管理员才能访问），此时，高权限进程创建并访问文件A，其实就相当于直接访问了文件B，原本攻击者对文件B没有权限，但利用高权限进程，访问到了文件B，通过该进程，可以对文件B进行破坏、篡改、数据窃取。</p>
<p>可以看到在这个案例中，原本文件A和B的属主应该都是root，但因为存在竞争攻击，A的属主变成了攻击者普通用户，临时文件变成了链接文件，B依旧是root属主，结果只要高权限进程有文件B的权限，就可以通过A这个软链接文件访问B。</p>
<p>openEuler默认已经设置软、硬链接保护。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令检查，如果返回值为1，表示已经启用保护：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl fs.protected_symlinks</span></span><br><span class="line">fs.protected_symlinks = 1</span><br><span class="line"><span class="comment"># sysctl fs.protected_hardlinks</span></span><br><span class="line">fs.protected_hardlinks = 1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>openEuler默认已经启用保护，无需设置。</p>
<ul>
<li><p>如果因实际场景需要启、闭保护状态，可使用如下命令临时设置，重启后恢复默认值：</p>
<p>启用保护</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w fs.protected_symlinks=1</span></span><br><span class="line">fs.protected_symlinks = 1</span><br><span class="line"><span class="comment"># sysctl -w fs.protected_hardlinks=1</span></span><br><span class="line">fs.protected_hardlinks = 1</span><br></pre></td></tr></table></figure>

<p>关闭保护</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w fs.protected_symlinks=0</span></span><br><span class="line">fs.protected_symlinks = 0</span><br><span class="line"><span class="comment"># sysctl -w fs.protected_hardlinks=0</span></span><br><span class="line">fs.protected_hardlinks = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过修改&#x2F;etc&#x2F;sysctl.conf文件，添加如下代码，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，实现永久启、闭保护状态：</p>
<p>启用保护</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line">fs.protected_symlinks = 1</span><br><span class="line">fs.protected_hardlinks = 1</span><br></pre></td></tr></table></figure>

<p>关闭保护</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line">fs.protected_symlinks = 0</span><br><span class="line">fs.protected_hardlinks = 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-1-17-避免使用USB存储"><a href="#1-1-17-避免使用USB存储" class="headerlink" title="1.1.17 避免使用USB存储"></a>1.1.17 避免使用USB存储</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>USB存储设备通常用于在服务器之间拷贝数据，但由于USB存储设备上的数据一般情况下无法通过技术手段保护，增加了被攻击的风险。如果USB设备上存在病毒、木马等攻击程序，将可能导致服务器被感染破坏，如果USB存储设备管理不善，将导致数据泄露。所以攻击者可以通过构造、破坏USB存储数据，再利用合法的管理人员在服务器上操作USB存储设备，达到攻击服务器、窃取数据的目的。建议根据实际场景，禁用USB存储。</p>
<p><strong>规则影响：</strong></p>
<p>无法使用USB存储数据</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令检查输出结果，如果输出“install &#x2F;bin&#x2F;true”，表示USB存储设备已经被禁止使用；如果输出“insmod &#x2F;lib&#x2F;modules&#x2F;(kernel version)&#x2F;kernel&#x2F;drivers&#x2F;usb&#x2F;storage&#x2F;usb-storage.ko.xz”，表示未被禁止，并列出ko所在目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe -n -v usb-storage</span></span><br><span class="line">install /bin/true</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;modprobe.d&#x2F;目录下，添加一个任意文件名的，并以.conf为后缀的配置文件，属主和属组均为root, 权限600，按照如下格式填入代码，即可禁用USB存储：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/modprobe.d/test.conf</span></span><br><span class="line">install usb-storage /bin/true</span><br></pre></td></tr></table></figure>
<h3 id="1-1-18-应当分区管理硬盘数据"><a href="#1-1-18-应当分区管理硬盘数据" class="headerlink" title="1.1.18 应当分区管理硬盘数据"></a>1.1.18 应当分区管理硬盘数据</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>在安装操作系统时，应根据实际场景特点，将操作系统数据同业务数据分区管理，避免将所有数据放在一个硬盘或分区下，合理规划硬盘分区可以避免或降低如下风险：</p>
<ul>
<li>日志文件过大，导致业务或系统数据盘满；</li>
<li>普通账号home目录过大，导致系统或业务盘满；</li>
<li>系统分区不独立，导致盘满后，操作系统基础服务故障，引起全面DOS攻击；</li>
<li>不利于权限最小化控制，不利于数据盘加密；</li>
<li>盘损坏后不利于系统或数据恢复。</li>
</ul>
<p>openEuler作为通用操作系统，默认安装单独分区“&#x2F;boot、&#x2F;tmp、&#x2F;home、&#x2F;”，建议根据实际场景确定其他目录的分区挂载以及大小。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过如下命令检查指定目录是否挂载合理，具体目录清单可根据实际情况增减，如果返回为空，表示这些目录都没有单独挂载分区，否则返回挂载列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df | grep -iE &quot;/boot|/tmp|/home|/var|/usr&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>根据实际使用场景对硬盘进行合理划分，建议如下：</p>
<ul>
<li>操作系统中的“&#x2F;boot、&#x2F;home、&#x2F;tmp、&#x2F;usr、&#x2F;var”目录，建议在系统安装部署时同根目录“&#x2F;”分开，单独分区挂载，并安装系统文件，其中“&#x2F;tmp”目录一般挂载为tmpfs格式的临时内存文件系统，如果关机后用户业务不需要保持“&#x2F;tmp”目录下文件持久化，可以不指定硬盘分区，操作系统自动挂载tmpfs文件系统；</li>
<li>业务数据目录建议单独分区或独立硬盘、磁阵挂载；</li>
<li>本地转储（或保存）的日志，建议单独分区或硬盘、磁阵挂载；</li>
<li>合理分配各个分区的空间大小。</li>
</ul>
<p>对于数据盘，可以通过mount命令进行临时挂载，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount /dev/sdb /mnt/data</span></span><br></pre></td></tr></table></figure>

<p>也可以修改&#x2F;etc&#x2F;fstab文件，确保下次重启后自动挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo &quot;/dev/sdb /home/test ext4 defaults 1 1&quot; &gt;&gt; /etc/fstab</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-19-确保LD-LIBRARY-PATH变量定义正确"><a href="#1-1-19-确保LD-LIBRARY-PATH变量定义正确" class="headerlink" title="1.1.19 确保LD_LIBRARY_PATH变量定义正确"></a>1.1.19 确保LD_LIBRARY_PATH变量定义正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>LD_LIBRARY_PATH是Linux的环境变量，程序加载动态链接库时，会优先从该环境变量指定的路径中获取。通常情况下该环境变量不应该被设置，如果被恶意设置为不正确的值，程序在运行时就有可能链接到不正确的动态库，导致安全风险。<br>注：&#x2F;etc&#x2F;ld.so.conf.d中配置也会影响动态库加载，需要确保正确配置。</p>
<p>openEuler默认不设置该变量，根据实际场景，如果必须设置LD_LIBRARY_PATH，需确保在所有用户上下文中该值都是正确的。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>有多个配置文件可以永久设置LD_LIBRARY_PATH值，需要进行排查，这些文件包括：&#x2F;etc&#x2F;profile、<del>&#x2F;.bashrc、</del>&#x2F;.bash_profile，后两个文件为用户home目录下的文件，每个用户都有，检查时务必不能遗漏。</p>
<p>使用grep命令进行检查，举例中发现&#x2F;etc&#x2F;profile文件中设置了LD_LIBRARY_PATH值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;LD_LIBRARY_PATH&quot; /etc/profile ~/.bashrc ~/.bash_profile</span></span><br><span class="line">/etc/profile:<span class="built_in">export</span> LD_LIBRARY_PATH=/home/</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查当前用户上下文中是否存在LD_LIBRARY_PATH值，如果未设置LD_LIBRARY_PATH，则echo命令执行完以后打印为空，否则打印出当前设置的LD_LIBRARY_PATH值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo $LD_LIBRARY_PATH</span></span><br><span class="line">/home/</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>删除所有配置文件中LD_LIBRARY_PATH配置项，或将其设置为正确值。</p>
<h3 id="1-1-20-确保用户PATH变量被严格定义"><a href="#1-1-20-确保用户PATH变量被严格定义" class="headerlink" title="1.1.20 确保用户PATH变量被严格定义"></a>1.1.20 确保用户PATH变量被严格定义</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>Linux下PATH变量定义的是当前用户上下文中可执行文件查找路径，例如：用户在任意目录下使用ls命令，那么系统会在PATH变量指定的目录下查找ls命令，找到后执行。所有用户上下文中的PATH变量不能包含当前目录“.”。目录必须是在文件系统中真实存在、并符合系统的设计期望的路径。正确的PATH值，可以有效防止系统命令被恶意的指令替代，确保系统命令能够安全执行。</p>
<p>所以PATH变量应该被定义为正确的值，openEuler系统默认设置为：</p>
<p>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</p>
<p>可以根据实际场景对PATH进行修改，但务必确保正确。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过echo命令可以打印出当前用户上下文中PATH的值，检查是否正确，openEuler root用户上下文中PATH值如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo $PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></table></figure>

<p>openEuler普通用户test上下文中PATH值如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo $PATH</span></span><br><span class="line">/usr/local/bin:/usr/bin</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>PATH环境变量分为两部分，一部分在&#x2F;etc&#x2F;profile文件中设置，一部分在用户目录下.bashrc或.bash_profile文件中设置，前者影响所有用户，后者只影响当前用户。</p>
<p>所以可以通过修改这两个文件中PATH相关字段代码，即可永久修改系统PATH变量值，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&lt;attach new path&gt;</span><br></pre></td></tr></table></figure>

<p>如果只是临时修改当前会话的PATH值，可以执行如下命令，会话关闭后失效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># export PATH=$PATH:&lt;attach new path&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="comment"># export PATH=&lt;the whole of new path&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-软件"><a href="#1-2-软件" class="headerlink" title="1.2 软件"></a>1.2 软件</h2><h3 id="1-2-1-禁止安装FTP客户端"><a href="#1-2-1-禁止安装FTP客户端" class="headerlink" title="1.2.1 禁止安装FTP客户端"></a>1.2.1 禁止安装FTP客户端</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong><br>FTP（File Transfer Protocol，文件传输协议），提供Linux服务器同其他服务器、桌面系统、终端设备之间的文件传输功能。FTP协议本身不支持加密传输，数据传输过程中容易被攻击者窃取，所以禁止安装FTP客户端，并使用FTP协议。未安装FTP客户端的设备，无法对外通过FTP协议进行传输，如业务需要进行文件传输，可以通过SFTP进行替代。</p>
<p><strong>规则影响：</strong></p>
<p>未安装FTP客户端，将无法同FTP服务器进行协议连接。</p>
<p><strong>检查方法：</strong></p>
<p>可通过如下命令检查是否安装了FTP软件，如果命令返回为”package ftp is not installed”，表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -q &quot;ftp&quot;</span></span><br><span class="line">package ftp is not installed</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已经安装了FTP软件的系统，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove ftp</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove ftp</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-禁止安装TFTP客户端"><a href="#1-2-2-禁止安装TFTP客户端" class="headerlink" title="1.2.2 禁止安装TFTP客户端"></a>1.2.2 禁止安装TFTP客户端</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong><br>TFTP（Trivial File Transfer Protocol，简单文件传输协议），提供Linux服务器同其他服务器、桌面系统、终端设备之间的文件传输功能。TFTP协议本身不支持认证和加密机制，通信过程中容易被攻击者仿冒、篡改、以及窃取，所以禁止安装TFTP客户端和服务。未安装TFTP客户端和服务的设备，无法对外提供TFTP服务，也无法使用客户端同外界基于TFTP协议进行通信，如业务需要进行文件传输，可以通过SFTP服务进行替代。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于TFTP服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>可通过如下命令检查是否安装了TFTP软件，如果命令返回“package tftp is not installed”，表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -q &quot;tftp&quot;</span></span><br><span class="line">package tftp is not installed</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已经安装了TFTP软件的系统，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove tftp tftp-server</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove tftp tftp-server</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-禁止安装Telnet客户端"><a href="#1-2-3-禁止安装Telnet客户端" class="headerlink" title="1.2.3 禁止安装Telnet客户端"></a>1.2.3 禁止安装Telnet客户端</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong><br>Telnet是一种应用层协议，常用于服务器的远程登录、操作控制、系统修改等；Telnet传输数据未被加密，用户名、口令、传输数据等容易被攻击者窃取，所以应禁止安装和使用Telnet客户端工具，可以使用基于ssh协议的客户端工具进行替代。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于Telnet服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>可通过如下命令检查是否安装了Telnet客户端软件，如果命令返回“package telnet is not installed”，表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -q &quot;telnet&quot;</span></span><br><span class="line">package telnet is not installed</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已经安装了Telnet软件的系统，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove telnet</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove telnet</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-禁止安装不安全的SNMP协议版本"><a href="#1-2-4-禁止安装不安全的SNMP协议版本" class="headerlink" title="1.2.4 禁止安装不安全的SNMP协议版本"></a>1.2.4 禁止安装不安全的SNMP协议版本</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>简单网络管理协议（SNMP，Simple Network Management Protocol），是专门设计用于在IP网络中管理网络节点的一种标准协议，该协议允许网元之间传递相关网络管理、控制数据。对于不需要SNMP的场景，如果安装了SNMP，则增加了系统资源消耗，并扩大了攻击面，特别是如果使用了SNMP v1.0协议，将导致攻击者可以轻易窃取、篡改、伪造SNMP报文，对各网元进行攻击。</p>
<p>openEuler安装镜像中提供了net-snmp安装包，但默认未安装。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于SNMP服务的程序执行受限制。</p>
<p><strong>检查方法：</strong> </p>
<p>可通过如下命令检查是否安装了snmp软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep -E &quot;net-snmp-[0-9]&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong> </p>
<p>对于已安装snmp组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove net-snmp</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove net-snmp</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-禁止安装python2"><a href="#1-2-5-禁止安装python2" class="headerlink" title="1.2.5 禁止安装python2"></a>1.2.5 禁止安装python2</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>python2 社区已经于2020年1月1日停止维护与改进。继续使用该软件容易扩大系统攻击面，增加系统漏洞和被攻击风险，所以禁止使用python2。若有使用python的诉求，建议使用主流版本以减小安全风险。</p>
<p>openEuler安装镜像中不提供python2相关软件包。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于python2的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>可通过如下命令检查是否安装了python2软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep &quot;python2-&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong> </p>
<p>对于已安装python2组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove python2</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove python2</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-6-确保yum源配置GPG校验"><a href="#1-2-6-确保yum源配置GPG校验" class="headerlink" title="1.2.6 确保yum源配置GPG校验"></a>1.2.6 确保yum源配置GPG校验</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>安装包在网络传输或本地存储时存在被攻击者恶意篡改的可能，若未对安装包进行完整性校验，则可能安装了攻击者篡改后的软件，导致服务器甚至整个网络集群遭受攻击。如果使用repo源进行操作系统软件安装升级，必须配置GPG校验。</p>
<p>openEuler支持使用dnf或yum命令从repo源下载、安装或升级rpm包，通过&#x2F;etc&#x2F;yum.repo.d目录下的文件进行repo源配置，必须配置GPG校验，在系统中必须已安装GPG公钥，或者在repo源配置文件中指定公钥下载地址。</p>
<p>GPG公钥是校验RPM包合法性的关键，请确保安装可信的GPG公钥。</p>
<p><strong>规则影响：</strong></p>
<p>无GPG的repo源无法正常使用。</p>
<p><strong>检查方法：</strong></p>
<p>检查系统中是否已经加载GPG公钥，如果返回为空，表示未安装公钥，如果有不同的repo源配置，可能会有多个不同的公钥返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa gpg-pubkey*</span></span><br><span class="line">gpg-pubkey-e2ec75bc-5c78bcae</span><br></pre></td></tr></table></figure>

<p>检查repo源配置文件中是否包含有“gpgcheck&#x3D;1”字段，如果有多个配置文件，则每个配置文件都应该设置该字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -iE &quot;^gpgcheck[ ]*=[ ]*1&quot; /etc/yum.repos.d/ -rn</span></span><br><span class="line">/etc/yum.repos.d/base.repo:6:gpgcheck=1</span><br></pre></td></tr></table></figure>

<p>检查repo源配置文件中是否已配置公钥下载地址（如果系统中已经安装有对应repo源的公钥，则不是必须配置）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -iE &quot;^gpgkey&quot; /etc/yum.repos.d/ -rn</span></span><br><span class="line">/etc/yum.repos.d/base_tmp.repo:7:gpgkey=&lt;repo源GPG公钥地址&gt;</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>openEuler所有商用发布的rpm包都经过GPG私钥签名，通过rpm命令进行安装时会校验签名是否合法，如果校验不通过，可以安装，但会给出告警提示（如下）。禁止通过添加–nosignature –nodigest等方式跳过签名和完整性校验。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -ivh keyutils-&lt;version numbers&gt;.rpm</span></span><br><span class="line">warning: keyutils-&lt;version numbers&gt;.rpm: Header V4 RSA/SHA256 Signature, key ID e2ec75bc: NOKEY</span><br><span class="line">Verifying...            <span class="comment">################################# [100%]</span></span><br><span class="line">Preparing...            <span class="comment">################################# [100%]</span></span><br><span class="line">Updating / installing...</span><br><span class="line">   1:keyutils-&lt;version numbers&gt;  <span class="comment">################################# [100%]</span></span><br></pre></td></tr></table></figure>

<p>通过repo源进行rpm包安装时，必须在repo源配置文件中添加gpgcheck&#x3D;1字段，开启GPG校验，并添加正确的GPG公钥下载地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/yum.repos.d/base.repo</span></span><br><span class="line">[Euler]</span><br><span class="line">name=Euler</span><br><span class="line">baseurl=&lt;repo源地址&gt;</span><br><span class="line">gpgkey=&lt;repo源GPG公钥地址&gt;</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br><span class="line">gpgcheck=1</span><br></pre></td></tr></table></figure>

<p>如果repo配置文件中不包含GPG公钥下载地址，则必须通过rpm命令安装对应源的公钥，如果有多个repo源，则每个repo源可能有不同的GPG公钥，需要分别安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm --import ./key</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-7-禁止启用debug-shell服务"><a href="#1-2-7-禁止启用debug-shell服务" class="headerlink" title="1.2.7 禁止启用debug-shell服务"></a>1.2.7 禁止启用debug-shell服务</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>debug-shell 服务主要是用来定位系统引导过程中出现的问题，该服务随systemd安装而被安装。开启debug-shell服务后可以在系统启动过程中，systemd启动阶段按下ctrl + alt + F9，攻击者不需要认证直接进入root shell。该过程安全风险很高，攻击者可以通过篡改数据，执行非法程序等手段破坏系统。</p>
<p>openEuler默认禁止启动debug-shell服务。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查是否启动了服务，如果命令返回为disable，则表示服务未启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled debug-shell</span></span><br><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装debug-shell组件的服务器，可以禁用debug-shell服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now disable debug-shell</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-8-禁止安装rsync服务"><a href="#1-2-8-禁止安装rsync服务" class="headerlink" title="1.2.8 禁止安装rsync服务"></a>1.2.8 禁止安装rsync服务</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>rsync服务可以用于在服务器之间或者服务器本地不同硬盘分区之间同步数据，但由于rsync使用不加密的传输协议，存在信息泄露的风险。若启用rsync服务，并且在不同服务器之间通过网络传输数据，则攻击者可以通过监听服务器端口或者路由器、交换机数据报文，窃取数据。</p>
<p>openEuler安装镜像中提供了rsync安装包，要求在生产环境中不启动rsync服务。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于rsync服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>步骤1：</p>
<p>检查是否安装了rsync软件，如果命令返回为空，则表示未安装，符合规范要求，检查结束，否则继续执行步骤2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep &quot;rsync&quot;</span></span><br></pre></td></tr></table></figure>

<p>步骤2：</p>
<p>安装了rsync软件时，检查rsync服务是否开启，disabled表示未启用服务，符合规范要求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled rsyncd</span></span><br><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装rsync组件的服务器，可以禁用rsyncd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now disable rsyncd</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-9-禁止安装avahi服务"><a href="#1-2-9-禁止安装avahi服务" class="headerlink" title="1.2.9 禁止安装avahi服务"></a>1.2.9 禁止安装avahi服务</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>avahi是一种零配置的网络实现，包括用于多播DNS&#x2F;DNS-SD服务的自动发现及自动广播。例如，用户可以将服务器接入网络，并让avahi自动广播其上运行的网络服务，从而方便其他用户访问这些服务。通常并不需要自动发现或者自动广播业务，如果启用不必要的avahi服务，不仅浪费了系统资源，还扩大了攻击面，攻击者可以轻易获取服务器服务情况，并进行针对性的攻击。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于avahi服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否安装了avahi软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep &quot;avahi&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，由于其他组件依赖，系统默认安装有avahi-libs。同时，可以通过systemctl命令检查是否安装avahi服务（如下返回表示未启动，且未安装avahi服务）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled avahi-daemon</span></span><br><span class="line">Failed to get unit file state <span class="keyword">for</span> avahi-daemon.service: No such  file or directory</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装avahi组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove avahi</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove avahi</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-10-禁止安装LDAP服务"><a href="#1-2-10-禁止安装LDAP服务" class="headerlink" title="1.2.10 禁止安装LDAP服务"></a>1.2.10 禁止安装LDAP服务</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>LDAP（Lightweight Directory Access Protocol，轻型目录访问协议）是一个轻量级的目录访问协议，提供访问控制和维护分布式的目录信息。系统提供LDAP服务会增加系统资源占用，且扩大了攻击面，如果用户业务场景不需要提供LDAP服务，则禁止安装LDAP服务。</p>
<p>openEuler安装镜像中提供了openldap-servers安装包，但默认未安装。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于LDAP服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否安装了openldap-servers软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep &quot;openldap-servers&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装openldap-servers组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove openldap-servers</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove openldap-servers</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-11-禁止安装打印服务"><a href="#1-2-11-禁止安装打印服务" class="headerlink" title="1.2.11 禁止安装打印服务"></a>1.2.11 禁止安装打印服务</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>CUPS（Common Unix Printing System，Unix通用打印系统），启用该服务的服务器为网络内其他设备提供打印服务。提供CUPS服务会占用系统资源，并扩大攻击面。如果业务场景不需要提供打印服务，则禁止安装打印服务。</p>
<p>openEuler安装镜像中提供了CUPS相关的安装包，但默认未安装。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于CUPS服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否安装了CUPS软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa cups</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装CUPS组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove cups</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove cups</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-12-禁止安装NIS服务端"><a href="#1-2-12-禁止安装NIS服务端" class="headerlink" title="1.2.12 禁止安装NIS服务端"></a>1.2.12 禁止安装NIS服务端</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>NIS（Network Information Service，网络信息服务），以客户端&#x2F;服务器形式存在，客户端（ypbind）从服务器获取分发的配置信息。NIS服务本质上是一个不安全的服务，容易受到DOS、缓冲区溢出等攻击。如果业务不涉及NIS服务，禁止安装NIS服务端。</p>
<p>openEuler安装镜像中提供了NIS服务端安装包（ypserv），但默认未安装。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于NIS服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否安装了ypserv软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep &quot;ypserv&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装ypserv组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove ypserv</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove ypserv</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-13-禁止安装NIS客户端"><a href="#1-2-13-禁止安装NIS客户端" class="headerlink" title="1.2.13 禁止安装NIS客户端"></a>1.2.13 禁止安装NIS客户端</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>NIS（Network Information Service，网络信息服务），以客户端&#x2F;服务器形式存在，客户端（ypbind）从服务器获取分发的配置信息。NIS服务本质上是一个不安全的服务，容易受到DOS、缓冲区溢出等攻击。如果业务不涉及NIS服务，禁止安装并使用NIS客户端。</p>
<p>openEuler安装镜像中提供了ypbind安装包，但默认未安装。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于NIS服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否安装了ypbind软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep &quot;ypbind&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装ypbind组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove ypbind</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove ypbind</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-14-禁止安装LDAP客户端"><a href="#1-2-14-禁止安装LDAP客户端" class="headerlink" title="1.2.14 禁止安装LDAP客户端"></a>1.2.14 禁止安装LDAP客户端</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>LDAP（Lightweight Directory Access Protocol，轻型目录访问协议）是一个轻量级的目录访问协议，提供访问控制和维护分布式的目录信息。系统提供LDAP客户端会造成系统资源浪费，且扩大了攻击面。如果业务场景不需要使用LDAP服务，则禁止安装LDAP客户端。</p>
<p>openEuler安装镜像中提供了openldap-clients安装包，但默认未安装。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于LDAP服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否安装了openldap-clients软件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep &quot;openldap-clients&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装openldap-clients组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove openldap-clients</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove openldap-clients</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-15-禁止安装网络嗅探类工具"><a href="#1-2-15-禁止安装网络嗅探类工具" class="headerlink" title="1.2.15 禁止安装网络嗅探类工具"></a>1.2.15 禁止安装网络嗅探类工具</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>生产环境中如果包含有网络嗅探类工具，容易被攻击者利用这些工具进行网络分析，辅助网络攻击。所以应在生产环境中禁止安装各类网络嗅探、抓包分析类工具，例如tcpdump、ethereal、wireshark等。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>编写脚本工具，在生产环境或镜像环境中通过关键字扫描来判断是否存在网络嗅探类工具，脚本中可以包含如下命令：</p>
<ul>
<li><p>查找相关rpm包是否被安装，用户可根据自身场景，在此基础上添加需要检查的所有rpm包名（此处只是举例，实际包名及范围由用户确定），如果返回为空，表示未安装，否则返回已安装的rpm包列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep -iE &quot;^(wireshark-|netcat-|tcpdump-|nmap-|ethereal-)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找相关命令是否被安装，用户可根据自身场景，在此基础上添加需要检查的所有命令名（此处只是举例，实际命令名及范围由用户确定），如果返回为空，表示未安装，否则返回已安装的命令列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># files=`find / -type f \( -name &quot;wireshark&quot; -o -name  &quot;netcat&quot; -o -name &quot;tcpdump&quot; -o -name &quot;nmap&quot; -o  -name &quot;ethereal&quot; \) 2&gt;/dev/null`;for f in $files;do if [ -n &quot;$f&quot; ];then file $f | grep -i &quot;ELF&quot; ;fi;done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>如果用户业务环境中安装有网络嗅探类软件，需通过rpm命令查找并删除软件包，例如删除nmap：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -e nmap</span></span><br></pre></td></tr></table></figure>

<p>或者通过rm命令手工删除nmap命令文件，但这种方式仅限于非rpm包方式安装的网络嗅探工具，且需确保删除所有相关文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm /usr/bin/nmap</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-16-禁止安装调测类工具"><a href="#1-2-16-禁止安装调测类工具" class="headerlink" title="1.2.16 禁止安装调测类工具"></a>1.2.16 禁止安装调测类工具</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>业务环境中如果包含有调测类脚本、工具，容易被攻击者利用并攻击。所以应在生产环境中严禁安装各类调测工具、文件，包括但不限于：代码调试工具，用于调测功能的提权命令、脚本、工具，调试阶段使用的证书、密钥，用于性能测试的perf工具、打点、打桩工具，用于CVE等安全问题验证的攻击脚本、工具脚本等。常见的开源第三方调测类工具包括：strace、gdb、readelf、perf等。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>编写脚本工具，在业务环境或镜像环境中通过关键字扫描来判断是否存在调测类工具，脚本中可以包含如下命令：</p>
<ul>
<li><p>查找相关rpm包是否被安装，用户可根据自身场景，在此基础上添加需要检查的所有rpm包名（此处只是举例，实际包名及范围由用户确定），如果返回为空，表示未安装，否则返回已安装的rpm包列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep -iE &quot;^strace-|^gdb-|^perf-|^binutils-extra|^appict|^kmem_analyzer_tools&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找相关命令是否被安装，用户可根据自身场景，在此基础上添加需要检查的所有命令名（此处只是举例，实际命令名及范围由用户确定），如果返回为空，表示未安装，否则返回已安装的命令列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -type f \( -name &quot;gdb&quot; -o -name  &quot;perf&quot; -o -name &quot;strace&quot; -o -name &quot;readelf&quot; \)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>如果用户业务环境中安装有调测类软件，需通过rpm命令查找并删除软件包，例如删除gdb：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -e gdb</span></span><br></pre></td></tr></table></figure>

<p>或者通过rm命令手工删除gdb命令文件，但这种方式仅限于非rpm包方式安装的调测工具，且需确保删除所有相关文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm /usr/bin/gdb</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-17-禁止安装开发编译类工具"><a href="#1-2-17-禁止安装开发编译类工具" class="headerlink" title="1.2.17 禁止安装开发编译类工具"></a>1.2.17 禁止安装开发编译类工具</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>业务环境中如果包含有编译工具，容易被攻击者利用，对环境内关键文件进行编辑篡改、逆向分析，从而实施攻击行为。所以应在生产环境中严禁安装各类编译、反编译、二进制分析类工具，包括但不限于：编译工具，反编译工具，编译环境等。常见的第三方开发编译类工具包括：gcc、cpp、mcpp、flex、cmake、make、rpm-build、ld、ar等。</p>
<p>如果业务环境在部署或运行过程中依赖python、lua、perl等解释器，则可以保留解释器运行环境。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>编写脚本工具，在业务环境或镜像环境中通过关键字扫描来判断是否存在开发编译类工具，脚本中可以包含如下命令：</p>
<ul>
<li><p>查找相关rpm包是否被安装，用户可根据自身场景，在此基础上添加需要检查的所有rpm包名（此处只是举例，实际包名及范围由用户确定），如果返回为空，表示未安装，否则返回已安装的rpm包列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep -iE &quot;^(gcc-|cpp-|mcpp-|flex-|cmake-|make-|rpm-build-|binutils-extra|elfutils-extra|llvm-|rpcgen-|gcc-c++|libtool)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找相关命令是否被安装，用户可根据自身场景，在此基础上添加需要检查的所有命令名（此处只是举例，实际命令名及范围由用户确定），如果返回为空，表示未安装，否则返回已安装的命令列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># files=`find / -type f \( -name &quot;gcc&quot; -o -name &quot;g++&quot; -o -name &quot;c++&quot; -o -name  &quot;cpp&quot; -o -name &quot;mcpp&quot; -o -name &quot;flex&quot; -o -name &quot;lex&quot; -o -name  &quot;cmake&quot; -o -name &quot;make&quot; -o -name &quot;rpmbuild&quot; -o  -name &quot;ld&quot; -o -name &quot;ar&quot; -o -name &quot;llc&quot; -o -name &quot;rpcgen&quot; -o -name &quot;libtool&quot; -o -name &quot;javac&quot; -o -name &quot;objdump&quot; -o -name &quot;eu-objdump&quot; -o -name &quot;eu-readelf&quot; -o -name &quot;nm&quot; \) 2&gt; /dev/null`; for f in $files; do if [ -n &quot;$f&quot; ]; then file $f | grep -i &quot;ELF&quot;; fi; done</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>如果业务环境中安装有开发编译类软件，需通过rpm命令查找并删除软件包，例如删除gcc：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -e gcc</span></span><br></pre></td></tr></table></figure>

<p>或者通过rm命令手工删除gcc命令文件，但这种方式仅限于非rpm包方式安装的开发编译工具，且需确保删除所有相关文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm /usr/bin/gcc</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-18-避免安装X-Window系统"><a href="#1-2-18-避免安装X-Window系统" class="headerlink" title="1.2.18 避免安装X Window系统"></a>1.2.18 避免安装X Window系统</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>X Window在Linux系统中提供图形界面供用户登录和操作，通常情况下服务器场景无需图形界面，管理员通过命令行即可对服务器完成配置修改。X Window图形界面扩大了攻击面，不常用或相对小众的图形界面组件可能存在较多的软件缺陷，容易被攻击者利用，进而对系统进行破坏。另外，在无需图形界面的服务器上安装X Window组件，浪费了服务器资源，增加了维护成本</p>
<p><strong>规则影响：</strong></p>
<p>X Windows相关组件无法使用</p>
<p><strong>检查方法：</strong></p>
<p>检查是否安装了X Window相关组件，如果命令返回为空，则表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qa &quot;xorg-x11&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装X Window组件的服务器，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove &lt;package name&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="comment"># dnf remove &lt;package name&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-19-避免安装HTTP服务"><a href="#1-2-19-避免安装HTTP服务" class="headerlink" title="1.2.19 避免安装HTTP服务"></a>1.2.19 避免安装HTTP服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>HTTP代表超文本协议（Hypertext Transfer Protocol，HTTP）,是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式。HTTP服务器允许客户端（通常是浏览器）通过HTTP协议请求网页、图像、文档等Web内容，并将这些内容传送给客户端。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于HTTP服务的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>可通过如下命令检查是否安装了httpd客户端软件，如果命令返回“package httpd is not installed”，表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -q &quot;httpd&quot;</span></span><br><span class="line">package httpd is not installed</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已经安装了httpd软件的系统，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove httpd</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove httpd</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-20-避免安装samba服务"><a href="#1-2-20-避免安装samba服务" class="headerlink" title="1.2.20 避免安装samba服务"></a>1.2.20 避免安装samba服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>samba守护进程允许系统管理员配置Linux系统以与windows桌面共享文件系统和目录。samba将通过服务器信息块（SMB）协议公布文件系统和目录。Windows桌面用户将能够将这些目录和文件系统作为盘符挂载在系统上。</p>
<p><strong>规则影响：</strong></p>
<p>与Windows系统进行文件共享或打印共享受限制。</p>
<p><strong>检查方法：</strong></p>
<p>可通过如下命令检查是否安装了samba软件，如果命令返回“package samba is not installed”，表示未安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -q &quot;samba&quot;</span></span><br><span class="line">package samba is not installed</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已经安装了samba软件的系统，可以通过yum或dnf命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum remove samba</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf remove samba</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-21-避免启用DNS服务"><a href="#1-2-21-避免启用DNS服务" class="headerlink" title="1.2.21 避免启用DNS服务"></a>1.2.21 避免启用DNS服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>域名系统(DNS)是一种分层命名系统，它将名称映射到计算机、服务和其它联网资源的IP地址。</p>
<p>除非系统被专门指定用作DNS服务器，否则建议禁用DNS Server以减少潜在的攻击面。</p>
<p><strong>规则影响：</strong></p>
<p>将无法作为域名服务器提供域名解析服务。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否启动了服务，如果命令返回为disable，则表示服务未启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled named</span></span><br><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装named组件的服务器，可以禁用named服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now disable named</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-22-避免启用NFS服务"><a href="#1-2-22-避免启用NFS服务" class="headerlink" title="1.2.22 避免启用NFS服务"></a>1.2.22 避免启用NFS服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>网络文件系统 (NFS) 是 UNIX 环境中最早也是分布最广泛的文件系统之一。它为系统提供了通过网络挂载其他服务器的文件系统的能力。如果系统不导出NFS共享，建议禁用NFS以减少远程攻击面。</p>
<p><strong>规则影响：</strong></p>
<p>禁用NFS会影响到系统上依赖NFS的服务和应用程序，以及现有的NFS挂载点。在禁用NFS之前，应确保了解系统上的使用情况，并考虑是否有替代方法来满足文件共享和数据访问的需求。</p>
<p><strong>检查方法：</strong></p>
<p>检查是否启动了服务，如果命令返回为disable，则表示服务未启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled nfs-server</span></span><br><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装nfs组件的服务器，可以禁用nfs-server服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now disable nfs-server</span></span><br></pre></td></tr></table></figure>


<h3 id="1-2-23-避免启用RPC服务"><a href="#1-2-23-避免启用RPC服务" class="headerlink" title="1.2.23 避免启用RPC服务"></a>1.2.23 避免启用RPC服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>rpcbind服务将远程过程调用(RPC)服务映射到它们侦听的端口。RPC进程在启动时通知rpcbind，注册它们正在侦听的端口以及它们期望服务的RPC程序编号。然后，客户端系统使用特定的RPC程序号联系服务器上的rpcbind。rpcbind服务将客户端重定向到正确的端口号，以便它可以与请求的服务进行通信。</p>
<p>如果系统不需要基于 rpc 的服务，建议禁用 rpcbind 以减少远程攻击面。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查是否启动了服务，如果命令返回为disabled，则表示服务未启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled rpcbind</span></span><br><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装rpcbind组件的服务器，可以禁用rpcbind服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now disable rpcbind</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-24-避免启用DHCP服务"><a href="#1-2-24-避免启用DHCP服务" class="headerlink" title="1.2.24 避免启用DHCP服务"></a>1.2.24 避免启用DHCP服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>动态主机配置协议（DHCP）是一项允许为机器动态分配IP地址的服务。</p>
<p>除非系统专门设置为充当DHCP Server，否则建议禁用该服务以减少潜在的攻击面。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查是否启动了服务，如果命令返回为disabled，则表示服务未启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled dhcpd</span></span><br><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>对于已安装dhcpd组件的服务器，可以禁用dhcpd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now disable dhcpd</span></span><br></pre></td></tr></table></figure>
<h2 id="2-安全访问"><a href="#2-安全访问" class="headerlink" title="2 安全访问"></a>2 安全访问</h2><h2 id="2-1-账户"><a href="#2-1-账户" class="headerlink" title="2.1 账户"></a>2.1 账户</h2><h3 id="2-1-1-禁止无需登录的账号设置登录能力"><a href="#2-1-1-禁止无需登录的账号设置登录能力" class="headerlink" title="2.1.1 禁止无需登录的账号设置登录能力"></a>2.1.1 禁止无需登录的账号设置登录能力</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>通常情况下，Linux系统中存在多个账号，而这些账号并不一定都是需要登录的，例如systemd、dhcp等软件安装时会自带安装一些账号，这些账号只是为了运行相关的服务进程。对于无需进行登录的账号，必须禁止其登录能力。如果允许非登录账号有登录能力，将扩大攻击面，攻击者可以利用这些账号进行bash交互操作，从而攻击系统。</p>
<p>注意，sync、shutdown、halt属于特殊账号，通常情况下不能将shell设置为nologin或false，这几个账号在&#x2F;shadow文件中口令设置为“*”，所以并不能直接登录。</p>
<p>openEuler默认满足无需登录的账号不具备登录能力。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong> </p>
<p>检查的目的是确认是否所有不该登录的账号都被设置了&#x2F;sbin&#x2F;nologin或&#x2F;bin&#x2F;false，或对应的口令被锁定。</p>
<ul>
<li><p>使用如下命令查看&#x2F;etc&#x2F;passwd文件中非登录账号是否都已经被设置正确，命令执行后会列出所有设置了禁止登录的账号，可根据业务场景对这些账号进行比对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | grep &quot;\/sbin\/nologin\|\/bin\/false&quot; | awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用如下命令查看&#x2F;etc&#x2F;passwd文件中所有允许登录的账号，命令执行后会列出所有允许登录的账号，可根据业务场景对这些账号进行比对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | grep -v &quot;\/sbin\/nologin\|\/bin\/false&quot; | awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如下命令执行后会列出所有口令被锁定的账号，可根据业务场景对这些账号进行比对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27; | xargs -I &#x27;&#123;&#125;&#x27; passwd -S &#x27;&#123;&#125;&#x27; | awk &#x27;($2==&quot;L&quot; || $2==&quot;LK&quot;) &#123;print $1&#125;&#x27; </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如下命令执行后会列出所有口令未被锁定的账号，可根据业务场景对这些账号进行比对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | awk -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27; | xargs -I &#x27;&#123;&#125;&#x27; passwd -S &#x27;&#123;&#125;&#x27; | awk &#x27;($2!=&quot;L&quot; &amp;&amp; $2!=&quot;LK&quot;) &#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong> </p>
<p>有两种方法可以锁定和解锁用户账号：</p>
<ul>
<li><p>通过usermod命令修改&#x2F;etc&#x2F;passwd文件，将指定账号的登录shell设置为&#x2F;sbin&#x2F;nologin或&#x2F;bin&#x2F;false，该方法不仅可以防止用户登录，还可以防止使用su命令切换为指定用户账号，优先推荐该方法，操作如下（test为账号名）：</p>
<p>锁定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -s /sbin/nologin test</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -s /bin/false test</span></span><br></pre></td></tr></table></figure>
<p>解锁：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -s /bin/bash test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;shadow文件，在指定账号的第二个字段中添加感叹号“!”或“!!”，锁定口令，可通过如下命令操作（test为账号名，如果账号并未设置口令，则会提示操作失败）：</p>
<p>锁定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -L test</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -l test</span></span><br></pre></td></tr></table></figure>
<p>解锁：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -U test</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -u test</span></span><br></pre></td></tr></table></figure>

<p>使用usermod命令锁定的口令，可以使用passwd命令进行解锁，反之亦然。锁定或解锁后可以通过如下命令检查状态，LK表示口令已经锁定，NP表示口令未设置，PS表示口令已被设置，且未锁定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -S test</span></span><br><span class="line"><span class="built_in">test</span> LK 2022-01-01 0 30 10 35 (Password locked.)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -S test</span></span><br><span class="line"><span class="built_in">test</span> NP 2020-12-03 0 50 10 35 (Empty password.)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -S test</span></span><br><span class="line"><span class="built_in">test</span> PS 2022-01-01 0 30 10 35 (Password <span class="built_in">set</span>, SHA512 crypt.)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-1-2-禁止存在不使用的账号"><a href="#2-1-2-禁止存在不使用的账号" class="headerlink" title="2.1.2 禁止存在不使用的账号"></a>2.1.2 禁止存在不使用的账号</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>如果系统中存在业务无关的账号，容易被攻击者利用该账号进行攻击行为。系统应该只保留业务所必须的账号，其他用于安装部署、调试验证，以及问题定位等的账号都必须被删除。</p>
<p>openEuler默认满足不存在不使用的账号。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>openEuler默认只保留系统运行必须的账号，根据自身业务场景确定是否存在业务无关账号，可以使用如下命令查找系统中所有账号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | awk  -F &quot;:&quot; &#x27;&#123;print $1&#125;&#x27;  </span></span><br></pre></td></tr></table></figure>

<p>按照以下步骤进行查询和判断：</p>
<ul>
<li>在未部署业务的平台上，使用上述命令获取所有账号信息；</li>
<li>在完整部署业务的平台上，使用上述命令获取所有账号信息；</li>
<li>对比两者返回结果，对差异部分进行分析，是否符合业务设计。</li>
</ul>
<p><strong>修复方法：</strong></p>
<p>如果存在业务无关账号，可通过如下步骤进行删除：</p>
<ul>
<li><p>查找所有该账号为属主的文件，并通过rm命令手工删除这些文件，如下（test为账号名，&#x2F;home&#x2F;test目录在删除账号时可通过参数自动删除，xxx表示需要被删除的文件或目录）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -user test</span></span><br><span class="line"><span class="comment"># rm xxx -rf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除账号，包括home目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># userdel -rf test</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-1-3-确保不同账号初始分配不同的组ID"><a href="#2-1-3-确保不同账号初始分配不同的组ID" class="headerlink" title="2.1.3 确保不同账号初始分配不同的组ID"></a>2.1.3 确保不同账号初始分配不同的组ID</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>不同用户账号的初始登录组必须不同，如果某个用户账号需要访问其他组的文件，则需要通过命令明确指定加入该组。在大多数情况下，文件权限设置为640，文件夹设置为750，那么同组用户账号是可以对文件进行访问的，所以如果两个不相干的用户账号被设置为同一个组，存在文件被意外读取甚至篡改的可能。</p>
<p>openEuler默认满足不同账号初始分配不同的组ID。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;passwd文件中各个账号所属的组id是否不同，可执行如下命令，如果没有相同组id，则命令执行后无输出，否则输出组id号以及相同组id的账号数量，如下面例子中输出1003 2，表示有两个账号的用户组id为1003：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | awk -F &quot;:&quot; &#x27;&#123;a[$4]++&#125;END&#123;for(i in a)&#123;if(a[i]!=1 &amp;&amp; i!=0)&#123;print i, a[i]&#125;&#125;&#125;&#x27;</span></span><br><span class="line">1003 2</span><br></pre></td></tr></table></figure>

<p>注意：上面命令中过滤了root用户组，因为sync、shutdown等系统账号都属于root组，属于例外场景，在本规范中不做要求。</p>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>添加新账号时，不使用-g参数指定group，而是让系统直接自动分配新的group组，此处-U参数表示需要创建新用户组，默认可以不加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd test</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd test</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果新账号需要被加入其它组，则可以通过-G参数指定，该命令为test1账号新建一个test1的组，作为test1账号默认登录组，另外会将test1账号加入用户组test：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd -G test test1</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令检查test1同test的默认登录组不同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | grep test</span></span><br><span class="line"><span class="built_in">test</span>:x:1007:1007::/home/test:/bin/bash</span><br><span class="line">test1:x:1008:1008::/home/test1:/bin/bash</span><br></pre></td></tr></table></figure>

<p>通过如下命令可以看到test1账号同时被加入了test组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># id test1</span></span><br><span class="line">uid=1008(test1) gid=1008(test1) <span class="built_in">groups</span>=1008(test1),1007(<span class="built_in">test</span>)</span><br></pre></td></tr></table></figure>

<p>test1账号登录后（或者su切换），可以通过newgrp命令切换到test组，命令执行后当前gid已经变成test组的id了，但这并不会改变&#x2F;etc&#x2F;passwd中的组id：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># su test1</span></span><br><span class="line">$ newgrp <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1008(test1) gid=1007(<span class="built_in">test</span>) <span class="built_in">groups</span>=1007(<span class="built_in">test</span>),1008(test1) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是已有账号，需要加入其他组，则可以通过如下命令操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -a -G root test1</span></span><br></pre></td></tr></table></figure>

<p>执行后，test1账号被加入到root组，查看结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># id test1</span></span><br><span class="line">uid=1008(test1) gid=1008(test1) <span class="built_in">groups</span>=1008(test1),0(root),1007(<span class="built_in">test</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-1-4-禁止存在UID为0的非root账号"><a href="#2-1-4-禁止存在UID为0的非root账号" class="headerlink" title="2.1.4 禁止存在UID为0的非root账号"></a>2.1.4 禁止存在UID为0的非root账号</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>UID为0的账号是linux系统中的超级管理员账号，账号名业界约定俗成为root，系统中不允许存在非root账号的UID等于0。如果将root账号UID改为其他值，而其他账号test的UID改为0，那么就会导致账号test拥有超级管理员权限，主要有以下几个问题：</p>
<ul>
<li>业界通用的安全扫描工具会认为账号test设置了非法UID；</li>
<li>增加管理成本，如果用户在使用test账号时没有意识到是超级管理员，可能因疏忽的缘故导致系统被破坏。</li>
</ul>
<p>openEuler默认满足不存在UID为0的非root账号。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过如下命令检查&#x2F;etc&#x2F;passwd文件中是否存在UID为0的非root账号，如下例子中命令执行后返回test 0，表示test账号的UID是0。如果没有UID为0的非root账号，命令无返回输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | awk -F &quot;:&quot; &#x27;&#123;if($1!=&quot;root&quot; &amp;&amp; $3==0)&#123;print $1, $3&#125;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">test</span> 0</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>直接修改&#x2F;etc&#x2F;passwd对应账号的UID字段，然后重启系统，需要确保修改的UID不能同其他账号重复。</p>
<p>注意：usermod命令可以修改账号UID，但如果被修改的账号UID原先为0，则会报错，因为UID为0的账号会被1号进程使用，所以只能通过手工方式直接修改&#x2F;etc&#x2F;passwd文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -u 2000 test</span></span><br><span class="line">usermod: user <span class="built_in">test</span> is currently used by process 1</span><br></pre></td></tr></table></figure>
<h3 id="2-1-5-确保账号、组及口令文件权限正确"><a href="#2-1-5-确保账号、组及口令文件权限正确" class="headerlink" title="2.1.5 确保账号、组及口令文件权限正确"></a>2.1.5 确保账号、组及口令文件权限正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>Linux操作系统中用户账号、口令、用户组等认证相关信息都记录在&#x2F;etc目录下的配置文件中，这些文件需要设置合理的访问权限，否则容易被攻击者窃取或篡改。</p>
<p>这些文件属主和属组必须为root和root组，对应的访问权限必须为：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>设置值</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;passwd</td>
<td>644（rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shadow</td>
<td>000（———）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;group</td>
<td>644（rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;gshadow</td>
<td>000（———）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;passwd-</td>
<td>644（rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;shadow-</td>
<td>000（———）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;group-</td>
<td>644（rw-r–r–）</td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;gshadow-</td>
<td>000（———）</td>
</tr>
</tbody></table>
<p>如果权限配置比表格中更加严格，则普通用户登录时可能无法读取passwd或group配置文件中的信息。导致登录或者执行操作失败。</p>
<p>如果权限配置比表格中更加宽松，则可能导致配置文件信息被攻击者窃取或篡改。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令进行检查，如果返回信息同上表不符，则表示未满足权限要求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ll /etc/passwd</span></span><br><span class="line">-rw-r--r--. 1 root root 1343 Dec  5 07:37 /etc/passwd</span><br><span class="line"><span class="comment"># ll /etc/shadow</span></span><br><span class="line">----------. 1 root root 786 Dec  5 07:38 /etc/shadow</span><br><span class="line"><span class="comment"># ll /etc/group</span></span><br><span class="line">-rw-r--r--. 1 root root 609 Dec 14 12:59 /etc/group</span><br><span class="line"><span class="comment"># ll /etc/gshadow</span></span><br><span class="line">----------. 1 root root 485 Dec  5 07:37 /etc/gshadow</span><br><span class="line"><span class="comment"># ll /etc/passwd-</span></span><br><span class="line">-rw-r--r--. 1 root root 1295 Dec  5 07:36 /etc/passwd-</span><br><span class="line"><span class="comment"># ll /etc/shadow-</span></span><br><span class="line">----------. 1 root root 681 Dec  5 07:37 /etc/shadow-</span><br><span class="line"><span class="comment"># ll /etc/group-</span></span><br><span class="line">-rw-r--r--. 1 root root 609 Dec  5 07:37 /etc/group-</span><br><span class="line"><span class="comment"># ll /etc/gshadow-</span></span><br><span class="line">----------. 1 root root 474 Dec  5 07:36 /etc/gshadow-</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果文件权限不符合规范要求，可以通过chown和chmod命令进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown root:root &lt;passwd/group/shadow config file&gt;</span></span><br><span class="line"><span class="comment"># chmod &lt;access permissions&gt; &lt;passwd/group/shadow config file&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-6-确保账号拥有自己的Home目录"><a href="#2-1-6-确保账号拥有自己的Home目录" class="headerlink" title="2.1.6 确保账号拥有自己的Home目录"></a>2.1.6 确保账号拥有自己的Home目录</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>每个用户账号必须有自己的Home目录，用来存放账号相关的数据，该目录的属主必须是用户自身。如果Home目录属主不是自身，那么可能无法对该目录进行读写，或者该目录下保存的用户数据可以被其他用户（如属主）读取或篡改。如果没有Home目录，则用户账号登录后将无法获取到自身的环境配置数据。</p>
<p>openEuler默认满足每个账户拥有自己的Home目录。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下脚本进行检查，如果无返回输出，则表示所有用户账号均有Home目录，目录属主正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"> </span><br><span class="line">grep -E -v <span class="string">&#x27;^(halt|sync|shutdown)&#x27;</span> <span class="string">&quot;/etc/passwd&quot;</span> | awk -F <span class="string">&quot;:&quot;</span> <span class="string">&#x27;($7 != &quot;/bin/false&quot; &amp;&amp; $7 != &quot;/sbin/nologin&quot; &amp;&amp; $7 != &quot;/usr/sbin/nologin&quot;) &#123;print $1 &quot; &quot; $6&#125;&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> name home;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$home</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;No home folder \&quot;<span class="variable">$home</span>\&quot; of \&quot;<span class="variable">$name</span>\&quot;.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            owner=`<span class="built_in">ls</span> -l -d <span class="variable">$home</span> | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>`</span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$owner</span>&quot;</span> != <span class="string">&quot;<span class="variable">$name</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;\&quot;<span class="variable">$home</span>\&quot; is owned by <span class="variable">$owner</span>, not \&quot;<span class="variable">$name</span>\&quot;.&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>删除相应的用户账号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># userdel -r test</span></span><br><span class="line">userdel: <span class="built_in">test</span> home directory (/home/test) not found</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用useradd命令添加用户账号（同时自动创建Home目录）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd test</span></span><br><span class="line"><span class="comment"># ll -d /home/test/</span></span><br><span class="line">drwx------. 2 <span class="built_in">test</span> <span class="built_in">test</span> 4096 Feb  2 13:19 /home/test/</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-1-7-确保-etc-passwd中的组都存在"><a href="#2-1-7-确保-etc-passwd中的组都存在" class="headerlink" title="2.1.7 确保&#x2F;etc&#x2F;passwd中的组都存在"></a>2.1.7 确保&#x2F;etc&#x2F;passwd中的组都存在</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>要求在&#x2F;etc&#x2F;passwd中涉及到的用户组，都必须在&#x2F;etc&#x2F;group文件中真实存在。如果管理员通过手工方式修改这两个文件，则可能因为人为错误而导致用户组不正确。如果&#x2F;etc&#x2F;passwd中的用户组在&#x2F;etc&#x2F;group中不存在，那么将导致用户组权限管理风险。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下脚本进行检查，如果无返回输出，则表示所有用户组设置正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">  </span><br><span class="line">grep -E -v <span class="string">&#x27;^(halt|sync|shutdown)&#x27;</span> <span class="string">&quot;/etc/passwd&quot;</span> | awk -F <span class="string">&quot;:&quot;</span> <span class="string">&#x27;($7 != &quot;/bin/false&quot; &amp;&amp; $7 != &quot;/sbin/nologin&quot;) &#123;print $4&#125;&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> group;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    grep -q -P <span class="string">&quot;^.*?:[^:]*:<span class="variable">$group</span>:&quot;</span> <span class="string">&quot;/etc/group&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Group <span class="variable">$group</span> not found&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>分析两个文件不匹配的原因，可以有两种修复方式：</p>
<ul>
<li><p>通过删除账号，重新添加的方式进行修复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># userdel -r test</span></span><br><span class="line"><span class="comment"># useradd test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过删除或添加组的方式进行修复（其中xxx表示gid的值）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># groupdel testgroup</span></span><br><span class="line"><span class="comment"># groupadd -g xxx testgroup</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-1-8-确保UID唯一"><a href="#2-1-8-确保UID唯一" class="headerlink" title="2.1.8 确保UID唯一"></a>2.1.8 确保UID唯一</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>要求在&#x2F;etc&#x2F;passwd中涉及到的用户账号UID唯一。Linux系统中根据UID来判断账号权限，如果多个账号使用同一个UID，则会导致这些账号拥有一样的权限，可以相互访问Home目录，以及各自创建的文件，导致越权以及信息泄露。</p>
<p>通常情况下使用useradd等命令添加用户账号，不会存在UID重复问题，但如果管理员操作失误，直接修改&#x2F;etc&#x2F;passwd文件，则可能导致问题。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令进行检查，如果无返回输出，则表示所有UID设置正确，且唯一，否则列出UID和对应的复用次数，如3003这个UID被两个账号使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | awk -F &quot;:&quot; &#x27;&#123;a[$3]++&#125;END&#123;for(i in a)&#123;if(a[i]!=1)&#123;print i, a[i]&#125;&#125;&#125;&#x27;</span></span><br><span class="line">3003 2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>分析UID被重复使用的原因，然后删除出现问题的账号，并重新添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># userdel -r test</span></span><br><span class="line"><span class="comment"># useradd test</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-9-确保账号名唯一"><a href="#2-1-9-确保账号名唯一" class="headerlink" title="2.1.9 确保账号名唯一"></a>2.1.9 确保账号名唯一</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>要求在&#x2F;etc&#x2F;passwd中涉及到的账号名唯一。如果&#x2F;etc&#x2F;passwd中的账号名重复，则实际只有&#x2F;etc&#x2F;passwd文件中第一个该账号的UID有效。</p>
<p>通常情况下使用useradd等命令添加用户账号，不会存在账号名重复问题，但如果管理员操作失误，直接修改&#x2F;etc&#x2F;passwd文件，则可能导致问题。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令进行检查，如果无返回输出，则表示所有账号名唯一，否则列出账号名和对应的复用次数，如test这个账号存在重复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/passwd | awk -F &quot;:&quot; &#x27;&#123;a[$1]++&#125;END&#123;for(i in a)&#123;if(a[i]!=1)&#123;print i, a[i]&#125;&#125;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">test</span> 2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>分析账号名被重复使用的原因，然后手工删除&#x2F;etc&#x2F;passwd文件中出现问题的账号，并按需确定是否使用useradd命令重新添加正确的账号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd test</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-10-确保GID唯一"><a href="#2-1-10-确保GID唯一" class="headerlink" title="2.1.10 确保GID唯一"></a>2.1.10 确保GID唯一</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>要求在&#x2F;etc&#x2F;group中涉及到的用户组GID唯一。Linux系统中根据GID来判断用户组权限，如果多个用户组使用同一个GID，则会导致这些用户组拥有一样的权限，可以相互访问拥有组权限的目录，导致越权以及信息泄露。</p>
<p>通常情况下使用useradd&#x2F;groupadd等命令添加用户账号&#x2F;用户组，不会存在GID重复问题，但如果管理员操作失误，直接修改&#x2F;etc&#x2F;group文件，则可能导致问题。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令进行检查，如果无返回输出，则表示所有GID唯一，否则列出GID和对应的复用次数，如3003这个GID被两个用户组使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/group | awk -F &quot;:&quot; &#x27;&#123;a[$3]++&#125;END&#123;for(i in a)&#123;if(a[i]!=1)&#123;print i, a[i]&#125;&#125;&#125;&#x27;</span></span><br><span class="line">3003 2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>分析GID被重复使用的原因，然后删除出现问题的用户组（注意，修复时需按照实际场景，先删除属于该用户组的用户账号）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># groupdel test1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-11-确保组名唯一"><a href="#2-1-11-确保组名唯一" class="headerlink" title="2.1.11 确保组名唯一"></a>2.1.11 确保组名唯一</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>要求在&#x2F;etc&#x2F;group中涉及到的用户组名唯一。如果&#x2F;etc&#x2F;group中的用户组名重复，则实际只有&#x2F;etc&#x2F;group文件中第一个该用户组的GID有效。</p>
<p>通常情况下使用useradd&#x2F;groupadd等命令添加用户账号&#x2F;用户组，不会存在用户组名重复问题，但如果管理员操作失误，直接修改&#x2F;etc&#x2F;group文件，则可能导致问题。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令进行检查，如果无返回输出，则表示所有用户组名唯一，否则列出组名和对应的复用次数，如test这个组名存在重复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/group | awk -F &quot;:&quot; &#x27;&#123;a[$1]++&#125;END&#123;for(i in a)&#123;if(a[i]!=1)&#123;print i, a[i]&#125;&#125;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">test</span> 2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>分析用户组名被重复使用的原因，然后手工删除&#x2F;etc&#x2F;group文件中出现问题的用户组，并按需确定是否使用groupadd命令重新添加正确的组名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># groupadd test</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-12-应当正确设置账号有效期"><a href="#2-1-12-应当正确设置账号有效期" class="headerlink" title="2.1.12 应当正确设置账号有效期"></a>2.1.12 应当正确设置账号有效期</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>账号应该根据自身的应用场景进行生命周期管理，例如临时创建的管理、维护账号；定期业务所需要的账号，业务生命周期结束，账号生命周期也结束了。对于这类账号，应该在生命周期结束时就直接删除，但由于管理原因，往往容易遗忘，所以建议管理员在创建账号的过程中，同时设定账号的过期时间。（注：系统账号可根据业务实际情况设置，系统账号通常用于系统服务及程序运行，不具备登录条件，不需要关注有效期。）</p>
<p>如果账号已经不再需要，但并没有被删除，也没有被禁用，那么由于该账号相关管理疏漏，有可能导致口令泄露或者账号被非法使用。例如原本用于日志维护的临时账号应该在1个月后过期，但到期后并没有被禁用，那么相应的管理人员在后续的时间内，依旧可以使用该账号登录系统，导致安全风险。</p>
<p><strong>规则影响：</strong></p>
<p>过期账号无法正常登陆。</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;shadow文件中除默认账号及无法登陆的账号外，所有的账号的第8个字段是否有值，这个值是从1970年1月1日开始计算的天数累加值，例如这个值如果是1，表示账号有效期到1970年1月2日24点过期。</p>
<p>可以通过如下命令检查，如果设置了过期时间，则直接返回该值，否则无返回数据（test为需要检查的账号）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/shadow | grep &quot;test&quot; | awk -F &quot;:&quot; &#x27;&#123;if($8!=&quot;&quot;)&#123;print $8&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过usermod命令设置账号的过期时间，如（test为需要被设置的账号，yyyy-mm-dd为过期时间）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># usermod -e yyyy-mm-dd test</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-13-避免Home目录下存在-forward文件"><a href="#2-1-13-避免Home目录下存在-forward文件" class="headerlink" title="2.1.13 避免Home目录下存在.forward文件"></a>2.1.13 避免Home目录下存在.forward文件</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>“.forward”文件可以配置一个email地址，当用户收到邮件时，会自动转发到该地址。如无相关邮件转发场景，建议删除“.forward”文件。如果存在“.forward”文件，可能导致携带有敏感信息的用户邮件被自动转发到高风险的邮箱。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下脚本进行检查，如果无返回输出，则表示所有Home目录下无“.forward”文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">  </span><br><span class="line">grep -E -v <span class="string">&#x27;^(halt|sync|shutdown)&#x27;</span> <span class="string">&quot;/etc/passwd&quot;</span> | awk -F <span class="string">&quot;:&quot;</span> <span class="string">&#x27;($7 != &quot;/bin/false&quot; &amp;&amp; $7 != &quot;/sbin/nologin&quot;) &#123;print $6&#125;&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> home;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$home</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        find <span class="variable">$home</span> -name <span class="string">&quot;.forward&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用rm命令将检查方法找到“.forward”文件删除。</p>
<h3 id="2-1-14-避免Home目录下存在-netrc文件"><a href="#2-1-14-避免Home目录下存在-netrc文件" class="headerlink" title="2.1.14 避免Home目录下存在.netrc文件"></a>2.1.14 避免Home目录下存在.netrc文件</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>“.netrc”文件保存用于登录远端ftp服务器的口令，如无相关ftp场景，建议删除“.netrc”文件。“.netrc”文件中存储的口令是明文的，容易被攻击者窃取，从而导致ftp服务器敏感数据泄露，甚至服务器遭受攻击。</p>
<p><strong>规则影响：</strong></p>
<p>ftp服务器自动登录受限制</p>
<p><strong>检查方法：</strong></p>
<p>使用如下脚本进行检查，如果无返回输出，则表示所有Home目录下无“.netrc”文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">grep -E -v <span class="string">&#x27;^(halt|sync|shutdown)&#x27;</span> <span class="string">&quot;/etc/passwd&quot;</span> | awk -F <span class="string">&quot;:&quot;</span> <span class="string">&#x27;($7 != &quot;/bin/false&quot; &amp;&amp; $7 != &quot;/sbin/nologin&quot;) &#123;print $6&#125;&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> home;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$home</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        find <span class="variable">$home</span> -name <span class="string">&quot;.netrc&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用rm命令将检查方法找到“.netrc”文件删除。</p>
<h2 id="2-2-口令"><a href="#2-2-口令" class="headerlink" title="2.2 口令"></a>2.2 口令</h2><h3 id="2-2-1-确保口令复杂度设置正确"><a href="#2-2-1-确保口令复杂度设置正确" class="headerlink" title="2.2.1 确保口令复杂度设置正确"></a>2.2.1 确保口令复杂度设置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>口令设置过于简单，容易被猜测，太短的口令、纯数字或纯字母的口令容易被暴力破解工具猜测出来。在系统设置口令时，应强制用户使用复杂口令。对于高安全要求的业务场景，可参考业界最佳实践，比如：口令长度设置为14位或更长，对于四种字符组合，建议每种字符至少出现一次，保证口令不会被轻易破解。</p>
<p>openEuler要求设置口令复杂度如下：</p>
<ul>
<li>口令长度至少8个字符。</li>
<li>口令必须包含如下至少3种字符的组合：<ul>
<li>至少一个小写字母。</li>
<li>至少一个大写字母。</li>
<li>至少一个数字。</li>
<li>至少一个特殊字符：&#96;~!@#$%^&amp;*()-_&#x3D;+|[{}];:’”,&lt;.&gt;&#x2F;?和空格。</li>
</ul>
</li>
</ul>
<p>考虑到在不同场景下的易用性，openEuler默认不配置enforce_for_root和retry值，请根据实际场景按需配置。</p>
<p><strong>规则影响：</strong></p>
<p>口令规则太过复杂，又会影响系统的易用性，给用户的正常使用造成不便。所以可以根据实际需求和使用场景，设计符合安全要求的口令复杂度。</p>
<p><strong>检查方法：</strong></p>
<p>方法1：</p>
<ul>
<li><p>&#x2F;etc&#x2F;pam.d&#x2F;system-auth和&#x2F;etc&#x2F;pam.d&#x2F;password-auth分别提供该功能项的配置，不同应用程序或者服务对应的配置项，需根据各自include的配置文件而定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep system-auth /etc/pam.d/ -r</span></span><br><span class="line">/etc/pam.d/login:auth       substack     system-auth</span><br><span class="line">/etc/pam.d/login:account    include      system-auth</span><br><span class="line">/etc/pam.d/login:password   include      system-auth</span><br><span class="line">/etc/pam.d/login:session    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:auth       include      system-auth</span><br><span class="line">/etc/pam.d/sudo:account    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:password   include      system-auth</span><br><span class="line">/etc/pam.d/sudo:session    include      system-auth-su</span><br></pre></td></tr></table></figure>

<p>以上只列举部分显示结果，从以上结果可知，login和sudo的账号认证采用&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中的配置。</p>
<p>后续以&#x2F;etc&#x2F;pam.d&#x2F;system-auth为例进行说明。</p>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中检查“设置口令复杂度”的配置情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep pam_pwquality /etc/pam.d/system-auth</span></span><br><span class="line">password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>方法2：</p>
<ul>
<li><p>在&#x2F;etc&#x2F;security&#x2F;pwquality.conf文件中检查“设置口令复杂度”的配置情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat /etc/security/pwquality.conf</span></span><br><span class="line">minlen=8</span><br><span class="line">minclass=3</span><br><span class="line">retry=3</span><br><span class="line">dcredit=0</span><br><span class="line">ucredit=0</span><br><span class="line">lcredit=0</span><br><span class="line">ocredit=0</span><br><span class="line">enforce_for_root</span><br></pre></td></tr></table></figure>
<p>此处仅列举本规范关注的配置项。</p>
</li>
</ul>
<p><strong>修复方法：</strong></p>
<p>方法1：</p>
<ul>
<li>口令复杂度的设置可以通过修改&#x2F;etc&#x2F;pam.d&#x2F;password-auth和&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件实现。以&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件为例，具体配置字段如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/system-auth</span></span><br><span class="line">password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>方法2：</p>
<ul>
<li>在&#x2F;etc&#x2F;security&#x2F;pwquality.conf文件中配置如下字段：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/security/pwquality.conf</span></span><br><span class="line">minlen=8</span><br><span class="line">minclass=3</span><br><span class="line">retry=3</span><br><span class="line">dcredit=0</span><br><span class="line">ucredit=0</span><br><span class="line">lcredit=0</span><br><span class="line">ocredit=0</span><br><span class="line">enforce_for_root</span><br></pre></td></tr></table></figure></li>
</ul>
<p>pam_pwquality.so配置项参数字段说明如下表：</p>
<table>
<thead>
<tr>
<th><strong>配置项</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>minlen&#x3D;8</td>
<td>口令长度至少包含8个字符。 说明： 建议配置更长的口令最小长度。</td>
</tr>
<tr>
<td>minclass&#x3D;3</td>
<td>口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种</td>
</tr>
<tr>
<td>ucredit&#x3D;0</td>
<td>口令包含任意个大写字母</td>
</tr>
<tr>
<td>lcredit&#x3D;0</td>
<td>口令包含任意个小写字母</td>
</tr>
<tr>
<td>dcredit&#x3D;0</td>
<td>口令包含任意个数字</td>
</tr>
<tr>
<td>ocredit&#x3D;0</td>
<td>口令包含任意个特殊字符</td>
</tr>
<tr>
<td>retry&#x3D;3</td>
<td>每次修改最多可以尝试3次</td>
</tr>
<tr>
<td>enforce_for_root</td>
<td>本设置对root账号同样有效</td>
</tr>
</tbody></table>
<h3 id="2-2-2-禁止使用历史口令"><a href="#2-2-2-禁止使用历史口令" class="headerlink" title="2.2.2 禁止使用历史口令"></a>2.2.2 禁止使用历史口令</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>频繁使用相同的历史口令容易造成口令泄露而被攻击者攻击。为了用户账号的安全，需要配置“禁用历史口令”功能。根据业务实际场景，合理的设置禁用历史口令次数，但不得小于5次。</p>
<p>考虑到社区版本在不同场景下的易用性，openEuler发行版默认不配置禁用历史口令，请根据实际场景按需配置。</p>
<p><strong>规则影响：</strong></p>
<p>禁止历史口令次数设置过大，易增加口令管理成本。</p>
<p><strong>检查方法：</strong></p>
<p>&#x2F;etc&#x2F;pam.d&#x2F;system-auth和&#x2F;etc&#x2F;pam.d&#x2F;password-auth都各自提供该功能项的配置，不同应用程序或者服务对应的配置项，需根据各自include的配置文件而定。</p>
<ul>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中检查“禁用历史口令”的配置情况，检查配置remember值是否不小于5：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep pam_pwhistory /etc/pam.d/system-auth</span></span><br><span class="line">password    required      pam_pwhistory.so use_authtok remember=5 enforce_for_root</span><br></pre></td></tr></table></figure>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;password-auth文件中检查“禁用历史口令”的配置情况，检查配置remember值是否不小于5：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep pam_pwhistory /etc/pam.d/password-auth</span></span><br><span class="line">password    required      pam_pwhistory.so use_authtok remember=5 enforce_for_root</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>“禁用历史口令”的设置可以通过修改&#x2F;etc&#x2F;pam.d&#x2F;password-auth和&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件实现。</p>
<ul>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件配置如下字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/system-auth</span></span><br><span class="line">password    required      pam_pwhistory.so use_authtok remember=5 enforce_for_root</span><br></pre></td></tr></table></figure>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;password-auth文件配置如下字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/password-auth</span></span><br><span class="line">password    required      pam_pwhistory.so use_authtok remember=5 enforce_for_root</span><br></pre></td></tr></table></figure></li>
</ul>
<p>pam_pwhistory.so配置项参数字段说明如下表：</p>
<table>
<thead>
<tr>
<th><strong>配置项</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>remember&#x3D;5</td>
<td>口令不能修改为过去5次使用过的旧口令</td>
</tr>
<tr>
<td>enforce_for_root</td>
<td>本设置对root账号同样有效</td>
</tr>
</tbody></table>
<h3 id="2-2-3-确保用户修改自身口令时需验证旧口令"><a href="#2-2-3-确保用户修改自身口令时需验证旧口令" class="headerlink" title="2.2.3 确保用户修改自身口令时需验证旧口令"></a>2.2.3 确保用户修改自身口令时需验证旧口令</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>为了防止第三方恶意修改其他账户口令，用户修改自身口令时需验证旧口令。</p>
<p>按照业界通用做法，root账号修改自身口令时不需要验证旧口令。root账号可以直接修改&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow文件，在修改自身口令时验证旧口令无实质的安全提升，所以遵循业界通常做法，root账号在修改口令时，无需验证旧口令。而普通账号需要验证通过旧口令后，才能进行新口令的设置，否则会引发安全风险，例如：普通账号的所有者在登录系统后未锁定屏幕，而直接离开座位，附近的攻击者可以在终端上修改该普通账号的口令。</p>
<p>该规则为pam_unix模块默认支持，无需额外配置。</p>
<p><strong>规则影响：</strong></p>
<p>普通用户如果忘记旧口令，则无法自行修改口令，降低易用性。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>root账号更改口令情况如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd</span></span><br><span class="line">Changing password <span class="keyword">for</span> user root.</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通账号（如test）更改口令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">Changing password <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">Changing password <span class="keyword">for</span> <span class="built_in">test</span>.</span><br><span class="line">Current password:</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>该规则为pam_unix模块默认支持，无需配置。</p>
<h3 id="2-2-4-确保口令中不包含账号字符串"><a href="#2-2-4-确保口令中不包含账号字符串" class="headerlink" title="2.2.4 确保口令中不包含账号字符串"></a>2.2.4 确保口令中不包含账号字符串</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>为了用户账号的安全，要求配置“口令中不包含账号字符串”功能。</p>
<p>口令跟账号名字符相同，或者是账号名字符逆序容易被攻击者猜测，而且口令中包含账号名字符，也增加了口令被破译的风险。账号名小于等于3个字符的情况下不作要求，但建议实际场景中设置长度合理的账号名。</p>
<p>账号名大于3个字符时，其口令不能是如下字符：</p>
<ul>
<li>账号名称</li>
<li>账号名称逆序</li>
<li>包含账号名称字符</li>
</ul>
<p><strong>规则影响：</strong></p>
<p>无法设置包含账号字符串的口令。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>&#x2F;etc&#x2F;pam.d&#x2F;system-auth和&#x2F;etc&#x2F;pam.d&#x2F;password-auth分别提供该功能项的配置，不同应用程序或者服务对应的配置项，需根据各自include的配置文件而定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep system-auth /etc/pam.d/ -r</span></span><br><span class="line">/etc/pam.d/login:auth       substack     system-auth</span><br><span class="line">/etc/pam.d/login:account    include      system-auth</span><br><span class="line">/etc/pam.d/login:password   include      system-auth</span><br><span class="line">/etc/pam.d/login:session    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:auth       include      system-auth</span><br><span class="line">/etc/pam.d/sudo:account    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:password   include      system-auth</span><br><span class="line">/etc/pam.d/sudo:session    include      system-auth-su</span><br></pre></td></tr></table></figure>

<p>以上只列举部分显示结果，从以上结果可知，login和sudo的账号认证采用&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中的配置。</p>
<p>后续以&#x2F;etc&#x2F;pam.d&#x2F;system-auth为例进行说明。</p>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中检查“口令中不包含账号字符串”的配置情况，不应包含“usercheck&#x3D;0”字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep pam_pwquality /etc/pam.d/system-auth</span></span><br><span class="line">password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>pam_pwquality.so是一个执行口令质量检测的pam模块，默认支持“口令中不包含账号字符串”该功能。所以，配置文件中包含该模块，且未配置“usercheck&#x3D;0”，即可实现对应的功能；反之，则无法实现。</p>
<p>通过修改&#x2F;etc&#x2F;pam.d&#x2F;password-auth和&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件实现。以&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件为例，如果配置中存在“usercheck&#x3D;0”字段，则删除，具体配置字段如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/system-auth</span></span><br><span class="line">password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0</span><br></pre></td></tr></table></figure>
<h3 id="2-2-5-确保口令使用强Hash算法加密"><a href="#2-2-5-确保口令使用强Hash算法加密" class="headerlink" title="2.2.5 确保口令使用强Hash算法加密"></a>2.2.5 确保口令使用强Hash算法加密</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>出于系统安全考虑，口令不允许明文存储在系统中，应该加密保护。在不需要还原口令的场景，必须使用不可逆算法加密。如果加密算法强度过低，攻击者可以通过加大算力，在口令被更新前，强行计算出相同hash结果的原始字符串，无论该字符串是否同原口令一致，均可用以登录对应账号。目前业界已知的MD5、sha1等弱算法，均可在有限算力情况下碰撞出相同密文的两段不同原文。对用户账号的口令使用强hash算法进行加密，能有效加大口令被碰撞破解的难度，从而降低口令泄漏的风险。可根据实际需求，进行口令加密算法配置，但是配置的算法强度不得低于sha512。</p>
<p>openEuler目前口令加密默认采用sha512算法，已满足安全要求。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>&#x2F;etc&#x2F;pam.d&#x2F;system-auth和&#x2F;etc&#x2F;pam.d&#x2F;password-auth分别提供该功能项的配置，不同应用程序或者服务对应的配置项，需根据各自include的配置文件而定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep system-auth /etc/pam.d/ -r</span></span><br><span class="line">/etc/pam.d/login:auth       substack     system-auth</span><br><span class="line">/etc/pam.d/login:account    include      system-auth</span><br><span class="line">/etc/pam.d/login:password   include      system-auth</span><br><span class="line">/etc/pam.d/login:session    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:auth       include      system-auth</span><br><span class="line">/etc/pam.d/sudo:account    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:password   include      system-auth</span><br><span class="line">/etc/pam.d/sudo:session    include      system-auth-su</span><br></pre></td></tr></table></figure>

<p>以上只列举部分显示结果，从以上结果可知，login和sudo的账号认证采用&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中的配置。</p>
<p>后续以&#x2F;etc&#x2F;pam.d&#x2F;system-auth为例进行说明。</p>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中检查“口令使用强Hash算法加密”的配置情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep sha512 /etc/pam.d/system-auth</span></span><br><span class="line">password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>“口令使用强Hash算法加密”的设置可以通过修改&#x2F;etc&#x2F;pam.d&#x2F;password-auth和&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件实现。</p>
<p>以&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件为例，具体配置字段如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/system-auth</span></span><br><span class="line">password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span><br></pre></td></tr></table></figure>
<h3 id="2-2-6-确保弱口令字典设置正确"><a href="#2-2-6-确保弱口令字典设置正确" class="headerlink" title="2.2.6 确保弱口令字典设置正确"></a>2.2.6 确保弱口令字典设置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>若用户口令是弱口令，就很容易被攻击者猜测到、或者在较短时间内通过字典攻击法进行破解。弱口令字典是一个包含强度不够、容易被猜测到的口令的集合。弱口令包括：系统默认的口令、过去曾被泄露的口令等。OS提供口令字典检查功能，在创建、修改口令的时候检查，如果命中则禁止使用该口令。弱口令字典可更新、可扩展。可根据实际业务场景，设定适合本业务的弱口令字典。</p>
<p>在升级场景中需要注意：历史版本是否启用了弱口令字典检查，或者新版本是否新增了弱口令清单。</p>
<p><strong>规则影响：</strong></p>
<p>原系统中可以使用的口令在新版本中可能被认定为弱口令，导致口令无法设置成功。</p>
<p><strong>检查方法：</strong></p>
<p>方法1：</p>
<ul>
<li><p>&#x2F;etc&#x2F;pam.d&#x2F;system-auth和&#x2F;etc&#x2F;pam.d&#x2F;password-auth分别提供该功能项的配置，不同应用程序或者服务对应的配置项，需根据各自include的配置文件而定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep system-auth /etc/pam.d/ -r</span></span><br><span class="line">/etc/pam.d/login:auth       substack     system-auth</span><br><span class="line">/etc/pam.d/login:account    include      system-auth</span><br><span class="line">/etc/pam.d/login:password   include      system-auth</span><br><span class="line">/etc/pam.d/login:session    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:auth       include      system-auth</span><br><span class="line">/etc/pam.d/sudo:account    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:password   include      system-auth</span><br><span class="line">/etc/pam.d/sudo:session    include      system-auth-su</span><br></pre></td></tr></table></figure>

<p>以上只列举部分显示结果，从以上结果可知，login和sudo的账号认证采用&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中的配置。</p>
<p>后续以&#x2F;etc&#x2F;pam.d&#x2F;system-auth为例进行说明。</p>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中检查“设置弱口令字典”的配置情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep pam_pwquality /etc/pam.d/system-auth</span></span><br><span class="line">password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0</span><br></pre></td></tr></table></figure>
<p>如果没有配置dictcheck&#x3D;0，则默认为开启，无需手动配置。</p>
</li>
<li><p>使用如下命令，导出字典库到文件dictionary.txt中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cracklib-unpacker /usr/share/cracklib/pw_dict &gt; dictionary.txt</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>方法2：</p>
<ul>
<li><p>在&#x2F;etc&#x2F;security&#x2F;pwquality.conf文件中检查“弱口令字典”的配置情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -rnR &quot;dictcheck&quot; /etc/security/pwquality.conf</span></span><br></pre></td></tr></table></figure>
<p>如果没有配置dictcheck&#x3D;0，则默认开启，无需手动配置。</p>
</li>
</ul>
<p><strong>修复方法：</strong></p>
<p>pam_pwquality.so是一个执行口令质量检测的pam模块，默认支持“设置弱口令字典”功能，使用如下操作可以更新弱口令字典库：</p>
<ul>
<li><p>使用如下命令，导出字典库到文件dictionary.txt中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cracklib-unpacker /usr/share/cracklib/pw_dict &gt; dictionary.txt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将弱口令字典导出并修改后，可执行如下命令进行字典库更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create-cracklib-dict dictionary.txt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可在原字典库基础上新增其他字典内容，如custom.txt：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create-cracklib-dict dictionary.txt custom.txt</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-7-确保口令有效期设置正确"><a href="#2-2-7-确保口令有效期设置正确" class="headerlink" title="2.2.7 确保口令有效期设置正确"></a>2.2.7 确保口令有效期设置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>如果口令长期不修改，则通过暴力破解等方法，容易增加口令被破解的可能性，从而影响系统安全；但该值如果设置过小，则导致口令频繁修改，增加管理成本，且容易导致用户因长时间未登录而无法再次登录，所以在设置该值时需要根据实际业务场景进行判断。</p>
<p>口令需要设置有效期，口令过期后用户重新登录时，提示口令过期，并强制修改，否则无法进入系统。口令最大有效期应为90天或者更短；口令过期前7天或更长时间应开始提示用户修改口令；两次修改口令的最小间隔时间建议设置为7天，可根据业务场景调整。</p>
<p>由于root是最高权限账号，如果长期未登录，导致root口令过期，或者因为频繁修改导致遗忘，系统将无法登录，存在管理风险。建议根据实际业务场景决定是否设置root口令过期时间，对于需要频繁登录root账号的场景，建议设置较短的过期时间；对于日常管理使用非root账号的，建议设置相对较长的过期时间。</p>
<p>考虑到社区版本在不同场景下的易用性，openEuler发行版默认不配置口令有效期和两次修改口令的最小间隔时间，请根据实际场景按需配置。</p>
<p><strong>规则影响：</strong></p>
<p>PASS_MAX_DAYS（口令有效期）：设置过长，会降低安全性，增加被暴力破解的概率，设置过短，会增加口令的管理复杂度；</p>
<p>PASS_WARN_AGE（口令过期前提醒）：设置过长，会过早提醒，降低用户体验，设置过短，会导致用户错过修改口令时间；</p>
<p>PASS_MIN_DAYS（两次修改口令的最小间隔时间）：设置过短，用户可以频繁更改口令以规避历史口令防重用检查机制；</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>检查&#x2F;etc&#x2F;login.defs文件中是否已经配置相关字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^PASS_MAX_DAYS /etc/login.defs </span></span><br><span class="line">PASS_MAX_DAYS 90</span><br><span class="line"><span class="comment"># grep ^PASS_WARN_AGE /etc/login.defs </span></span><br><span class="line">PASS_WARN_AGE 7</span><br><span class="line"><span class="comment"># grep ^PASS_MIN_DAYS /etc/login.defs</span></span><br><span class="line">PASS_MIN_DAYS 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查&#x2F;etc&#x2F;shadow文件中指定账号的配置是否正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^test: /etc/shadow </span></span><br><span class="line"><span class="built_in">test</span>:!:18599:0:90:7:35::  </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>有两种设置方法：</p>
<ul>
<li><p>修改&#x2F;etc&#x2F;login.defs文件中的默认配置，对后续新建账号口令默认生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/login.defs</span></span><br><span class="line">PASS_MAX_DAYS 90</span><br><span class="line">PASS_MIN_DAYS 0</span><br><span class="line">PASS_WARN_AGE 7</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改shadow文件中具体某个账号的口令有效期，新增的账号，口令的默认有效期同&#x2F;etc&#x2F;login.defs文件中定义一致，对应的值会写到shadow文件中，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># useradd test</span></span><br><span class="line"><span class="comment"># cat /etc/shadow | grep test</span></span><br><span class="line"><span class="built_in">test</span>:!:18599:0:90:7:35::</span><br></pre></td></tr></table></figure>

<p>shadow文件中每一行记录一个账号的口令信息，通过冒号“:”划分为9个字段，如上举例中：</p>
<ul>
<li>第4字段表示两次修改口令的最小间隔时间，默认为0，表示不作限制；</li>
<li>第5字段表示口令最大有效期（自设置之日起），默认90天，设置成99999表示永不过期；</li>
<li>第6字段表示口令过期前几天开始提醒，默认7天；</li>
<li>第7个字段表示口令修改有效期，过期后几天内允许用户修改。时间段内，用户登录时强制要求修改口令；超过这个时间，直接拒绝用户登录，默认值是35天。</li>
</ul>
<p>管理员可通过passwd命令进行修改。</p>
<p>设置两次口令修改最小间隔时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -n 0 test</span></span><br><span class="line">Adjusting aging data <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">passwd: Success</span><br></pre></td></tr></table></figure>

<p>设置口令最大有效期：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -x 90 test</span></span><br><span class="line">Adjusting aging data <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">passwd: Success</span><br></pre></td></tr></table></figure>

<p>设置口令过期前提醒时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -w 7 test</span></span><br><span class="line">Adjusting aging data <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">passwd: Success</span><br></pre></td></tr></table></figure>

<p>设置口令修改有效期（无法通过&#x2F;etc&#x2F;login.defs设置默认值）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -i 35 test</span></span><br><span class="line">Adjusting aging data <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">passwd: Success </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-8-禁止空口令登录"><a href="#2-2-8-禁止空口令登录" class="headerlink" title="2.2.8 禁止空口令登录"></a>2.2.8 禁止空口令登录</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>空口令登录是指在用户账号登录时，不输入口令的情况下也能成功登录系统。</p>
<p>若允许空口令登录，会增加空口令账号本身被攻击或被用来作为攻击账号的风险。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;ssh&#x2F;sshd_config中是否配置了禁止空口令登录的字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^PermitEmptyPasswords /etc/ssh/sshd_config | grep no</span></span><br><span class="line">PermitEmptyPasswords no</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;ssh&#x2F;sshd_config中配置禁止空口令登录，并重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-9-确保Grub已设置口令保护"><a href="#2-2-9-确保Grub已设置口令保护" class="headerlink" title="2.2.9 确保Grub已设置口令保护"></a>2.2.9 确保Grub已设置口令保护</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>Grub是Linux的默认引导程序，通过引导程序可以设置系统的启动模式，而设置Grub口令可以防御攻击者通过修改Grub设置进入单用户模式。</p>
<p>如果没有设置Grub口令，攻击者可以轻易进入Grub编辑菜单，通过修改启动参数进行攻击行为，例如：进入单用户模式修改root口令，窃取数据。</p>
<p>UEFI和legacy是两种不同的引导方式，对应的Grub配置文件路径会存在差异。UEFI的配置路径为：&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;openEuler，legecy的配置路径为&#x2F;boot&#x2F;grub2。</p>
<p><strong>规则影响：</strong></p>
<p>需要验证Grub口令后才能进入Grub编辑菜单。</p>
<p><strong>检查方法：</strong></p>
<p>UEFI模式下：</p>
<p>方法1：</p>
<ul>
<li><p>查看grub.cfg配置文件是否存在password_pbkdf2相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep password_pbkdf2 /boot/efi/EFI/openEuler/grub.cfg</span></span><br><span class="line">password_pbkdf2 root <span class="variable">$&#123;GRUB2_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>GRUB2_PASSWORD是定义在user.cfg文件中的口令密文，“xxxx”表示密文内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /boot/efi/EFI/openEuler/user.cfg</span></span><br><span class="line">GRUB2_PASSWORD=grub.pbkdf2.sha512.10000.xxxx</span><br></pre></td></tr></table></figure></li>
</ul>
<p>方法2：</p>
<ul>
<li><p>查看grub.cfg配置文件是否存在password_pbkdf2相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep grub.pbkdf2.sha512.10000 /boot/efi/EFI/openEuler/grub.cfg</span></span><br><span class="line">grub.pbkdf2.sha512.10000.xxxx</span><br></pre></td></tr></table></figure></li>
</ul>
<p>legecy模式下：</p>
<p>方法1：</p>
<ul>
<li><p>查看grub.cfg配置文件是否存在password_pbkdf2相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep password_pbkdf2 /boot/grub2/grub.cfg</span></span><br><span class="line">password_pbkdf2 root <span class="variable">$&#123;GRUB2_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>GRUB2_PASSWORD是定义在user.cfg文件中的口令密文，“xxxx”表示密文内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /boot/grub2/user.cfg</span></span><br><span class="line">GRUB2_PASSWORD=grub.pbkdf2.sha512.10000.xxxx</span><br></pre></td></tr></table></figure></li>
</ul>
<p>方法2：</p>
<ul>
<li><p>查看grub.cfg配置文件是否存在password_pbkdf2相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep grub.pbkdf2.sha512.10000 /boot/grub2/grub.cfg</span></span><br><span class="line">grub.pbkdf2.sha512.10000.xxxx</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>openEuler在安装阶段通过人工方式在图形界面设置Grub2口令。</p>
</li>
<li><p>建议用户首次登录时修改口令并定期更新，避免口令泄露后，启动选项被篡改，导致系统启动异常。</p>
<p>在终端输入grub2-mkpasswd-pbkdf2后，根据提示输入明文口令后，生成sha512加密的口令密文，“xxxx”表示密文内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grub2-mkpasswd-pbkdf2</span></span><br><span class="line">Enter password: </span><br><span class="line">Reenter password: </span><br><span class="line">PBKDF2 <span class="built_in">hash</span> of your password is </span><br><span class="line">grub.pbkdf2.sha512.10000.xxxx</span><br></pre></td></tr></table></figure>

<p>UEFI模式下，将新口令密文输出到&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;openEuler&#x2F;user.cfg文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo &quot;GRUB2_PASSWORD=grub.pbkdf2.sha512.10000.xxxx&quot; &gt; /boot/efi/EFI/openEuler/user.cfg</span></span><br></pre></td></tr></table></figure>

<p>legecy模式下，将新口令密文输出到&#x2F;boot&#x2F;grub2&#x2F;user.cfg文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo &quot;GRUB2_PASSWORD=grub.pbkdf2.sha512.10000.xxxx&quot; &gt; /boot/grub2/user.cfg</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>系统下次重启时，如果需要进入Grub2菜单，将需要验证新口令。</p>
</li>
</ul>
<h3 id="2-2-10-确保单用户模式已设置口令保护"><a href="#2-2-10-确保单用户模式已设置口令保护" class="headerlink" title="2.2.10 确保单用户模式已设置口令保护"></a>2.2.10 确保单用户模式已设置口令保护</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>编辑grub启动菜单，在linux启动命令行添加“s”或“single”命令，可以进入单用户模式，单用户模式属于紧急救援模式，可以对系统进行修改。例如修改root口令，所以要求在进入单用户模式时，验证root口令。</p>
<p>openEuler系统默认已经加固，进入单用户模式必须输入root口令。</p>
<p><strong>规则影响：</strong></p>
<p>如果管理员忘记root口令，将无法通过单用户模式进入系统修改。</p>
<p><strong>检查方法：</strong></p>
<p>通过grep命令检查rescue和emergency服务中是否使用systemd-sulogin-shell登录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep /systemd-sulogin-shell /usr/lib/systemd/system/rescue.service</span></span><br><span class="line"><span class="comment"># grep /systemd-sulogin-shell /usr/lib/systemd/system/emergency.service</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rescue.service文件中，修改ExecStart项为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /usr/lib/systemd/system/rescue.service</span></span><br><span class="line">ExecStart=-/usr/lib/systemd/systemd-sulogin-shell rescue</span><br></pre></td></tr></table></figure>
</li>
<li><p>在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;emergency.service文件中，修改ExecStart项为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /usr/lib/systemd/system/emergency.service</span></span><br><span class="line">ExecStart=-/usr/lib/systemd/systemd-sulogin-shell emergency</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-11-确保账号在首次登录时强制修改口令"><a href="#2-2-11-确保账号在首次登录时强制修改口令" class="headerlink" title="2.2.11 确保账号在首次登录时强制修改口令"></a>2.2.11 确保账号在首次登录时强制修改口令</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>对于非用户本人设置的口令，如管理员重置的口令，如果在业务环境上没有被及时修改，极易引起低成本的攻击事件，所以要求用户在首次登录账号时强制修改口令。<br>root口令除外。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;shadow文件中指定账号的配置是否正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^test: /etc/shadow </span></span><br><span class="line"><span class="built_in">test</span>:!:0:0:90:7:35::</span><br></pre></td></tr></table></figure>

<p>此处，以冒号“:”分割的第3个字段，如果是0，表示此账号对应口令已被强制设置为过期。</p>
<p><strong>修复方法：</strong></p>
<p>管理员在重置账号口令后，通过如下命令可以将该口令立即过期，该账号下次登录时会被要求强制口令修改，此种方式过期的口令不受口令修改有效期（默认35天）的约束（test为举例的账号）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd -e test</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-身份认证"><a href="#2-3-身份认证" class="headerlink" title="2.3 身份认证"></a>2.3 身份认证</h2><h3 id="2-3-1-确保登录失败一定次数后锁定账号"><a href="#2-3-1-确保登录失败一定次数后锁定账号" class="headerlink" title="2.3.1 确保登录失败一定次数后锁定账号"></a>2.3.1 确保登录失败一定次数后锁定账号</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>用户使用账号登录系统，如果连续登录失败一定次数后，系统会锁定该账号登录，即一定时间内不允许该账号继续登录，防止恶意的破解系统口令。账号锁定期间，任何输入被判定为无效，锁定时间不因用户的再次输入而重新计时；解锁后，错误输入记录被清空。通过上述设置可以有效防范口令暴力破解，增强系统的安全性。系统默认设定的连续登录失败次数为3次；登录失败后，默认锁定的时间为300s。</p>
<p>考虑到社区版本在不同场景下的易用性，openEuler发行版默认不提供该项安全功能，用户应根据实际应用场景和需求，对默认的失败次数和锁定时间进行配置。</p>
<p><strong>规则影响：</strong></p>
<p>失败次数数值设置过小和锁定时间的数值设置过大，会影响使用体验。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>&#x2F;etc&#x2F;pam.d&#x2F;system-auth和&#x2F;etc&#x2F;pam.d&#x2F;password-auth分别提供该功能项的配置，不同应用程序或者服务对应的配置项，需根据各自include的配置文件而定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep system-auth /etc/pam.d/ -r</span></span><br><span class="line">/etc/pam.d/login:auth       substack     system-auth</span><br><span class="line">/etc/pam.d/login:account    include      system-auth</span><br><span class="line">/etc/pam.d/login:password   include      system-auth</span><br><span class="line">/etc/pam.d/login:session    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:auth       include      system-auth</span><br><span class="line">/etc/pam.d/sudo:account    include      system-auth</span><br><span class="line">/etc/pam.d/sudo:password   include      system-auth</span><br><span class="line">/etc/pam.d/sudo:session    include      system-auth-su</span><br></pre></td></tr></table></figure>

<p>以上只列举部分显示结果，从以上结果可知，login和sudo的账号认证采用&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中的配置。</p>
<p>后续以&#x2F;etc&#x2F;pam.d&#x2F;system-auth为例进行说明。</p>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中检查“连续失败登录次数”的配置情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep deny /etc/pam.d/system-auth</span></span><br><span class="line">auth  required  pam_faillock.so preauth audit deny=3 even_deny_root unlock_time=300</span><br><span class="line">auth  [default=die] pam_faillock.so authfail audit deny=3 even_deny_root unlock_time=300</span><br><span class="line">auth  sufficient  pam_faillock.so authsucc audit deny=3 even_deny_root unlock_time=300</span><br><span class="line">auth      required   pam_deny.so</span><br><span class="line">password  required   pam_deny.so</span><br></pre></td></tr></table></figure>
</li>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中检查“锁定时间”的配置情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep unlock_time /etc/pam.d/system-auth</span></span><br><span class="line">auth  required  pam_faillock.so preauth audit deny=3 even_deny_root unlock_time=300</span><br><span class="line">auth  [default=die] pam_faillock.so authfail audit deny=3 even_deny_root unlock_time=300</span><br><span class="line">auth  sufficient  pam_faillock.so authsucc audit deny=3 even_deny_root unlock_time=300</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>可以通过修改&#x2F;etc&#x2F;pam.d&#x2F;password-auth和&#x2F;etc&#x2F;pam.d&#x2F;system-auth中所有“deny&#x3D;”和“unlock_time&#x3D;”字段后的数，来分别完成对“连续失败登录次数”和“锁定时间”的配置。以&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件为例，具体配置字段如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/system-auth</span></span><br><span class="line">auth  required  pam_faillock.so preauth audit deny=3 even_deny_root unlock_time=300</span><br><span class="line">auth  [default=die] pam_faillock.so authfail audit deny=3 even_deny_root unlock_time=300</span><br><span class="line">auth  sufficient  pam_faillock.so authsucc audit deny=3 even_deny_root unlock_time=300</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-确保会话超时时间设置正确"><a href="#2-3-2-确保会话超时时间设置正确" class="headerlink" title="2.3.2 确保会话超时时间设置正确"></a>2.3.2 确保会话超时时间设置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>设置合理的会话超时时间可以降低因管理员人为原因而导致系统被攻击者攻击的风险。</p>
<p>考虑到社区版本在不同场景下的易用性，openEuler发行版默认不配置会话超时时间，请根据实际场景按需配置。</p>
<p><strong>规则影响：</strong></p>
<p>会话超时时间设置过长，甚至永不超时，当管理员离开时没有退出登录，其他人员就可以直接在终端上以管理员权限进行操作。<br>如果设置过短，则频繁锁定，增加管理员输入口令次数，降低用户体验的同时，也容易引入安全风险，管理员周边人员有较多的机会可以窥探到输入的口令。</p>
<p><strong>检查方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^export TMOUT&quot; /etc/profile</span></span><br><span class="line"><span class="built_in">export</span> TMOUT=300</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>修改&#x2F;etc&#x2F;profile文件TMOUT字段，根据业务场景修改为合理的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="built_in">export</span> TMOUT=&lt;seconds&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用source命令使之生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source /etc/profile    </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-3-确保Warning-Banners包含合理的信息"><a href="#2-3-3-确保Warning-Banners包含合理的信息" class="headerlink" title="2.3.3 确保Warning Banners包含合理的信息"></a>2.3.3 确保Warning Banners包含合理的信息</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>Warning Banners包含有系统登录界面添加的警告信息，为所有登录系统的用户标识出本系统的安全警告，安全警告可以根据业务场景包括系统所属的组织，登录行为所受到的监视或者记录，非授权登录或者入侵会受到的法律制裁等内容。不合适的安全警告信息，可能增加系统被攻击的风险，或触犯当地法律法规。</p>
<p>Warning Banners不应将系统版本、应用服务器类型、功能等暴露给用户，避免攻击者获取到系统信息，实施攻击。除此之外，还需要正确配置文件所有权，否则未经授权的用户可能会使用不正确或误导性信息来修改文件。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>通过cat命令，查看&#x2F;etc&#x2F;motd、&#x2F;etc&#x2F;issue、&#x2F;etc&#x2F;issue.net三个文件中警告信息是否合理，是否存在系统版本、应用服务器类型、功能等信息；</p>
</li>
<li><p>通过ll命令查看&#x2F;etc&#x2F;motd、&#x2F;etc&#x2F;issue、&#x2F;etc&#x2F;issue.net三个文件权限是否为644；</p>
</li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>通过vim命令，修改&#x2F;etc&#x2F;motd、&#x2F;etc&#x2F;issue、&#x2F;etc&#x2F;issue.net三个文件中的告警信息；</p>
</li>
<li><p>通过chmod命令修改&#x2F;etc&#x2F;motd、&#x2F;etc&#x2F;issue、&#x2F;etc&#x2F;issue.net三个文件的权限为644；</p>
</li>
</ul>
<h3 id="2-3-4-应当正确配置Banner路径"><a href="#2-3-4-应当正确配置Banner路径" class="headerlink" title="2.3.4 应当正确配置Banner路径"></a>2.3.4 应当正确配置Banner路径</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>Banner路径指向一个文件，文件中包含有用户登录SSH前在客户端给出的提示信息，用户可根据实际业务场景配置该文件中的内容。</p>
<p>如果不配置，则默认没有显示。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^Banner&quot; /etc/ssh/sshd_config</span></span><br><span class="line">Banner /etc/issue.net</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，配置Banner字段指向的文件，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">Banner /etc/issue.net</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Banner指向文件中的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/issue.net</span></span><br><span class="line">Authorized <span class="built_in">users</span> only. All activities may be monitored and reported.</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-4-访问控制"><a href="#2-4-访问控制" class="headerlink" title="2.4 访问控制"></a>2.4 访问控制</h2><h3 id="2-4-1-限制历史命令记录数量"><a href="#2-4-1-限制历史命令记录数量" class="headerlink" title="2.4.1 限制历史命令记录数量"></a>2.4.1 限制历史命令记录数量</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>HISTSIZE是一个环境变量，用于控制命令历史记录的大小。具体来说，HISTSIZE定义了命令历史记录中可以存储的命令条目数量。通过设置HISTSIZE的值，可以限制或增加命令历史记录的大小，从而控制在命令行终端中可用的以前输入的命令数量。</p>
<p>例如，设置HISTSIZE&#x3D;100将限制命令历史记录最多存储100条命令。一旦命令历史记录达到这个限制，新的命令将会覆盖最旧的命令，以保持历史记录的大小不超过指定的值。</p>
<p>作用：较小的历史记录可以减少敏感信息（如密码）在历史记录中被保留的风险。</p>
<p>建议系统限制查看历史命令的数量，建议50或100</p>
<p><strong>规则影响：</strong></p>
<p>限制的值设置过小，会导致历史使用的命令不可见，易用性下降。</p>
<p><strong>检查方法：</strong></p>
<ol>
<li>查看环境变量 HISTSIZE 设置的值：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo $HISTSIZE</span></span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看 profile 文件 HISTSIZE 设置的值：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -iP &quot;^HISTSIZE&quot; /etc/profile</span></span><br><span class="line">HISTSIZE=100</span><br></pre></td></tr></table></figure>
<p>如果检测1中输出为1-100范围，且检测2中”HISTSIZE&#x3D;”等于号之后输出的值为1-100的范围，说明通过检查，否则检测未通过。</p>
<p><strong>修复方法：</strong></p>
<p>查看profile文件中环境变量HISTSIZE的值，运行以下命令设置历史命令记录数量为1-100范围内的值并生效即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -qiP &quot;^HISTSIZE&quot; /etc/profile &amp;&amp; sed -i &quot;/^HISTSIZE/cHISTSIZE=100&quot; /etc/profile || echo -e &quot;HISTSIZE=100&quot; &gt;&gt; /etc/profile</span></span><br><span class="line"><span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-应当启用enforce模式"><a href="#2-4-2-应当启用enforce模式" class="headerlink" title="2.4.2 应当启用enforce模式"></a>2.4.2 应当启用enforce模式</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SELinux是Linux发行版中内置的安全模块，通过细粒度的访问控制机制，实现应用程序对资源的访问控制，从而提高系统的安全性。SELinux的运行模式有三种：</p>
<ul>
<li><p>enforcing（强制模式）：当访问无权限时，阻止资源访问，并记录audit日志；</p>
</li>
<li><p>permissive（宽容模式）：当访问无权限时，仅记录audit日志，不阻止资源访问；</p>
</li>
<li><p>disable（禁用模式）：关闭SELinux功能；</p>
</li>
</ul>
<p>SELinux只有工作在enforcing模式时才能有效启用并保护系统，若工作在其它模式，则无法对系统提供保护，而系统中的进程会默认有较大的权限（尤其是以root身份运行的进程），可能会给系统带来安全风险。</p>
<p><strong>规则影响：</strong></p>
<p>系统开启enforce模式会拒绝部分高风险操作（依赖于策略配置），易用性降低。</p>
<p><strong>检查方法：</strong></p>
<p>输入命令查看当前系统SELinux运行模式是否为enforcing：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># getenforce</span></span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>

<p>使用如下命令查看系统默认SELinux运行模式是否为enforcing：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^SELINUX=&quot; /etc/selinux/config</span></span><br><span class="line">SELINUX=enforcing</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用setenforce命令设置当前系统SELinux的运行模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setenforce 1</span></span><br><span class="line"><span class="comment"># getenforce</span></span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>

<p>设置&#x2F;etc&#x2F;selinux&#x2F;config文件中的SELINUX参数，重启操作系统后生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=enforcing</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-应当正确配置SELinux策略"><a href="#2-4-3-应当正确配置SELinux策略" class="headerlink" title="2.4.3 应当正确配置SELinux策略"></a>2.4.3 应当正确配置SELinux策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SELinux的策略分为两种，系统基础策略和自定义策略：</p>
<p>基础策略：定义在基础策略包中的策略，包括selinux-policy、selinux-policy-targeted、selinux-policy-mls等。</p>
<p>自定义策略：用户修改或添加的策略。</p>
<p>SELinux可以实现进程级别的强制访问控制，通过根据最小权限原则配置合理的策略，限制系统中关键应用和关键资源的行为，可以提高系统的安全性。</p>
<p>如果未对应用程序配置合理的策略，可能产生两种影响：</p>
<ul>
<li><p>如果未对应用程序配置策略，应用程序有可能运行在unconfined_t或其他权限较大的域，若被攻击可能对系统或业务造成较大影响；</p>
</li>
<li><p>如果为应用程序配置了不合理的策略，有可能影响应用程序的正常运行。</p>
</li>
</ul>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>运行以下命令查看当前系统策略，建议配置为targeted：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sestatus | grep &#x27;Loaded policy name&#x27;</span></span><br><span class="line">Loaded policy name:             targeted</span><br></pre></td></tr></table></figure>

<p>运行以下命令，输出为空，表示无异常规则和异常访问行为，若不为空，需要分析被禁止的访问行为是否为正常访问行为，如果为正常访问行为，则需要修改策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep avc /var/log/audit/audit.log*</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>设置基础策略包为targeted策略包：</p>
<ul>
<li><p>安装目标基础策略包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install selinux-policy-targeted</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置&#x2F;etc&#x2F;selinux&#x2F;config文件中的SELINUXTYPE参数以修改系统基础策略包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SELINUXTYPE=targeted</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在根目录下创建.autorelabel文件，用于系统重启后刷新文件标签：</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># touch /.autorelabel</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启操作系统。</li>
</ul>
<p>若应用程序运行异常，需要为应用程序配置合理的SELinux策略。</p>
<h3 id="2-4-4-确保su受限使用"><a href="#2-4-4-确保su受限使用" class="headerlink" title="2.4.4 确保su受限使用"></a>2.4.4 确保su受限使用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>su命令可以使一个普通用户拥有超级用户或其他用户的权限，它经常被用于从普通用户账号切换到系统root账号。su命令为用户变更身份提供了便捷的途径，但如果不加约束的使用su命令，会给系统带来潜在的风险。通过对用户使用su访问root账号的权限进行限制，仅对部分账号进行su使用授权，可以提高系统账号使用的安全性。</p>
<p>openEuler默认仅允许wheel组中的普通用户具有su的使用权限。</p>
<p><strong>规则影响：</strong></p>
<p>非wheel组用户无法使用su</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;pam.d&#x2F;su中是否配置了非wheel组用户账号禁止使用su：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep pam_wheel.so /etc/pam.d/su | grep required</span></span><br><span class="line">auth	 required	 pam_wheel.so use_uid</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;pam.d&#x2F;su配置文件，配置非wheel组用户账号禁止使用su：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/su</span></span><br><span class="line">auth	 required	 pam_wheel.so use_uid</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-确保普通用户通过sudo运行特权程序"><a href="#2-4-5-确保普通用户通过sudo运行特权程序" class="headerlink" title="2.4.5 确保普通用户通过sudo运行特权程序"></a>2.4.5 确保普通用户通过sudo运行特权程序</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>sudo可以使设定的普通用户以root权限执行某些特定的程序。大部分系统管理命令都需要使用root权限执行，对于系统管理员来说，适当地对其他用户授权可以减轻系统管理员负担，但直接授予普通用户root口令会带来安全风险，使用sudo则可以规避这一问题。系统中需要以root账号运行的特权程序，可以使用sudo机制避免使用root账号登录。 </p>
<p>使用sudo代替root用户运行特权程序不仅可以减轻系统管理员负担，同时由于使用sudo时无需输入root口令，这提高了安全性。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;sudoers中是否配置了普通用户执行sudo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;(root)&quot; /etc/sudoers</span></span><br><span class="line">test_sudo  ALL=(root)  /bin/ping</span><br></pre></td></tr></table></figure>

<p>说明：示例中“&#x2F;bin&#x2F;ping”为可以使用sudo执行的程序。实际上，具体的程序由用户根据业务场景进行配置。</p>
<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;sudoers配置文件，对需要以root执行指定特权的用户配置权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sudoers</span></span><br><span class="line">test_sudo  ALL=(root)  /bin/ping</span><br></pre></td></tr></table></figure>

<p>上一行配置一共包含四个字段，如上举例中：</p>
<p>第一个字段test_sudo为用户账号，实际配置时还可以指定为某一用户组，这样该用户组内的所有用户账号均可按后边的规则执行sudo；</p>
<p>第二个字段ALL意思是在任何主机名下都适用；</p>
<p>第三个字段root表明第一个字段所设定的用户账号或用户组可以切换到root下执行特权程序；</p>
<p>第四个字段中&#x2F;bin&#x2F;ping即为指定的特权程序，多个特权程序用逗号隔开。</p>
<h3 id="2-4-6-确保sudoers不能配置低权限用户可写的脚本"><a href="#2-4-6-确保sudoers不能配置低权限用户可写的脚本" class="headerlink" title="2.4.6 确保sudoers不能配置低权限用户可写的脚本"></a>2.4.6 确保sudoers不能配置低权限用户可写的脚本</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>sudo可以使设定的普通用户以root权限执行某些特定的程序，与之对应的配置文件为&#x2F;etc&#x2F;sudoers。管理员用户可以配置相应的规则使某些脚本或二进制文件以root的权限运行，所以sudo配置的脚本应该只有root可写，不能配置低权限用户可写的脚本，若配置了低权限用户可写的脚本则该用户可以通过修改该脚本实现提权操作。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查sudo配置文件&#x2F;etc&#x2F;sudoers，检查特权程序是否为低权限用户可写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;(root)&quot; /etc/sudoers</span></span><br><span class="line">test_sudo  ALL=(root)  /bin/xxx.sh</span><br><span class="line"><span class="comment"># ll /bin/xxx.sh</span></span><br><span class="line">-rw-------. 1 root root 451 Mar 27 17:00 /bin/xxx.sh</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>例如一个&#x2F;etc&#x2F;sudoers配置文件中的脚本为低权限用户可写，则用户需要根据实际的业务场景进行修复：</p>
<ul>
<li><p>修复方法1</p>
<p>修改&#x2F;etc&#x2F;sudoers配置文件中的脚本的文件权限，去除掉低特权用户的可写权限以防止该用户实现提权操作。</p>
</li>
<li><p>修复方法2</p>
<p>修改&#x2F;etc&#x2F;sudoers配置文件删除低权限用户可配置的脚本文件，防止低权限用户实现提权操作</p>
</li>
</ul>
<h3 id="2-4-7-确保普通用户不能借助pkexec配置提权root"><a href="#2-4-7-确保普通用户不能借助pkexec配置提权root" class="headerlink" title="2.4.7 确保普通用户不能借助pkexec配置提权root"></a>2.4.7 确保普通用户不能借助pkexec配置提权root</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>pkexec命令可以使一个普通用户拥有超级用户或其他用户的权限，当验证通过后便会以超级用户的权限来执行相应的程序。pkexec为用户变更身份提供了便捷的路径，但是如果不加约束的使用pkexec命令，会给系统带来潜在的安全风险。通过对用户使用pkexec访问root账号的权限进行限制，限制了其他账号的使用。可以提高系统账号使用的安全性。</p>
<p>openEuler默认配置使用pkexec需要验证root口令，且仅有root可获得系统管理员权限。</p>
<p><strong>规则影响：</strong></p>
<p>普通用户不能使用pkexec。</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;polkit-1&#x2F;rules.d&#x2F;50-default.rules中是否配置了仅root用户可以使用pkexec：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/polkit-1/rules.d/50-default.rules</span></span><br><span class="line">/* -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*- */</span><br><span class="line"></span><br><span class="line">// DO NOT EDIT THIS FILE, it will be overwritten on update</span><br><span class="line">//</span><br><span class="line">// Default rules <span class="keyword">for</span> polkit</span><br><span class="line">//</span><br><span class="line">// See the polkit(8) man page <span class="keyword">for</span> more information</span><br><span class="line">// about configuring polkit.</span><br><span class="line"></span><br><span class="line">polkit.addAdminRule(<span class="keyword">function</span>(action, subject) &#123;</span><br><span class="line">    <span class="built_in">return</span> [<span class="string">&quot;unix-user:0&quot;</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;polkit-1&#x2F;rules.d&#x2F;50-default.rules配置文件，仅root用户可以使用pkexec：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/polkit-1/rules.d/50-default.rules</span></span><br><span class="line">polkit.addAdminRule(<span class="keyword">function</span>(action, subject) &#123;</span><br><span class="line">    <span class="built_in">return</span> [<span class="string">&quot;unix-user:0&quot;</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-8-确保su命令继承用户环境变量不会引入提权"><a href="#2-4-8-确保su命令继承用户环境变量不会引入提权" class="headerlink" title="2.4.8 确保su命令继承用户环境变量不会引入提权"></a>2.4.8 确保su命令继承用户环境变量不会引入提权</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>su命令可以使一个普通用户拥有超级用户或其他用户的权限，它经常被用于从普通用户账号切换到系统root账号。su命令为用户变更身份提供了便捷的途径，但如果不加约束的使用su命令，会给系统带来潜在的风险，su命令切换用户时不会自动为用户设置PATH。如果通过su切换用户后系统会自动初始化环境变量PATH，则可以有效防范由于继承环境变量PATH而导致的提权问题。</p>
<p>openEuler默认设置su完成后，PATH会自动初始化。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;login.defs中是否配置了自动初始化环境变量PATH，即ALWAYS_SET_PATH&#x3D;yes：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/login.defs | grep ALWAYS_SET_PATH=yes</span></span><br><span class="line">ALWAYS_SET_PATH=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;login.defs配置文件添加如下配置，使切换用户后系统会自动初始化环境变量PATH：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/login.defs</span></span><br><span class="line">ALWAYS_SET_PATH=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-9-避免root用户本地接入系统"><a href="#2-4-9-避免root用户本地接入系统" class="headerlink" title="2.4.9 避免root用户本地接入系统"></a>2.4.9 避免root用户本地接入系统</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>root是Linux系统中的超级特权用户，具有所有Linux系统资源的访问权限。如果允许直接使用root账号登录Linux系统对系统进行操作，会带来很多潜在的安全风险，为了规避由此带来的风险，应禁止直接使用root帐号登录操作系统，仅在必要的情况通过其他技术手段（如：sudo或su）间接的使用root账号。</p>
<p>由于root账号拥有最高权限，直接使用root登录存在如下风险：</p>
<ul>
<li><p>高危误操作可能直接导致服务器瘫痪，例如误删除、修改系统关键文件；</p>
</li>
<li><p>如果有多人需要root权限操作，则root口令将有多人保管，容易导致口令泄露，同时增加了口令维护成本。</p>
</li>
</ul>
<p>openEuler默认不进行配置，如果实际场景中不存在需要使用root账号在本地登录的情况，建议禁用root账号本地登录。</p>
<p><strong>规则影响：</strong></p>
<p>root账号无法本地接入系统。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>检查&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中是否添加了account类型的pam_access.so模块，且该模块必须在sufficient控制行之前加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/pam.d/system-auth</span></span><br><span class="line">account     required      pam_unix.so</span><br><span class="line">account     required      pam_faillock.so</span><br><span class="line">account     sufficient    pam_localuser.so</span><br><span class="line">account     sufficient    pam_succeed_if.so uid &lt; 1000 quiet</span><br></pre></td></tr></table></figure>
</li>
<li><p>并且，检查&#x2F;etc&#x2F;security&#x2F;access.conf文件中是否设置对root用户登录tty1的限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^\-:root&quot; /etc/security/access.conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用串口尝试登录root账号，确认是否拒绝登录。如果拒绝登录，串口打印信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Authorized <span class="built_in">users</span> only. All activities may be monitored and reported.</span><br><span class="line">localhost login: root</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line">Permission denied </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>在&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件中添加了account类型的pam_access.so模块，且该模块必须在sufficient控制行之前加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/pam.d/system-auth</span></span><br><span class="line">…</span><br><span class="line">account     required      pam_unix.so</span><br><span class="line">account     required      pam_faillock.so</span><br><span class="line">account     required      pam_access.so</span><br><span class="line">account     sufficient     pam_localuser.so</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
</li>
<li><p>在&#x2F;etc&#x2F;security&#x2F;access.conf文件中添加对root用户登录tty1的限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/security/access.conf</span></span><br><span class="line">-:root:tty1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-10-避免使用标签为unconfined-service-t的程序"><a href="#2-4-10-避免使用标签为unconfined-service-t的程序" class="headerlink" title="2.4.10 避免使用标签为unconfined_service_t的程序"></a>2.4.10 避免使用标签为unconfined_service_t的程序</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SELinux设置unconfined_service_t标签的目的是使一些未配置SELinux策略的第三方服务进程不受约束地运行。默认情况下，systemd运行标签为bin_t或usr_t（一般位于&#x2F;usr&#x2F;bin、&#x2F;opt等目录下）的第三方应用程序时，产生的进程标签为unconfined_service_t。</p>
<p>与其他高权限标签（如unconfined_t、initrc_t等）的区别是，unconfined_service_t只有极少的域转换规则，这意味着即使进程运行那些已经配置过SELinux策略的应用程序，新进程的标签也依然为unconfined_service_t，进程配置的SELinux策略也不会生效，如果被攻击会对系统造成较大的影响。</p>
<p><strong>规则影响：</strong></p>
<p>标签为unconfined_service_t的程序运行受限制</p>
<p><strong>检查方法：</strong></p>
<p>运行以下命令，若返回值为空，表示当前系统中没有标签为unconfined_service_t的进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -eZ | grep unconfined_service_t</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>为应用程序配置合理的SELinux策略，并添加域转换规则，使其被执行时转换到配置策略的进程标签。</p>
<h2 id="2-5-完整性"><a href="#2-5-完整性" class="headerlink" title="2.5 完整性"></a>2.5 完整性</h2><h3 id="2-5-1-应当启用IMA度量"><a href="#2-5-1-应当启用IMA度量" class="headerlink" title="2.5.1 应当启用IMA度量"></a>2.5.1 应当启用IMA度量</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>IMA（Integrity Measurement Architecture）完整性度量架构是内核提供的完整性保护功能，开启IMA时，可基于用户自定义的策略为系统中的重要文件提供完整性度量，度量结果可被用于本地以及远程完整性证明。</p>
<p>系统未开启IMA度量功能时，无法实时记录关键文件的摘要信息，不能识别对文件内容或属性的篡改。本地证明、远程证明等保护系统完整性的功能依赖于IMA度量提供的摘要值，因此也无法使用，或者完整性保护不全。</p>
<p>IMA全局策略配置与具体环境相关，通常情况下完整性保护只针对于不可变文件（如可执行文件、动态库等），如果策略配置不当，可能导致性能及内存开销过大，建议用户根据自身情况决定是否开启IMA，并配置正确的策略。</p>
<p>注意：由于IMA只是全局完整性保护机制中的度量部分，要完整使用需依赖TPM 2.0及远程证明服务，本规范仅对IMA度量部分进行说明、建议。如果系统未集成TPM 2.0及远程证明服务，则不应启用IMA度量功能。</p>
<p>IMA度量不支持容器环境和虚拟机环境，且要求UEFI启动，不支持Legacy模式。</p>
<p><strong>规则影响：</strong></p>
<ul>
<li>开启IMA度量会导致系统启动时间和文件访问时间有轻微增加。</li>
<li>如果策略配置不当（如对实时变化的日志文件、临时文件等进行度量），可导致度量日志增长过快、占用系统内存过大，且度量日志所占用内存在系统下次重启前不会被释放，进而影响业务正常运行。另外由于被度量文件一直在变化，引发度量值变化，而远程证明基线值无法同步更新，导致远程证明失败，失去完整性保护的意义。</li>
</ul>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>首先确认当前内核启动参数中是否配置了integrity&#x3D;1，如果查不到该参数，则说明IMA没有开启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cmdline | grep integrity=1</span></span><br><span class="line">BOOT_IMAGE=/vmlinuz-&lt;kernel version&gt; root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M quiet  integrity=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认IMA开启后，查看&#x2F;sys&#x2F;kernel&#x2F;security&#x2F;ima&#x2F;runtime_measurement_count文件中存储的度量记录数，如果该值大于1，则表示已配置IMA度量策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/kernel/security/ima/runtime_measurements_count</span></span><br><span class="line">2053</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>在&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;openEuler&#x2F;grub.cfg文件中配置启动参数“integrity&#x3D;1 ima_appraise&#x3D;off evm&#x3D;ignore”（其中后两个参数可不配置），并重启系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /boot/efi/EFI/openEuler/grub.cfg</span></span><br><span class="line">        linuxefi   /vmlinuz-&lt;kernel version&gt; root=/dev/mapper/openeuler-root ro resume=dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M integrity=1 ima_appraise=off evm=ignore</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置度量策略，一共有两种方式：</p>
<p>在&#x2F;etc&#x2F;ima目录下添加策略文件ima-policy，该方式比较灵活，可以在ima-policy文件中自定义各自策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ima/ima-policy</span></span><br><span class="line">&lt;ima policy lines&gt;</span><br></pre></td></tr></table></figure>

<p>在启动参数中配置ima_policy&#x3D;&lt;tcb&#x2F;exec_tcb&gt;，该方式使用系统默认的几种策略（默认策略度量文件范围大，请谨慎使用），并重启系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /boot/efi/EFI/openEuler/grub.cfg</span></span><br><span class="line">        linuxefi   /vmlinuz-&lt;kernel version&gt; root=/dev/mapper/openeuler-root ro resume=dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M integrity=1 ima_policy=tcb</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-2-应当启用aide入侵检测"><a href="#2-5-2-应当启用aide入侵检测" class="headerlink" title="2.5.2 应当启用aide入侵检测"></a>2.5.2 应当启用aide入侵检测</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>aide（advanced intrusion detection environment）是一款入侵检测工具，可以用来检查系统中文件和目录的完整性，识别遭到恶意篡改的文件或目录。其完整性检查的原理是先构造一个基准数据库，该数据库包含文件或目录的一些属性如权限、所属用户等，在进行完整性检查时将当前系统的状态与基准数据库进行对比得出检查结果，最后报告当前系统的文件或目录变更情况，即检查报告。</p>
<p>启用aide入侵检测能有效识别恶意篡改文件或目录的行为，从而提升系统完整性安全。需要检查的文件或目录可以按需配置，灵活性高，用户只需要查询检查报告即可以判断是否存在恶意篡改行为。</p>
<p><strong>规则影响：</strong></p>
<p>需检查的文件越多，检查过程所需时间越长。如果用户启用aide，应根据自身业务场景，合理配置检查策略。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>检查是否安装了aide软件包（如果返回-bash: aide: command not found，表示未安装）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aide --version</span></span><br><span class="line">Aide 0.16</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查&#x2F;etc&#x2F;aide.conf文件中是否已经配置需要监控的文件或目录，举例仅表示默认配置监控目录中的&#x2F;boot目录，用户若自行配置了需要监控的文件或目录，则确认相应的文件或目录已配置即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep boot /etc/aide.conf | grep NORMAL</span></span><br><span class="line">/boot  NORMAL</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查是否存在基准数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /var/lib/aide/aide.db.gz</span></span><br><span class="line">/var/lib/aide/aide.db.gz</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>如果未安装aide，则使用yum或dnf命令安装软件包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install aide</span><br><span class="line">或</span><br><span class="line">dnf install aide</span><br></pre></td></tr></table></figure></li>
<li><p>在配置文件&#x2F;etc&#x2F;aide.conf中配置需要被监控的文件或目录。&#x2F;etc&#x2F;aide.conf中默认已经配置了部分需要监控的目录，包括&#x2F;boot, &#x2F;bin, &#x2F;lib, &#x2F;lib64等重要目录。用户可以根据需要，自行添加需要监控的文件或目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/aide.conf</span></span><br><span class="line">/boot   NORMAL</span><br><span class="line">/bin    NORMAL</span><br><span class="line">/lib    NORMAL</span><br><span class="line">/lib64  NORMAL</span><br><span class="line">&lt;add new folders&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成基准数据库，执行初始化命令后，在&#x2F;var&#x2F;lib&#x2F;aide目录下生成aide.db.new.gz，将其重命名aide.db.gz，即为基准数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aide --init</span></span><br><span class="line"><span class="comment"># mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>入侵检查，执行aide –check; 检查的结果会在屏幕打印，同时会保存到&#x2F;var&#x2F;log&#x2F;aide&#x2F;aide.log日志文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aide --check</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新基准数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aide --update</span></span><br><span class="line"><span class="comment"># mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-6-数据安全"><a href="#2-6-数据安全" class="headerlink" title="2.6 数据安全"></a>2.6 数据安全</h2><h3 id="2-6-1-应当启用haveged服务"><a href="#2-6-1-应当启用haveged服务" class="headerlink" title="2.6.1 应当启用haveged服务"></a>2.6.1 应当启用haveged服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>haveged服务提供了一个易用的、不可预测的随机数生成器，生成的随机数用于补充系统熵池，可解决某些情况下系统熵过低的问题。建议在有加解密或生成密钥需求的场景下（例如使用openssl和gnutls）都开启此服务。</p>
<p>如果haveged服务没有开启，需要生成强伪随机数的进程从&#x2F;dev&#x2F;random取值时，会因为取不到足够的值而陷入等待，直至取到新的随机字节后才返回。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查环境中haveged服务是否处于正常运行状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-active haveged</span></span><br><span class="line">active</span><br></pre></td></tr></table></figure>

<p>如果显示处于active状态，说明haveged服务正在运行，反之如果显示处于inactive状态，说明服务未开启。</p>
<p><strong>修复方法：</strong></p>
<p>开启haveged服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl start haveged</span></span><br></pre></td></tr></table></figure>

<p>如果要将其设置为随系统启动，可以这样配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl enable haveged.service</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-2-应当设置全局加解密策略配置不低于DEFAULT"><a href="#2-6-2-应当设置全局加解密策略配置不低于DEFAULT" class="headerlink" title="2.6.2 应当设置全局加解密策略配置不低于DEFAULT"></a>2.6.2 应当设置全局加解密策略配置不低于DEFAULT</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>系统全局加解密策略用于指定加解密组件允许的算法，通过修改&#x2F;etc&#x2F;crypto-policies&#x2F;config配置文件可以改变预置的安全策略级别，从而改变应用程序可使用的算法集。</p>
<p>openEuler系统默认配置DEFAULT策略，提供LEGACY、DEFAULT、NEXT、FUTURE、FIPS可供选择，建议用户设置不低于DEFAULT的策略级别，即禁止设置LEGACY模式。</p>
<p>LEGACY：LEGACY策略可确保与旧系统的最大兼容性，但是该策略的安全性较低。该策略提供的安全级别至少为64位。<br>DEFAULT：DEFAULT策略是符合当前标准的默认策略。该策略提供的安全级别至少为80位。<br>NEXT：NEXT策略是为即将发布的操作系统准备的策略。该策略提供的安全级别至少为112位（注：DNSSec所需的SHA-1签名和其他仍普遍使用的SHA-1签名除外）。<br>FUTURE：FUTURE策略为安全级别较高的策略，可以抵御近期大多数的攻击方式。该策略提供的安全级别至少为128位。<br>FIPS：FIPS策略是符合FIPS 140-2要求的策略。该策略提供的安全级别至少为112位。</p>
<p><strong>规则影响：</strong></p>
<p>如果全局加解密策略设置过于宽松，将允许使用不安全加解密算法，降低系统整体安全性。</p>
<p>如果全局加解密策略设置过于严格，则可能由于客户端不支持更加安全的加解密算法，而导致存在兼容性问题。</p>
<p>如果业务程序未使用系统加解密模块，而是自行调用第三方加解密算法库进行操作，则不受影响。</p>
<p><strong>检查方法：</strong></p>
<p>检查环境中&#x2F;etc&#x2F;crypto-policies&#x2F;config文件是否未配置LEGACY模式，如果返回信息为空，或者仅返回位于注释信息中的LEGACY字段，表示未配置LEGACY：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/crypto-policies/config | grep &quot;LEGACY&quot;</span></span><br></pre></td></tr></table></figure>

<p>亦可通过如下方式检查当前配置的模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/crypto-policies/config | grep -v &quot;^#&quot;</span></span><br><span class="line">DEFAULT</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;crypto-policies&#x2F;config文件中配置合适的策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/crypto-policies/config</span></span><br><span class="line">DEFAULT</span><br></pre></td></tr></table></figure>
<h2 id="3-运行和服务"><a href="#3-运行和服务" class="headerlink" title="3 运行和服务"></a>3 运行和服务</h2><h2 id="3-1-网络"><a href="#3-1-网络" class="headerlink" title="3.1 网络"></a>3.1 网络</h2><h3 id="3-1-1-避免使用不常见网络服务"><a href="#3-1-1-避免使用不常见网络服务" class="headerlink" title="3.1.1 避免使用不常见网络服务"></a>3.1.1 避免使用不常见网络服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>一些不常见的协议，往往使用场景较少，社区发展较慢，安全问题不易被快速解决，如果未关闭这些并不使用的协议，可能导致攻击者利用协议或代码漏洞进行攻击。</p>
<p>流控制传输协议（SCTP，Stream Control Transmission Protocol）是一种在网络连接两端之间同时传输多个数据流的协议，SCTP提供的服务与UDP和TCP类似。</p>
<p>透明进程间通信（TIPC，Transparent Inter-process Communication）是一种用于进程间通信的网络通信协议，原本是为集群间通信特别设计的。它允许设计人员能够创建可以和其它应用快速可靠通信的应用，无须考虑其它需要通信的应用在集群环境中的位置。</p>
<p>如果业务场景不需要使用SCTP和TIPC等服务，要求从内核中关闭支持，减小攻击场景。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>使用modprobe命令检查sctp，如果输出“install &#x2F;bin&#x2F;true”，表示sctp已经被禁止使用；如果输出“insmod &#x2F;lib&#x2F;modules&#x2F;(kernel version)&#x2F;kernel&#x2F;net&#x2F;sctp&#x2F;sctp.ko”，表示未被禁止，并列出ko所在目录；如果输出“modprobe: FATAL: Module sctp not found in directory &#x2F;lib&#x2F;modules&#x2F;(kernel version)”，表示不存在该ko文件，可不用处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe -n -v sctp</span></span><br><span class="line">install /bin/true </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用modprobe命令检查tipc，如果输出“install &#x2F;bin&#x2F;true”，表示tipc已经被禁止使用；如果输出“insmod &#x2F;lib&#x2F;modules&#x2F;(kernel version)&#x2F;kernel&#x2F;net&#x2F;tipc&#x2F;tipc.ko”，表示未被禁止，并列出ko所在目录，根据平台不同，即使已经禁用tipc，命令执行后也可能会列出tipc的依赖ko，如udp_tunnel.ko和ip6_udp_tunnel.ko，可不用处理；如果输出“modprobe: FATAL: Module tipc not found in directory &#x2F;lib&#x2F;modules&#x2F;(kernel version)”，表示不存在该ko文件，可不用处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe -n -v tipc</span></span><br><span class="line">insmod /lib/modules/(kernel version)/kernel/net/ipv4/udp_tunnel.ko </span><br><span class="line">insmod /lib/modules/(kernel version)/kernel/net/ipv6/ip6_udp_tunnel.ko</span><br><span class="line">install /bin/true</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;modprobe.d&#x2F;目录下，添加一个任意文件名，并以.conf为后缀的配置文件，属主和属组均为root, 权限600，按照如下格式填入内容，即可禁用sctp和tipc协议：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/modprobe.d/test.conf</span></span><br><span class="line">install sctp /bin/true</span><br><span class="line">install tipc /bin/true</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-避免使用无线网络"><a href="#3-1-2-避免使用无线网络" class="headerlink" title="3.1.2 避免使用无线网络"></a>3.1.2 避免使用无线网络</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>如果硬件设备包含WIFI等无线模块，且系统启用了WIFI，则服务器存在通过无线连接网络的可能，如果是不受控的连接，则一方面可能导致网络不稳定，另一方面增加了攻击面。</p>
<p>当不存在使用无线网络的场景，建议用户根据实际情况关闭无线网络功能。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于无线网络的程序运行受限制</p>
<p><strong>检查方法：</strong></p>
<p>通过nmcli命令查看无线网络配置，如果WIFI和WWAN为enabled，表示已启用无线网络，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmcli radio all</span></span><br><span class="line">WIFI-HW  WIFI     WWAN-HW  WWAN    </span><br><span class="line">enabled  enabled  enabled  enabled</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过nmcli命令可永久关闭WIFI和WWAN，即使系统重启也依旧保持关闭状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmcli radio all off</span></span><br><span class="line"><span class="comment"># nmcli radio all</span></span><br><span class="line">WIFI-HW  WIFI     WWAN-HW  WWAN    </span><br><span class="line">enabled  disabled  enabled  disabled</span><br></pre></td></tr></table></figure>
<h2 id="3-2-防火墙"><a href="#3-2-防火墙" class="headerlink" title="3.2 防火墙"></a>3.2 防火墙</h2><h3 id="3-2-1-应当启用firewalld服务"><a href="#3-2-1-应当启用firewalld服务" class="headerlink" title="3.2.1 应当启用firewalld服务"></a>3.2.1 应当启用firewalld服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>防火墙作为一种网络或系统之间强制实行访问控制的机制，是确保网络安全的重要手段。针对不同的需求和应用环境，可以量身定制出不同的防火墙系统。如果系统中没有配置防火墙服务，可能会导致系统被外部攻击、内部数据被窃取或篡改，大量无效流量浪费带宽、访问一些存在安全风险或业务无关的网站导致信息泄露。</p>
<p>对于连接到网络上的Linux系统来说，防火墙是必不可少的防御机制，它只允许合法的网络流量进出系统，而禁止其它任何网络流量，例如只限定允许的IP地址访问其SSH服务。因而，可以定制防火墙配置来满足任何特定需求和任何安全性需求。</p>
<p>openEuler提供firewalld、iptables、nftables三种常用的防火墙服务配置界面，其中firewalld底层实际调用iptables或nftables机制。</p>
<p>openEuler默认且建议启用firewalld服务，并关闭iptables、nftables服务。</p>
<p>三种防火墙服务建议只启用一种，不建议同时启用多种，如果多种防火墙规则设置不正确，可能导致规则冲突、防护混乱。</p>
<p><strong>规则影响：</strong></p>
<p>防火墙配置错误可能起不到防护作用，还有可能会导致正常的业务无法通信。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下命令检查firewalld服务已经启用，并且iptables和nftables服务未被启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service firewalld status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: active (running) since Wed 2021-02-03  00:14:10 CST; 14h ago</span><br><span class="line"><span class="comment"># service iptables status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: inactive (dead)</span><br><span class="line"><span class="comment"># service nftables status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: inactive (dead)</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用如下方法启用firewalld服务，并配置永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service firewalld start</span></span><br><span class="line"><span class="comment"># systemctl enable firewalld</span></span><br></pre></td></tr></table></figure>

<p>使用如下方法关闭iptables和nftables服务，并配置永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables stop</span></span><br><span class="line"><span class="comment"># service nftables stop</span></span><br><span class="line"><span class="comment"># systemctl disable iptables</span></span><br><span class="line"><span class="comment"># systemctl disable nftables</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-应当配置正确的默认区域"><a href="#3-2-2-应当配置正确的默认区域" class="headerlink" title="3.2.2 应当配置正确的默认区域"></a>3.2.2 应当配置正确的默认区域</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>Firewalld服务通过区域（zone）概念，允许将防火墙划分为几个独立的规则区域，不同的接口或源地址可以绑定到不同的区域，实现不同的控制逻辑。一个区域可以配置许多不同的网络接口或源，但反过来，一个接口或源只能绑定到一个区域中，避免报文进出时无法确定执行哪个区域的规则。</p>
<p>如果一个区域在处理接口或源的报文时，发现并没有显式的规则匹配，此时该区域可以决定如何处理该报文，比如接收、拒绝，或者直接交由默认区域处理。</p>
<p>可以根据实际业务场景，配置合适的默认区域，所有未被显式划分到指定区域的接口、源地址、连接等网络资源，都应该被分配到默认区域。</p>
<p>如果默认区域配置不合理，则可能对未绑定到其他区域的网络资源产生非预期的影响。</p>
<p>如果所有网络资源都已经显式的绑定到其他区域，且已经制定详尽的规则，默认区域未配置任何规则，则默认区域将不影响业务。但这不是推荐的做法。</p>
<p>openEuler firewalld服务共提供11种区域类型：Server、Workstation、block、dmz、drop、external、home、internal、public、trusted、work。默认配置为public。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用firewall-cmd命令查询默认区域配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --get-default-zone</span></span><br><span class="line">public</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用firewall-cmd命令配置默认区域：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --set-default-zone=&lt;name of zone&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-应当确保网络接口绑定正确区域"><a href="#3-2-3-应当确保网络接口绑定正确区域" class="headerlink" title="3.2.3 应当确保网络接口绑定正确区域"></a>3.2.3 应当确保网络接口绑定正确区域</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>不同的防火墙区域可以制定不同的过滤策略，如果服务器网络比较复杂，有多个接口，且不同接口承担不同的业务功能，建议将接口配置到不同的区域，并制定不同的防火墙策略，比如外网业务接口不允许SSH访问，而内网管理接口可以开放SSH访问。如果所有接口都配置到一个区域中，防火墙策略不利于对不同接口进行不同配置，增加管理复杂度，降低防火墙安全防护的过滤效率，因配置问题，可能导致不该接收的报文未被拒绝或丢弃。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查各个区域配置的接口情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --get-active-zones</span></span><br><span class="line">public</span><br><span class="line">  interfaces: eth0</span><br><span class="line">work</span><br><span class="line">  interfaces: eth1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用firewall-cmd命令从指定区域移除接口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=work --remove-interface eth1</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>使用firewall-cmd命令往指定区域增加接口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=work --add-interface eth1</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>使用firewall-cmd命令将当前防火墙配置固化到配置文件中，使之永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --runtime-to-permanent</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-避免开启不必要的服务和端口"><a href="#3-2-4-避免开启不必要的服务和端口" class="headerlink" title="3.2.4 避免开启不必要的服务和端口"></a>3.2.4 避免开启不必要的服务和端口</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>在区域中需要精确配置哪些接口、服务、端口等是要开启的，哪些是必须关闭的。正确配置后可以防止不被允许的报文被接收处理，减少服务器暴露的端口，减小攻击面。</p>
<p>如果配置不正确，原本应该被禁止的接口或端口被开放出去，攻击者就可以利用这些接口或端口实施攻击行为，增加服务器和其他网元的风险。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下脚本查看所有active状态的区域，检查区域中接口、服务、端口等配置是否合理（此处public、work两个区域只是举例，配置的接口、服务、端口等需要根据实际部署情况确定）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for zone in $(firewall-cmd --get-active-zones | grep -v &quot;^[[:space:]]&quot;); do firewall-cmd --list-all --zone=$zone; done</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth1</span><br><span class="line">  sources: </span><br><span class="line">  services: ssh mdns dhcpv6-client</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">	</span><br><span class="line">work (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth2</span><br><span class="line">  sources: </span><br><span class="line">  services: ssh mdns dhcpv6-client samba</span><br><span class="line">  ports: 80/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用如下命令，删除指定区域中对应的服务、端口等：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=work --remove-service samba</span></span><br><span class="line">success</span><br><span class="line"><span class="comment"># firewall-cmd --zone=work --remove-port 80/tcp</span></span><br><span class="line">success</span><br><span class="line"><span class="comment"># firewall-cmd --list-all --zone=work</span></span><br><span class="line">work (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth1</span><br><span class="line">  sources: </span><br><span class="line">  services: ssh mdns dhcpv6-client</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<p>使用firewall-cmd命令将当前防火墙配置固化到配置文件中，使之永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --runtime-to-permanent</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<h3 id="3-2-5-应当启用iptables服务"><a href="#3-2-5-应当启用iptables服务" class="headerlink" title="3.2.5 应当启用iptables服务"></a>3.2.5 应当启用iptables服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>Iptables是Linux操作系统提供的一套基于IPv4和IPv6过滤规则链的防火墙管理工具，同时提供防火墙服务。</p>
<p>Iptables服务区分IPv4和IPv6，所以需要分别配置策略和启闭服务。</p>
<p>openEuler默认且建议使用firewalld服务。如果必须使用iptables提供防火墙服务，则必须关闭firewalld和nftables服务。如果未启用任何防火墙服务，则将提高系统被攻击、篡改的可能。</p>
<p>三种防火墙服务建议只启用一种，不建议同时启用多种，如果多种防火墙规则设置不正确，可能导致规则冲突、防护混乱。</p>
<p><strong>规则影响：</strong></p>
<p>如果启用多个防火墙服务，可能导致因为策略配置不一致而造成业务中断。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方式检查iptables服务已经被启用，firewalld和nftables服务未被启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: active (exited) since Wed 2021-02-03 00:14:10 CST; 14h ago</span><br><span class="line"><span class="comment"># service firewalld status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: inactive (dead)</span><br><span class="line"><span class="comment"># service nftables status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: inactive (dead)</span><br></pre></td></tr></table></figure>

<p>检查ip6tables服务是否已经启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ip6tables status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: active (exited) since Wed 2021-02-03 00:14:10 CST; 14h ago</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用如下方法启用iptables服务，并配置永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables start</span></span><br><span class="line"><span class="comment"># systemctl enable iptables</span></span><br></pre></td></tr></table></figure>

<p>使用如下方法启用ip6tables服务，并配置永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ip6tables start</span></span><br><span class="line"><span class="comment"># systemctl enable ip6tables</span></span><br></pre></td></tr></table></figure>

<p>使用如下方法关闭firewalld和nftables服务，并配置永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service firewalld stop</span></span><br><span class="line"><span class="comment"># service nftables stop</span></span><br><span class="line"><span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment"># systemctl disable nftables</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-6-应当正确配置iptables默认拒绝策略"><a href="#3-2-6-应当正确配置iptables默认拒绝策略" class="headerlink" title="3.2.6 应当正确配置iptables默认拒绝策略"></a>3.2.6 应当正确配置iptables默认拒绝策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>通常情况下，iptables策略配置可以分为白名单方式和黑名单方式两种，建议通过白名单方式配置，只要不符合白名单中规则的链接，全部禁止。所以可以先配置对INPUT、OUTPUT、FORWARD链的DROP或REJECT策略，然后针对需要开放的端口和服务配置ACCEPT策略。</p>
<p><strong>规则影响：</strong></p>
<p>通过黑名单方式配置策略，由于未被配置为DROP或REJECT的链接都将被ACCEPT，容易因为遗漏而导致安全风险。</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令检查IPv4的INPUT、OUTPUT、FORWARD链默认是否为拒绝策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -L | grep -E &quot;INPUT|OUTPUT|FORWARD&quot;</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">Chain OUTPUT (policy DROP)</span><br></pre></td></tr></table></figure>

<p>使用如下命令检查IPv6的INPUT、OUTPUT、FORWARD链默认是否为拒绝策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -L | grep -E &quot;INPUT|OUTPUT|FORWARD&quot;</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">Chain OUTPUT (policy DROP)</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用如下命令配置INPUT、OUTPUT、FORWARD链的默认策略为拒绝。需要注意的是，如果通过网络连接进行远程配置操作，那么策略被修改后网络就会断开，需要通过串口进行连接配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -A INPUT -j DROP</span></span><br><span class="line"><span class="comment"># iptables -A OUTPUT -j DROP</span></span><br><span class="line"><span class="comment"># iptables -A FORWARD -j DROP</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables save</span></span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables: [  OK  ]</span><br></pre></td></tr></table></figure>

<p>配置IPv6默认策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -A INPUT -j DROP</span></span><br><span class="line"><span class="comment"># ip6tables -A OUTPUT -j DROP</span></span><br><span class="line"><span class="comment"># ip6tables -A FORWARD -j DROP</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ip6tables save</span></span><br><span class="line">ip6tables: Saving firewall rules to /etc/sysconfig/ip6tables: [  OK  ]</span><br></pre></td></tr></table></figure>
<h3 id="3-2-7-应当正确配置iptables-loopback策略"><a href="#3-2-7-应当正确配置iptables-loopback策略" class="headerlink" title="3.2.7 应当正确配置iptables loopback策略"></a>3.2.7 应当正确配置iptables loopback策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>回环地址是服务器上一个特殊的地址，以127.0.0.0&#x2F;8表示，同网卡无关，主要用于本机进程间通信，不应该从网卡上收到源地址为127.0.0.0&#x2F;8的报文，此类报文应该被丢弃。如果回环地址策略设置不正确，则可能导致本机进程间通信失败，或者从网卡收到欺骗报文。</p>
<p>服务器需要设置策略，允许接收和处理lo接口的回环地址报文，但拒绝从网卡收到的报文。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>查看IPv4的INPUT、OUTPUT链是否已经正确配置回环地址策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -L INPUT -v -n</span></span><br><span class="line">Chain INPUT (policy DROP 389 packets, 125K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 1089 81354 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:22</span><br><span class="line">   10   840 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">    0     0 DROP       all  --  *      *       127.0.0.0/8          0.0.0.0/0</span><br><span class="line"><span class="comment"># iptables -L OUTPUT -v -n</span></span><br><span class="line">Chain OUTPUT (policy DROP 58 packets, 11780 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">  871 94717 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp spt:22</span><br><span class="line">   17  1428 ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p>查看IPv6的INPUT、OUTPUT链是否已经正确配置回环地址策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -L INPUT -v -n</span></span><br><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 ACCEPT     all      lo     *       ::/0                 ::/0</span><br><span class="line">    0     0 DROP       all      *      *       ::1                  ::/0</span><br><span class="line"><span class="comment"># ip6tables -L OUTPUT -v -n</span></span><br><span class="line">Chain OUTPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 ACCEPT     all      *      lo      ::/0                 ::/0</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下命令设置允许接收和处理lo接口报文，拒绝源地址为127.0.0.0&#x2F;8的报文。iptables是按照顺序进行规则匹配的，所以DROP规则必须被添加在另外两条规则之后，否则由于lo接口发出的报文源地址也是127.0.0.0&#x2F;8，会被DROP规则丢弃：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -A INPUT -i lo -j ACCEPT</span></span><br><span class="line"><span class="comment"># iptables -A OUTPUT -o lo -j ACCEPT</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -s 127.0.0.0/8 -j DROP</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables save</span></span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables: [  OK  ]</span><br></pre></td></tr></table></figure>

<p>配置IPv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -A INPUT -i lo -j ACCEPT</span></span><br><span class="line"><span class="comment"># ip6tables -A OUTPUT -o lo -j ACCEPT</span></span><br><span class="line"><span class="comment"># ip6tables -A INPUT -s ::1 -j DROP</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ip6tables save</span></span><br><span class="line">ip6tables: Saving firewall rules to /etc/sysconfig/ip6tables: [  OK  ]</span><br></pre></td></tr></table></figure>
<h3 id="3-2-8-应当正确配置iptables-INPUT策略"><a href="#3-2-8-应当正确配置iptables-INPUT策略" class="headerlink" title="3.2.8 应当正确配置iptables INPUT策略"></a>3.2.8 应当正确配置iptables INPUT策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>INPUT链的作用是对从外部接收的报文进行过滤，任何对外提供的服务，都需要配置对应的INPUT策略，开启相关的端口，外部客户端才能通过该端口访问该服务。</p>
<p>如果未配置，由于默认策略配置为DROP，所有外部尝试访问相关业务的报文都将被丢弃。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查INPUT链配置的策略是否满足业务需要，如下例子中开启了目标端口为22的tcp报文通道（即SSH协议的默认端口），且不限制源、目标IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -L INPUT -v -n</span></span><br><span class="line">Chain INPUT (policy DROP 2132 packets, 683K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 1207 90226 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:22</span><br></pre></td></tr></table></figure>

<p>检查IPv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -L INPUT -v -n</span></span><br><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 ACCEPT     all      lo     *       ::/0                 ::/0</span><br><span class="line">    0     0 DROP       all      *      *       ::1                  ::/0</span><br><span class="line">    0     0 ACCEPT     tcp      *      *       ::/0                 ::/0                 tcp dpt:22</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下命令新增ACCEPT策略到INPUT链：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -A INPUT -p &lt;protocol&gt; -s &lt;source ip&gt; -d &lt;dest ip&gt; --dport &lt;dest port&gt; -j ACCEPT</span></span><br><span class="line">例如：</span><br><span class="line"><span class="comment"># iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables save</span></span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables: [  OK  ]</span><br></pre></td></tr></table></figure>

<p>配置IPv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -A INPUT -p &lt;protocol&gt; -s &lt;source ip&gt; -d &lt;dest ip&gt; --dport &lt;dest port&gt; -j ACCEPT</span></span><br><span class="line">例如：</span><br><span class="line"><span class="comment"># ip6tables -A INPUT -p tcp --dport 22 -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ip6tables save</span></span><br><span class="line">ip6tables: Saving firewall rules to /etc/sysconfig/ip6tables: [  OK  ]</span><br></pre></td></tr></table></figure>
<h3 id="3-2-9-应当正确配置iptables-OUTPUT策略"><a href="#3-2-9-应当正确配置iptables-OUTPUT策略" class="headerlink" title="3.2.9 应当正确配置iptables OUTPUT策略"></a>3.2.9 应当正确配置iptables OUTPUT策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>服务器外发报文主要有两种情况，一种是主机进程主动连接外部服务器，比如http访问，或者外发数据到日志服务器等，另一种是外部访问本机服务，本机进行回复的报文。</p>
<p>如果未配置OUTPUT策略，由于默认策略是DROP，服务器所有外发报文都将被丢弃。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查OUTPUT链配置的策略是否满足业务需要，如下例子中开启了源端口为22的tcp报文通道（即SSH协议的默认端口），且不限制源、目标IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -L OUTPUT -v -n</span></span><br><span class="line">Chain OUTPUT (policy DROP 30 packets, 9840 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 1383  156K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp spt:22</span><br></pre></td></tr></table></figure>

<p>检查IPv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -L OUTPUT -v -n</span></span><br><span class="line">Chain OUTPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 ACCEPT     all      *      lo      ::/0                 ::/0</span><br><span class="line">    0     0 ACCEPT     tcp      *      *       ::/0                 ::/0                 tcp spt:22</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下命令新增ACCEPT策略到OUTPUT链：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -A OUTPUT -p &lt;protocol&gt; -s &lt;source ip&gt; -d &lt;dest ip&gt; --sport &lt;src port&gt; -j ACCEPT</span></span><br><span class="line">例如：</span><br><span class="line"><span class="comment"># iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables save</span></span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables: [  OK  ]</span><br></pre></td></tr></table></figure>

<p>配置IPv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -A OUTPUT -p &lt;protocol&gt; -s &lt;source ip&gt; -d &lt;dest ip&gt; --sport &lt;src port&gt; -j ACCEPT</span></span><br><span class="line">例如：</span><br><span class="line"><span class="comment"># ip6tables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ip6tables save</span></span><br><span class="line">ip6tables: Saving firewall rules to /etc/sysconfig/ip6tables: [  OK  ]</span><br></pre></td></tr></table></figure>
<h3 id="3-2-10-应当正确配置iptables-INPUT、OUTPUT关联策略"><a href="#3-2-10-应当正确配置iptables-INPUT、OUTPUT关联策略" class="headerlink" title="3.2.10 应当正确配置iptables INPUT、OUTPUT关联策略"></a>3.2.10 应当正确配置iptables INPUT、OUTPUT关联策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>虽然可以通过配置协议、ip和端口等，将进出服务器的报文策略配置到INPUT和OUTPUT链，但有些情况下会比较复杂，比如客户端通过某端口访问服务器，但服务器在返回响应报文时并不一定从原端口返回，可能使用随机的源端口，这种情况下通过sport参数很难配置准确的策略。</p>
<p>此时需要考虑使用关联链接的方式配置策略，如果一个外发的报文属于一个已经存在的网络链接，则直接放行；如果一个接收的报文，属于一个已经存在的网络链接，也直接放行。因为这些已经存在的链接必定是经过其他策略过滤和检查的，否则无法建立。</p>
<p>如果不通过关联链接的方式配置策略，则需要将所有可能的链接情况全部分析清楚并配置对应的策略，如果配置过松，可能导致安全风险，如果配置过严，可能导致业务中断。</p>
<p><strong>规则影响</strong>：</p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查INPUT和OUTPUT链是否配置了关联策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -L</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             state ESTABLISHED</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             state ESTABLISHED</span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere             state ESTABLISHED</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP)</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             state NEW,ESTABLISHED</span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere             state NEW,ESTABLISHED</span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere             state NEW,ESTABLISHED</span><br></pre></td></tr></table></figure>

<p>检查IPv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -L</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     all      anywhere             anywhere</span><br><span class="line">DROP       all      localhost            anywhere</span><br><span class="line">ACCEPT     tcp      anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">ACCEPT     tcp      anywhere             anywhere             state ESTABLISHED</span><br><span class="line">ACCEPT     udp      anywhere             anywhere             state ESTABLISHED</span><br><span class="line">ACCEPT     icmp     anywhere             anywhere             state ESTABLISHED</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     all      anywhere             anywhere</span><br><span class="line">ACCEPT     tcp      anywhere             anywhere             tcp spt:ssh</span><br><span class="line">ACCEPT     tcp      anywhere             anywhere             state NEW,ESTABLISHED</span><br><span class="line">ACCEPT     udp      anywhere             anywhere             state NEW,ESTABLISHED</span><br><span class="line">ACCEPT     icmp     anywhere             anywhere             state NEW,ESTABLISHED</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下命令配置OUTPUT链的tcp、udp和icmp策略，允许所有新建和已建立链接的报文外发；配置INPUT链的tcp、udp和icmp策略，允许所有已建立链接的报文接收：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># iptables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># iptables -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service iptables save</span></span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables: [  OK  ]</span><br></pre></td></tr></table></figure>

<p>配置IPv6：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip6tables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># ip6tables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># ip6tables -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># ip6tables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># ip6tables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT</span></span><br><span class="line"><span class="comment"># ip6tables -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure>

<p>通过如下命令使当前配置的策略永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ip6tables save</span></span><br><span class="line">ip6tables: Saving firewall rules to /etc/sysconfig/ip6tables: [  OK  ]</span><br></pre></td></tr></table></figure>
<h3 id="3-2-11-应当启用nftables服务"><a href="#3-2-11-应当启用nftables服务" class="headerlink" title="3.2.11 应当启用nftables服务"></a>3.2.11 应当启用nftables服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>nftables是Linux内核的子系统，提供对网络数据包的过滤和分类，nftables替换了Netfilter的iptables部分。与iptables相比，nftable更容易扩展到新协议，nftables将在未来替代iptables。另外，nftables不同于firewalld和iptables，操作系统默认未配置任何策略，需要管理员手工配置。</p>
<p>需要注意的是，openEuler默认且建议使用firewalld服务。如果必须使用nftables提供防火墙服务，则必须关闭firewalld和iptables服务。如果未启用任何防火墙服务，则将提高系统被攻击、篡改的可能。</p>
<p>三种防火墙服务建议只启用一种，不建议同时启用多种，如果多种防火墙规则设置不正确，可能导致规则冲突、防护混乱。</p>
<p><strong>规则影响：</strong></p>
<p>如果启用多个防火墙服务，可能导致因为策略配置不一致而造成业务中断。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方式检查nftables服务已经被启用，firewalld和iptables服务未被启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service nftables status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: active (exited) since Wed 2020-12-16 07:04:32 CST; 6s ago</span><br><span class="line"><span class="comment"># service firewalld status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: inactive (dead)</span><br><span class="line"><span class="comment"># service iptables status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">Active: inactive (dead)</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>使用如下方法启用nftables服务，并配置永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service nftables start</span></span><br><span class="line"><span class="comment"># systemctl enable nftables</span></span><br></pre></td></tr></table></figure>

<p>使用如下方法关闭firewalld和iptables服务，并配置永久生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service firewalld stop</span></span><br><span class="line"><span class="comment"># service iptables stop</span></span><br><span class="line"><span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment"># systemctl disable iptables</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-12-应当配置nftables默认拒绝策略"><a href="#3-2-12-应当配置nftables默认拒绝策略" class="headerlink" title="3.2.12 应当配置nftables默认拒绝策略"></a>3.2.12 应当配置nftables默认拒绝策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>从安全角度考虑，nftables基础链类似于iptables，（input、output、forward）需要配置所有报文的拒绝策略，然后再在基础链中添加允许策略，开放相关服务和端口。</p>
<p>如果没有配置基础链，或没有指定基础链的hook规则，报文将不会被nftables捕捉到，也就无法进行过滤处理。</p>
<p><strong>规则影响：</strong></p>
<p>如果基础链未配置DROP或REJECT策略，报文默认都将被ACCEPT，容易因为遗漏拒绝策略而导致安全风险。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方法检查是否配置了input、output和forward的DROP策略，注意举例中同时已经配置了SSH的input和output ACCEPT策略，如果不配置，通过SSH远程登录将断开：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset</span></span><br><span class="line">table inet <span class="built_in">test</span> &#123;</span><br><span class="line">	chain input &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook input priority 0; policy drop;</span><br><span class="line">		tcp dport ssh accept</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain output &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook output priority 0; policy drop;</span><br><span class="line">		tcp sport ssh accept</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain forward &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook forward priority 0; policy drop;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>首先创建table：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add table inet &lt;table name&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后通过如下方法在table中配置input、output、forward基础链的drop策略，注意，配置后网络将可能断开：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add chain inet &lt;table name&gt; &lt;chain name&gt; &#123; type filter hook input priority 0\; policy drop\; &#125;</span></span><br><span class="line"><span class="comment"># nft add chain inet &lt;table name&gt; &lt;chain name&gt; &#123; type filter hook output priority 0\; policy drop\; &#125;</span></span><br><span class="line"><span class="comment"># nft add chain inet &lt;table name&gt; &lt;chain name&gt; &#123; type filter hook forward priority 0\; policy drop\; &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过如下方式将当前配置的规则保存到配置文件中，以便系统重启后能够自动加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>

<p>注意，上述方式保存配置文件会覆盖原有配置内容，亦可将当前规则导出到单独文件中，或者直接在文件中编写新规则，然后在&#x2F;etc&#x2F;sysconfig&#x2F;nftables.conf配置文件中通过include方式加载，此种方式需要注意避免多个include规则文件内有重复规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/nftables/new_test_rules.nft</span></span><br><span class="line"><span class="comment"># echo &quot;include \&quot;/etc/nftables/new_test_rules.nft\&quot;&quot; &gt;&gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-13-应当配置nftables-loopback策略"><a href="#3-2-13-应当配置nftables-loopback策略" class="headerlink" title="3.2.13 应当配置nftables loopback策略"></a>3.2.13 应当配置nftables loopback策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>回环地址是服务器上一个特殊的地址，以127.0.0.0&#x2F;8表示，同网卡无关，主要用于本机进程间通信，不应该从网卡上收到源地址为127.0.0.0&#x2F;8的报文，此类报文应该被丢弃。如果回环地址策略设置不正确，则可能导致本机进程间通信失败，或者从网卡收到欺骗报文。</p>
<p>服务器需要设置策略，允许接收和处理lo接口的回环地址报文，但拒绝从网卡收到的报文。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>查看是否已经配置回环地址策略，input链需要配置从“lo”设备接收报文的ACCEPT策略，配置从非“lo”设备接收，且源地址为127.0.0.0&#x2F;8的报文的DROP策略，在output链需要配置源地址为127.0.0.0&#x2F;8的报文的ACCEPT策略：</p>
<p>IPv4配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset</span></span><br><span class="line">table inet <span class="built_in">test</span> &#123;</span><br><span class="line">	chain input &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook input priority 0; policy drop;</span><br><span class="line">		tcp dport ssh accept</span><br><span class="line">		iif <span class="string">&quot;lo&quot;</span> accept</span><br><span class="line">		iif != <span class="string">&quot;lo&quot;</span> ip saddr 127.0.0.0/8 drop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain output &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook output priority 0; policy drop;</span><br><span class="line">		tcp sport ssh accept</span><br><span class="line">		ip saddr 127.0.0.0/8 accept</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain forward &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook forward priority 0; policy drop;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPv6配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset</span></span><br><span class="line">table inet <span class="built_in">test</span> &#123;</span><br><span class="line">	chain input &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook input priority 0; policy drop;</span><br><span class="line">		tcp dport ssh accept</span><br><span class="line">		iif <span class="string">&quot;lo&quot;</span> accept</span><br><span class="line">		iif != <span class="string">&quot;lo&quot;</span> ip6 saddr ::1 drop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain output &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook output priority 0; policy drop;</span><br><span class="line">		tcp sport ssh accept</span><br><span class="line">		ip6 saddr ::1 accept</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain forward &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook forward priority 0; policy drop;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下方法添加input和output链的策略：</p>
<p>配置input链“lo”接口ACCEPT策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add rule inet test input iif &quot;lo&quot; accept</span></span><br></pre></td></tr></table></figure>

<p>配置IPv4 input链DROP策略，output链ACCEPT策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add rule inet test input iif != &quot;lo&quot; ip saddr 127.0.0.0/8 drop</span></span><br><span class="line"><span class="comment"># nft add rule inet test output ip saddr 127.0.0.0/8 accept</span></span><br></pre></td></tr></table></figure>

<p>配置IPv6 input链DROP策略，output链ACCEPT策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add rule inet test input iif != &quot;lo&quot; ip6 saddr ::1 drop</span></span><br><span class="line"><span class="comment"># nft add rule inet test output ip6 saddr ::1 accept</span></span><br></pre></td></tr></table></figure>

<p>通过如下方式将当前配置的规则保存到配置文件中，以便系统重启后能够自动加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>

<p>注意，上述方式保存配置文件会覆盖原有配置内容，亦可将当前规则导出到单独文件中，或者直接在文件中编写新规则，然后在&#x2F;etc&#x2F;sysconfig&#x2F;nftables.conf配置文件中通过include方式加载，此种方式需要注意避免多个include规则文件内有重复规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/nftables/new_test_rules.nft</span></span><br><span class="line"><span class="comment"># echo &quot;include \&quot;/etc/nftables/new_test_rules.nft\&quot;&quot; &gt;&gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-14-应当正确配置nftables-input策略"><a href="#3-2-14-应当正确配置nftables-input策略" class="headerlink" title="3.2.14 应当正确配置nftables input策略"></a>3.2.14 应当正确配置nftables input策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>input链的作用是对从外部接收的报文进行过滤，任何对外提供的服务，都需要配置对应的input策略，开启相关的端口，外部客户端才能通过该端口访问该服务。</p>
<p>如果未配置，由于默认策略配置为DROP，所有外部尝试访问相关业务的报文都将被丢弃。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查input链配置的策略是否满足业务需要，如下例子中开启了目标端口为22的tcp报文通道（即SSH协议的默认端口），且不限制源、目标IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list chain inet test input</span></span><br><span class="line">table inet <span class="built_in">test</span> &#123;</span><br><span class="line">	chain input &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook input priority 0; policy drop;</span><br><span class="line">		tcp dport ssh accept</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下命令新增ACCEPT策略到input链：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add rule inet &lt;table name&gt; &lt;chain name&gt; &lt;protocol&gt; dport &lt;port number&gt; accept</span></span><br><span class="line">例如：</span><br><span class="line"><span class="comment"># nft add rule inet test input tcp dport ssh accept</span></span><br></pre></td></tr></table></figure>

<p>通过如下方式将当前配置的规则保存到配置文件中，以便系统重启后能够自动加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>

<p>注意，上述方式保存配置文件会覆盖原有配置内容，亦可将当前规则导出到单独文件中，或者直接在文件中编写新规则，然后在&#x2F;etc&#x2F;sysconfig&#x2F;nftables.conf配置文件中通过include方式加载，此种方式需要注意避免多个include规则文件内有重复规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/nftables/new_test_rules.nft</span></span><br><span class="line"><span class="comment"># echo &quot;include \&quot;/etc/nftables/new_test_rules.nft\&quot;&quot; &gt;&gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-15-应当正确配置nftables-output策略"><a href="#3-2-15-应当正确配置nftables-output策略" class="headerlink" title="3.2.15 应当正确配置nftables output策略"></a>3.2.15 应当正确配置nftables output策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>服务器外发报文主要有两种情况，一种是主机进程主动连接外部服务器，比如http访问，或者外发数据到日志服务器等，另一种是外部访问本机服务，本机进行回复的报文。</p>
<p>如果未配置output策略，由于默认策略是DROP，服务器所有外发报文都将被丢弃。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查output链配置的策略是否满足业务需要，如下例子中开启了源端口为22的tcp报文通道（即SSH协议的默认端口），且不限制源、目标IP地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list chain inet test output</span></span><br><span class="line">table inet <span class="built_in">test</span> &#123;</span><br><span class="line">	chain output &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook output priority 0; policy drop;</span><br><span class="line">		tcp sport ssh accept</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下命令新增ACCEPT策略到output链：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add rule inet &lt;table name&gt; &lt;chain name&gt; &lt;protocol&gt; sport &lt;port number&gt; accept</span></span><br><span class="line">例如：</span><br><span class="line"><span class="comment"># nft add rule inet test output tcp sport ssh accept</span></span><br></pre></td></tr></table></figure>

<p>通过如下方式将当前配置的规则保存到配置文件中，以便系统重启后能够自动加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>

<p>注意，上述方式保存配置文件会覆盖原有配置内容，亦可将当前规则导出到单独文件中，或者直接在文件中编写新规则，然后在&#x2F;etc&#x2F;sysconfig&#x2F;nftables.conf配置文件中通过include方式加载，此种方式需要注意避免多个include规则文件内有重复规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/nftables/new_test_rules.nft</span></span><br><span class="line"><span class="comment"># echo &quot;include \&quot;/etc/nftables/new_test_rules.nft\&quot;&quot; &gt;&gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-16-应当正确配置nftables-input、output关联策略"><a href="#3-2-16-应当正确配置nftables-input、output关联策略" class="headerlink" title="3.2.16 应当正确配置nftables input、output关联策略"></a>3.2.16 应当正确配置nftables input、output关联策略</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>虽然可以通过配置协议、ip和端口等，将进出服务器的报文策略配置到input和output链，但有些情况下会比较复杂，比如客户端通过某端口访问服务器，但服务器在返回响应报文时并不一定从原端口返回，可能使用随机的源端口，这种情况下通过sport参数很难配置准确的策略。</p>
<p>此时需要考虑使用关联链接的方式配置策略，如果一个外发的报文属于一个已经存在的网络链接，则直接放行；如果一个接收的报文，属于一个已经存在的网络链接，也直接放行。因为这些已经存在的链接必定是经过其他策略过滤和检查的，否则无法建立。</p>
<p>如果不通过关联链接的方式配置策略，则需要将所有可能的链接情况全部分析清楚并配置对应的策略，如果配置过松，可能导致安全风险，如果配置过严，可能导致业务中断。</p>
<p><strong>规则影响</strong>：</p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查input和output链是否配置了关联策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset</span></span><br><span class="line">table inet <span class="built_in">test</span> &#123;</span><br><span class="line">	chain input &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook input priority 0; policy drop;</span><br><span class="line">		tcp dport ssh accept</span><br><span class="line">		ip protocol tcp ct state established accept</span><br><span class="line">		ip protocol udp ct state established accept</span><br><span class="line">		ip protocol icmp ct state established accept</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain output &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook output priority 0; policy drop;		</span><br><span class="line">		ip protocol tcp ct state established,related,new accept</span><br><span class="line">		ip protocol udp ct state established,related,new accept</span><br><span class="line">		ip protocol icmp ct state established,related,new accept</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain forward &#123;</span><br><span class="line">		<span class="built_in">type</span> filter hook forward priority 0; policy drop;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下命令配置output链的tcp、udp和icmp策略，允许所有新建和已建立链接的报文外发；配置input链的tcp、udp和icmp策略，允许所有已建立链接的报文接收：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft add rule inet test output ip protocol tcp ct state new,related,established accept</span></span><br><span class="line"><span class="comment"># nft add rule inet test output ip protocol udp ct state new,related,established accept</span></span><br><span class="line"><span class="comment"># nft add rule inet test output ip protocol icmp ct state new,related,established accept</span></span><br><span class="line"><span class="comment"># nft add rule inet test input ip protocol tcp ct state established accept</span></span><br><span class="line"><span class="comment"># nft add rule inet test input ip protocol udp ct state established accept</span></span><br><span class="line"><span class="comment"># nft add rule inet test input ip protocol icmp ct state established accept</span></span><br></pre></td></tr></table></figure>

<p>通过如下方式将当前配置的规则保存到配置文件中，以便系统重启后能够自动加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>

<p>注意，上述方式保存配置文件会覆盖原有配置内容，亦可将当前规则导出到单独文件中，或者直接在文件中编写新规则，然后在&#x2F;etc&#x2F;sysconfig&#x2F;nftables.conf配置文件中通过include方式加载，此种方式需要注意避免多个include规则文件内有重复规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nft list ruleset &gt; /etc/nftables/new_test_rules.nft</span></span><br><span class="line"><span class="comment"># echo &quot;include \&quot;/etc/nftables/new_test_rules.nft\&quot;&quot; &gt;&gt; /etc/sysconfig/nftables.conf</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-SSH"><a href="#3-3-SSH" class="headerlink" title="3.3 SSH"></a>3.3 SSH</h2><h3 id="3-3-1-确保SSH服务版本配置正确"><a href="#3-3-1-确保SSH服务版本配置正确" class="headerlink" title="3.3.1 确保SSH服务版本配置正确"></a>3.3.1 确保SSH服务版本配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>如果使用SSH1，由于协议本身存在较多的未修复漏洞，且社区已不作为主流协议进行长期维护，容易使攻击者有机可乘，造成信息泄露、命令数据篡改等风险。</p>
<p>openEuler默认继承的OpenSSH组件使用SSH协议进行远程控制或在服务器之间传递文件，支持SSH 1.3、1.5和2.0协议，其中1.x协议简称SSH1，由于安全原因不允许使用；2.0协议简称为SSH2，目前无安全问题，要求使用。SSH1同SSH2互不兼容，所以要求服务端在使用SSH2之后，客户端也必须使用SSH 2.0协议。</p>
<p>当前openEuler默认使用SSH2。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过如下命令，查看返回是否为2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^Protocol&quot; /etc/ssh/sshd_config</span></span><br><span class="line">Protocol 2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，将Protocol字段后面的数字修改为2，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">Protocol 2</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-确保SSH服务认证方式配置正确"><a href="#3-3-2-确保SSH服务认证方式配置正确" class="headerlink" title="3.3.2 确保SSH服务认证方式配置正确"></a>3.3.2 确保SSH服务认证方式配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>配置合理的认证方式有利于确保用户及系统数据安全，通常情况下，对于人机账号，账号&#x2F;口令方式比较合适；对于非交互式的登录场景，公私钥方式比较合适；而对于高安全风险场景，仅开启公私钥认证方式更合适。如果使用基于主机的身份认证，攻击者可通过域名污染或IP欺骗后无需口令直接入侵系统。</p>
<p>SSH服务本身提供多种认证方式，但出于安全考虑，禁止使用基于主机的身份认证。</p>
<p>openEuler默认使用账号&#x2F;口令方式认证，在安装系统时，要求配置root管理员口令。</p>
<p>openEuler允许公私钥方式认证。</p>
<p>openEuler允许交互式-账号&#x2F;口令方式认证。</p>
<p>根据业务场景需要，务必配置正确的认证方式。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方法，检查配置是否正确，此处IgnoreRhosts必须配置为yes，HostbasedAuthentication必须配置为no，PasswordAuthentication、ChallengeResponseAuthentication和PubkeyAuthentication至少有一个为yes：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^PasswordAuthentication\|^PubkeyAuthentication\|^ChallengeResponseAuthentication\|^IgnoreRhosts\|^HostbasedAuthentication&quot; /etc/ssh/sshd_config</span></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">ChallengeResponseAuthentication <span class="built_in">yes</span></span><br><span class="line">IgnoreRhosts <span class="built_in">yes</span></span><br><span class="line">HostbasedAuthentication no</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>启用账号&#x2F;口令认证方式</p>
<p>配置&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，开启PasswordAuthentication选项，重启sshd服务，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启用公私钥认证方式</p>
<p>配置&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，开启PubkeyAuthentication选项，并配置公钥存储路径，重启sshd服务，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">AuthorizedKeysFile      .ssh/authorized_keys</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>

<p>客户端生成RSA公私钥，并把公钥拷贝到指定目录下即可，如上例中“.ssh&#x2F;authorized_keys”目录。</p>
</li>
<li><p>启用交互式-账号&#x2F;口令认证方式</p>
<p>配置&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，开启ChallengeResponseAuthentication选项，重启sshd服务，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">ChallengeResponseAuthentication <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭基于主机的认证</p>
<p>配置&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，开启IgnoreRhosts，关闭HostbasedAuthentication，重启sshd服务，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">IgnoreRhosts <span class="built_in">yes</span></span><br><span class="line">HostbasedAuthentication no</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-3-确保SSH密钥交换算法配置正确"><a href="#3-3-3-确保SSH密钥交换算法配置正确" class="headerlink" title="3.3.3 确保SSH密钥交换算法配置正确"></a>3.3.3 确保SSH密钥交换算法配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>密钥交换是密码学中双方交换密钥以允许使用某种加密算法的过程。通过安全的密钥交换算法，双方可以安全地交换密钥，从而允许使用加密算法对要发送的消息进行加密，并对接收到的消息进行解密。设置SSH密钥交换算法，限制密钥交换这一阶段所能使用的算法。要注意的是，若配置的算法不安全，则会增加使用风险，因为弱算法在业界已经或者即将被破解。</p>
<p>推荐的安全算法如下（按优先级排序，openEuler已默认配置）：</p>
<p>curve25519-sha256</p>
<p><a href="mailto:&#99;&#117;&#114;&#x76;&#x65;&#x32;&#x35;&#x35;&#x31;&#57;&#x2d;&#115;&#104;&#97;&#x32;&#53;&#54;&#64;&#x6c;&#105;&#x62;&#115;&#x73;&#x68;&#x2e;&#111;&#x72;&#103;">&#99;&#117;&#114;&#x76;&#x65;&#x32;&#x35;&#x35;&#x31;&#57;&#x2d;&#115;&#104;&#97;&#x32;&#53;&#54;&#64;&#x6c;&#105;&#x62;&#115;&#x73;&#x68;&#x2e;&#111;&#x72;&#103;</a></p>
<p>diffie-hellman-group-exchange-sha256</p>
<p>可以根据实际业务场景进行修改配置，但所选择的算法必须符合业界安全标准。</p>
<p><strong>规则影响：</strong></p>
<p>如果SSH客户端不支持服务端配置的密钥交换算法，客户端将无法连接到SSH服务端。</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;ssh&#x2F;sshd_config中是否配置了正确的密钥交换算法的字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^KexAlgorithms /etc/ssh/sshd_config</span></span><br><span class="line">KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256</span><br></pre></td></tr></table></figure>

<p>KexAlgorithms字段设置可用的SSH密钥交换算法，用户根据需要进行设置。</p>
<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config，在该文件中设置SSH密钥交换算法，下面给出密钥交换算法示例，用户在设置的时候应根据需要进行设置，设置好密钥交换算法后需重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-确保用户认证密钥算法配置正确"><a href="#3-3-4-确保用户认证密钥算法配置正确" class="headerlink" title="3.3.4 确保用户认证密钥算法配置正确"></a>3.3.4 确保用户认证密钥算法配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>如果采用公私钥认证方式，则需要限制客户端公私钥算法，避免使用已经被业界淘汰的不安全算法。</p>
<p>推荐的安全算法如下（按优先级排序，openEuler已默认配置）：</p>
<p>ssh-ed25519</p>
<p><a href="mailto:&#x73;&#115;&#x68;&#x2d;&#101;&#100;&#50;&#53;&#x35;&#x31;&#57;&#x2d;&#99;&#x65;&#114;&#116;&#x2d;&#118;&#48;&#x31;&#64;&#x6f;&#112;&#101;&#x6e;&#115;&#x73;&#x68;&#x2e;&#99;&#111;&#x6d;">&#x73;&#115;&#x68;&#x2d;&#101;&#100;&#50;&#53;&#x35;&#x31;&#57;&#x2d;&#99;&#x65;&#114;&#116;&#x2d;&#118;&#48;&#x31;&#64;&#x6f;&#112;&#101;&#x6e;&#115;&#x73;&#x68;&#x2e;&#99;&#111;&#x6d;</a></p>
<p>rsa-sha2-256</p>
<p>rsa-sha2-512</p>
<p>RFC 4253中定义的ssh-rsa公钥算法使用了SHA1进行哈希运算，因此禁止使用。</p>
<p><strong>规则影响：</strong></p>
<p>如果SSH客户端不支持服务端配置的公私钥算法，客户端将无法连接到SSH服务端。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方法检查配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^PubkeyAcceptedKeyTypes&quot; /etc/ssh/sshd_config</span></span><br><span class="line">PubkeyAcceptedKeyTypes ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,rsa-sha2-256,rsa-sha2-512</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config的PubkeyAcceptedKeyTypes字段的算法列表，不同算法间通过逗号分隔，重启sshd服务，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">PubkeyAcceptedKeyTypes ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,rsa-sha2-256,rsa-sha2-512</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-5-确保PAM认证使能"><a href="#3-3-5-确保PAM认证使能" class="headerlink" title="3.3.5 确保PAM认证使能"></a>3.3.5 确保PAM认证使能</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>PAM（Pluggable Authentication Modules）是Linux平台上可插拔的认证模块，PAM提供了一系列的开源共享库文件（so），通过配置参数可以灵活控制相关认证过程。SSH通过配置PAM认证，可以基于Linux系统的用户认证管理模块完成SSH远程登录用户的认证授权和管理，相对比较方便和统一；否则SSH需要对认证过程进行管理，例如认证失败次数控制，账号是否锁定等，配置容易遗漏或无法达到PAM管理的效果。</p>
<p>openEuler SSH默认使用PAM认证。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^UsePAM&quot; /etc/ssh/sshd_config</span></span><br><span class="line">UsePAM <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，将UsePAM设置为yes，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">UsePAM <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-6-确保SSH服务MACs算法配置正确"><a href="#3-3-6-确保SSH服务MACs算法配置正确" class="headerlink" title="3.3.6 确保SSH服务MACs算法配置正确"></a>3.3.6 确保SSH服务MACs算法配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>消息认证算法MACs：密码学中，通信实体双方使用的一种验证机制，保证了消息数据完整性。若配置的算法不安全，则会增加使用风险，因为弱算法在业界已经或者即将被破解。</p>
<p>推荐的安全算法如下（按优先级排序，openEuler已默认配置）：</p>
<p>hmac-sha2-512</p>
<p><a href="mailto:&#x68;&#x6d;&#97;&#99;&#45;&#115;&#x68;&#x61;&#x32;&#x2d;&#x35;&#49;&#50;&#45;&#x65;&#116;&#109;&#x40;&#x6f;&#112;&#x65;&#x6e;&#x73;&#115;&#104;&#x2e;&#99;&#x6f;&#x6d;">&#x68;&#x6d;&#97;&#99;&#45;&#115;&#x68;&#x61;&#x32;&#x2d;&#x35;&#49;&#50;&#45;&#x65;&#116;&#109;&#x40;&#x6f;&#112;&#x65;&#x6e;&#x73;&#115;&#104;&#x2e;&#99;&#x6f;&#x6d;</a></p>
<p>hmac-sha2-256</p>
<p><a href="mailto:&#x68;&#x6d;&#97;&#99;&#x2d;&#x73;&#x68;&#x61;&#50;&#45;&#x32;&#53;&#x36;&#45;&#101;&#116;&#x6d;&#64;&#x6f;&#x70;&#101;&#x6e;&#115;&#x73;&#x68;&#x2e;&#x63;&#x6f;&#x6d;">&#x68;&#x6d;&#97;&#99;&#x2d;&#x73;&#x68;&#x61;&#50;&#45;&#x32;&#53;&#x36;&#45;&#101;&#116;&#x6d;&#64;&#x6f;&#x70;&#101;&#x6e;&#115;&#x73;&#x68;&#x2e;&#x63;&#x6f;&#x6d;</a></p>
<p><strong>规则影响：</strong></p>
<p>如果SSH客户端不支持服务端配置的MACs算法，客户端将无法连接到SSH服务端。</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^MACs&quot; /etc/ssh/sshd_config</span></span><br><span class="line">MACs hmac-sha2-512,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha2-256-etm@openssh.com</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，在该文件中设置SSH消息认证算法，下面给出消息认证算法示例，用户在设置的时候应根据需要进行设置，设置好消息认证算法后需重启sshd服务使之生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">MACs hmac-sha2-512,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha2-256-etm@openssh.com</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-7-确保SSH服务密码算法配置正确"><a href="#3-3-7-确保SSH服务密码算法配置正确" class="headerlink" title="3.3.7 确保SSH服务密码算法配置正确"></a>3.3.7 确保SSH服务密码算法配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>随着密码技术的发展以及计算能力的提升，一些密码算法已不再适合现今的安全领域。例如MD5算法，该算法已经于2004年由山东大学王小云教授的团队予以破解（人为构造出两个具有相同MD5值的信息），并且在2007年由密码学家Marc Stevens进一步扩展和改进该攻击，实现了数字证书伪造，其安全性已非常低下，因此， MD5不应用于所有密码学安全用途，包括用于数字签名，HMAC，口令单向保护、密钥派生、RNG等，但是，对于校验线路错误、校验介质损坏引起的比特跳变等非密码学安全用途，使用MD5不受本规范约束。又比如DES算法，因为密码学分析技术的发展和计算能力提升导致对其进行暴力破解成为可能，现有的暴力破解设备能将破解DES的时间减少到一天以内。这些算法统称为不安全密码算法，如果继续使用这些不安全的密码算法，有可能为数据带来风险。</p>
<p>强密码算法是指当前被业界普遍认可，在其适合的应用场景下安全强度相对该场景下的其它加密算法有相对优势，在合理的安全假设下具有可证明安全性或对其实施破解在计算上显著不可行的密码算法。</p>
<p>密码算法用于加密解密数据，若配置的算法不安全，则会增加使用风险，因为弱算法在业界已经或者即将被破解。</p>
<p><strong>规则影响：</strong></p>
<p>如果SSH客户端不支持服务端配置的加密算法，客户端将无法连接到SSH服务端。</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^Ciphers&quot; /etc/ssh/sshd_config</span></span><br><span class="line">Ciphers aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com,aes128-gcm@openssh.com,aes256-gcm@openssh.com</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，在该文件中设置SSH密码算法，下面给出密码算法示例，用户在设置的时候应根据需要进行设置，设置好密码算法后需重启sshd服务使之生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">Ciphers aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com,aes128-gcm@openssh.com,aes256-gcm@openssh.com</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-8-禁止SSH服务配置加密算法覆盖策略"><a href="#3-3-8-禁止SSH服务配置加密算法覆盖策略" class="headerlink" title="3.3.8 禁止SSH服务配置加密算法覆盖策略"></a>3.3.8 禁止SSH服务配置加密算法覆盖策略</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SSH服务加密算法的配置文件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config、&#x2F;etc&#x2F;sysconfig&#x2F;sshd。当SSH服务正在运行中，用户可以编辑&#x2F;etc&#x2F;sysconfig&#x2F;sshd文件从而覆盖加密算法策略。如果配置加密算法覆盖策略将允许用户配置安全性较低的加密算法、消息认证算法、密钥交换算法等，降低了系统的安全性。攻击者可以利用这些不安全的算法破解系统信息，增加了安全风险。</p>
<p>openEuler默认不配置加密算法覆盖策略。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查SSH配置文件&#x2F;etc&#x2F;sysconfig&#x2F;sshd，如果“CRYPTO_POLICY&#x3D;”字段为空或该行被注释则说明没有配置加密算法覆盖策略，反之则说明配置了加密算法覆盖策略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^\s*CRYPTO_POLICY=&quot; /etc/sysconfig/sshd | cut -d &quot;=&quot; -f 2-</span></span><br><span class="line"><span class="string">&#x27;-oCiphers=aes256-ctr,aes192-ctr,aes128-ctr -oMACS=hmac-sha2-512,hmac-sha2-256&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>编辑SSH服务配置文件&#x2F;etc&#x2F;sysconfig&#x2F;sshd删除加密算法策略或注释掉该行，重新加载sshd配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysconfig/sshd</span></span><br><span class="line">  </span><br><span class="line">方案 1 删除加密算法策略：</span><br><span class="line">CRYPTO_POLICY=</span><br><span class="line">方案 2 注释该行：</span><br><span class="line"><span class="comment"># CRYPTO_POLICY=&#x27;-oCiphers=aes256-ctr,aes192-ctr,aes128-ctr -oMACS=hmac-sha2-512,hmac-sha2-256&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># systemctl reload sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-9-确保禁用root用户通过SSH登录"><a href="#3-3-9-确保禁用root用户通过SSH登录" class="headerlink" title="3.3.9 确保禁用root用户通过SSH登录"></a>3.3.9 确保禁用root用户通过SSH登录</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SSH 配置文件：&#x2F;etc&#x2F;ssh&#x2F;sshd_config中的PermitRootLogin参数指定root用户是否可以使用ssh登录。<br>不允许root用户通过SSH登录：要求系统管理员使用自己的个人账户进行SSH登录，然后通过sudo或 su提升权限到root。这样可在发生安全事件时提供清晰的审计线索。<br>在对此项安全建议进行配置前，应确认还有其他可用的系统管理员用户账号，否则在配置生效后，将可能导致无法进行SSH远程管理。</p>
<p><strong>规则影响：</strong></p>
<p>配置生效后，root用户不能通过ssh远程登录</p>
<p><strong>检查方法：</strong></p>
<p>执行以下命令，验证SSH的PermitRootLogin配置是否正确（同时满足如下两个命令行的检查）：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sshd -T -C user=root -C host=&quot;$(hostname)&quot; -C addr=&quot;$(grep $(hostname) /etc/hosts | awk &#x27;&#123;print $1&#125;&#x27;)&quot; | grep permitrootlogin</span></span><br><span class="line">permitrootlogin no</span><br><span class="line"><span class="comment"># grep -Ei &#x27;^\s*PermitRootLogin\s+yes&#x27; /etc/ssh/sshd_config</span></span><br><span class="line">Nothing is returned</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，将PermitRootLogin字段修改为no，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-10-应当正确配置SSH服务日志级别"><a href="#3-3-10-应当正确配置SSH服务日志级别" class="headerlink" title="3.3.10 应当正确配置SSH服务日志级别"></a>3.3.10 应当正确配置SSH服务日志级别</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SSH提供多种日志输出级别：QUIET、FATAL、ERROR、INFO、VERBOSE、DEBUG、DEBUG1、DEBUG2、DEBUG3。日志级别设置越高（例如QUIET、FATAL），打印的日志信息越少，有利于节约硬盘空间，但不利于管理员对SSH事件进行审计追溯；反之（例如DEBUG2、DEBUG3），日志打印量大，消耗硬盘空间多，记录的事件比较详细。</p>
<p>openEuler默认设置为VERBOSE，建议根据实际场景设置合理的日志级别，不建议设置DEBUG及以下级别，容易导致日志量过多。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看日志级别配置，如下例中配置为VERBOSE：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^LogLevel&quot; /etc/ssh/sshd_config</span></span><br><span class="line">LogLevel VERBOSE</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，将LogLevel设置为相应的级别，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">LogLevel VERBOSE</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-11-应当正确配置SSH服务接口"><a href="#3-3-11-应当正确配置SSH服务接口" class="headerlink" title="3.3.11 应当正确配置SSH服务接口"></a>3.3.11 应当正确配置SSH服务接口</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>通常情况下服务器存在多个网卡多个IP地址，IP地址应该进行相关的规划，哪些用于业务，哪些用于管理，所以并不是每个IP地址都需要侦听SSH连接，可以通过配置限制只有指定IP地址才能进行SSH连接，减小攻击面。未配置的IP地址无法通过SSH连接到服务器。</p>
<p>openEuler作为平台，无法确定现网场景，默认不配置。建议根据实际情况规划和配置。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>如果已经配置侦听的地址，通过grep命令可以查询对应的配置（<ip addr>为实际已配置的ip地址），返回打印为空表示未配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^ListenAddress&quot; /etc/ssh/sshd_config</span></span><br><span class="line">ListenAddress &lt;ip addr&gt;</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，在ListenAddress字段后设置相应的IP地址，如果有多个，可以设置多行，重启sshd服务，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">ListenAddress &lt;ip addr 1&gt;</span><br><span class="line">ListenAddress &lt;ip addr 2&gt;</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-12-应当正确配置SSH并发未认证连接数"><a href="#3-3-12-应当正确配置SSH并发未认证连接数" class="headerlink" title="3.3.12 应当正确配置SSH并发未认证连接数"></a>3.3.12 应当正确配置SSH并发未认证连接数</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>攻击者在不知道口令的情况下，可以通过建立大量的未完成认证的并发连接来消耗系统资源。</p>
<p>openEuler默认不配置，建议根据实际场景配置上限值。</p>
<p><strong>规则影响：</strong></p>
<p>如果正在进行认证的连接数达到上限，则新连接将被直接拒绝。</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^MaxStartups&quot; /etc/ssh/sshd_config</span></span><br><span class="line">maxstartups 10:30:60</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，配置maxstartups字段。</p>
<p>配置值为用冒号分隔的3个字段，其中第一个字段和最后一个字段分别表示连接数下限和上限，中间字段表示丢弃连接的比例，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">maxstartups 10:30:60</span><br></pre></td></tr></table></figure>
<p>表示未完成认证的连接数达到10个以后，开始丢弃30%的连接申请，如果此时继续累积未完成认证的连接数达到60个，那么拒绝所有新增连接。</p>
<p>修改本配置需要重启sshd服务生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-13-应当正确配置单个SSH连接允许的并发会话数"><a href="#3-3-13-应当正确配置单个SSH连接允许的并发会话数" class="headerlink" title="3.3.13 应当正确配置单个SSH连接允许的并发会话数"></a>3.3.13 应当正确配置单个SSH连接允许的并发会话数</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SSH允许支持多路复用的客户端基于一个网络连接可以建立多个会话，MaxSessions限制每个网络连接允许建立的SSH并发会话数，可以防止系统资源被单个或少数连接无限制的占用，导致拒绝服务攻击。MaxSessions设置为1将禁用会话多路复用，即一个连接仅允许一个会话，而将其设置为0将阻止所有连接会话。</p>
<p>openEuler默认不在配置文件中配置，代码中会取默认值10，建议根据实际场景在配置文件中配置上限值。</p>
<p><strong>规则影响：</strong></p>
<p>如果单个客户端连接建立的会话数已经达到最大连接数，新建会话将被拒绝。</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^MaxSessions&quot; /etc/ssh/sshd_config</span></span><br><span class="line">MaxSessions 10</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，配置MaxSessions字段，该字段后面配置的数字表示限制的连接会话数，重启sshd服务，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">MaxSessions 5</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>

<p>说明：假设设置MaxSessions为5，修改配置并重新启动服务后，对已经存在的SSH会话不参与计数，也就是在该SSH通道还可以新建5个会话；如果修改配置后重新启动服务器，则一个通道只能存在5个会话。</p>
<h3 id="3-3-14-禁止使用X11-Forwarding"><a href="#3-3-14-禁止使用X11-Forwarding" class="headerlink" title="3.3.14 禁止使用X11 Forwarding"></a>3.3.14 禁止使用X11 Forwarding</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SSH的X11 Forwarding功能允许在本地主机上执行远程主机的GUI程序。启用X11 Forwarding功能，则扩大了攻击面，存在被X11服务器端其他用户攻击的可能。如果业务场景中不需要，则必须禁止该功能。</p>
<p>openEuler默认关闭X11 Forwarding功能。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于X11 Forwarding的程序执行受限制。</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^X11Forwarding&quot; /etc/ssh/sshd_config</span></span><br><span class="line">X11Forwarding no</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，配置X11Forwarding字段，将该字段设置为no，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">X11Forwarding no</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-15-应当正确配置MaxAuthTries"><a href="#3-3-15-应当正确配置MaxAuthTries" class="headerlink" title="3.3.15 应当正确配置MaxAuthTries"></a>3.3.15 应当正确配置MaxAuthTries</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>MaxAuthTries值用于表示系统允许单次连接过程中，用户认证失败的次数，超过上限则自动断开连接。建议设置该值小于等于3。</p>
<p>如果该值配置比较大，则单次连接过程中客户端可以尝试多次认证失败，降低了攻击开销。如果该值未在配置文件中显式配置，系统默认为6。</p>
<p><strong>规则影响：</strong></p>
<p>认证失败次数超过上限，自动断开连接。</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^MaxAuthTries&quot; /etc/ssh/sshd_config</span></span><br><span class="line">MaxAuthTries 3</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，配置MaxAuthTries字段，该字段后面配置的数字表示限制的尝试次数，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">MaxAuthTries 3</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-16-禁止使用PermitUserEnvironment"><a href="#3-3-16-禁止使用PermitUserEnvironment" class="headerlink" title="3.3.16 禁止使用PermitUserEnvironment"></a>3.3.16 禁止使用PermitUserEnvironment</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>PermitUserEnvironment允许用户设置SSH环境变量，该设置可能导致攻击者通过修改SSH环境变量进行相应攻击。</p>
<p>如果PermitUserEnvironment配置为yes，则攻击者可以通过修改SSH环境变量绕过安全机制，或者执行攻击代码。该配置必须关闭。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^PermitUserEnvironment&quot; /etc/ssh/sshd_config</span></span><br><span class="line">PermitUserEnvironment no</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，配置PermitUserEnvironment字段为no，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">PermitUserEnvironment no</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-17-应当正确配置LoginGraceTime"><a href="#3-3-17-应当正确配置LoginGraceTime" class="headerlink" title="3.3.17 应当正确配置LoginGraceTime"></a>3.3.17 应当正确配置LoginGraceTime</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>LoginGraceTime用于限制用户登录的时间，如果用户在LoginGraceTime限定的时间内没有完成登录动作，则自动断开连接。建议该值设置为小于或等于60秒。</p>
<p>如果该值设置过大，则攻击者可以利用大量未完成登录动作的连接来消耗服务器资源，从而导致正常管理员登录失败。如果该值未在配置文件中显式配置，系统默认为120秒。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -i &quot;^LoginGraceTime&quot; /etc/ssh/sshd_config</span></span><br><span class="line">LoginGraceTime 60</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，配置LoginGraceTime的值，该字段后面配置的数字表示限制的时间，单位秒，配置后重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">LoginGraceTime 60</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-18-禁止SSH服务预设置authorized-keys"><a href="#3-3-18-禁止SSH服务预设置authorized-keys" class="headerlink" title="3.3.18 禁止SSH服务预设置authorized_keys"></a>3.3.18 禁止SSH服务预设置authorized_keys</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>authorized_keys为远程主机的公钥，用户可以将该公钥存放于主目录$HOME&#x2F;.ssh&#x2F;authorized_keys文件中，用于公钥认证便可以直接登录系统。如果系统中预设authorized_keys，并且服务端开启了公私钥认证的登录方式，攻击者便可以绕过认证直接登录到指定的系统中对其进行攻击。所以系统中不能预设置authorized_keys。</p>
<p>openEuler默认不预设置authorized_keys。<br>注意，本规则仅对初始系统预设置进行约束，对于运行期间，按业务要求必须使用公钥认证的场景，可以例外。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未预设置authorized_keys：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find /home/ /root/ -name authorized_keys </span></span><br><span class="line">/home/test/.ssh/authorized_keys</span><br><span class="line">/root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>删除被检测到的预设置authorized_keys，如&#x2F;root&#x2F;.ssh&#x2F;authorized_keys文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm /root/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-19-禁止SSH服务预设置known-hosts"><a href="#3-3-19-禁止SSH服务预设置known-hosts" class="headerlink" title="3.3.19 禁止SSH服务预设置known_hosts"></a>3.3.19 禁止SSH服务预设置known_hosts</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>known_hosts为主机已经访问过的计算机的公钥，用户成功登录其他计算机后会自动将公钥信息保存在$HOME&#x2F;.ssh&#x2F;known_hosts中。当下次访问相同计算机时会校验公钥，如果校验失败则拒绝建立连接。所以系统中不能预设置known_hosts。</p>
<p>当系统中预设known_hosts时：</p>
<ul>
<li>如果主机公钥正确，则在与目标主机建立连接的过程中不会发出警告，增加了安全风险。</li>
<li>如果主机公钥错误，则无法建立连接到目标主机。</li>
</ul>
<p>openEuler默认不预设置known_hosts。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令查看配置，如果返回为空，表示未预设置known_hosts：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find /home/ /root/ -name known_hosts </span></span><br><span class="line">/home/test/.ssh/known_hosts</span><br><span class="line">/root/.ssh/known_hosts</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>删除被检测到的文件，如&#x2F;root&#x2F;.ssh&#x2F;known_hosts文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm /root/.ssh/known_hosts</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-20-禁止SSH服务配置弃用的选项"><a href="#3-3-20-禁止SSH服务配置弃用的选项" class="headerlink" title="3.3.20 禁止SSH服务配置弃用的选项"></a>3.3.20 禁止SSH服务配置弃用的选项</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>目前SSH服务通讯协议主要分为第一代和第二代，不同版本的通讯协议SSH服务的配置项并不兼容，而且某些低版本的配置项在新版本中已经被废除了。SSH服务端配置文件存放在&#x2F;etc&#x2F;ssh&#x2F;sshd_config中，当前配置选项均为SSH第二代通信协议的配置选项，如果强行配置旧版本的配置项，会导致SSH服务进行自检时报错，且配置项并不生效。所以应禁止配置已经弃用的SSH选项。</p>
<p>openEuler默认不配置已经弃用的SSH选项。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用SSH服务自检命令进行检查如果返回为空表示未出现错误，反之则说明配置了不兼容的选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sshd -t</span></span><br><span class="line">/etc/ssh/sshd_config line 147: Deprecated option RSAAuthentication</span><br><span class="line">/etc/ssh/sshd_config line 149: Deprecated option RhostsRSAAuthentication</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>编辑SSH服务配置文件，删除已经废除的配置项，重启sshd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># RSAAuthentication yes</span></span><br><span class="line"><span class="comment"># RhostsRSAAuthentication no</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-21-确保禁用SSH的TCP转发功能"><a href="#3-3-21-确保禁用SSH的TCP转发功能" class="headerlink" title="3.3.21 确保禁用SSH的TCP转发功能"></a>3.3.21 确保禁用SSH的TCP转发功能</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>将AllowTcpForwarding设置为no的作用是禁止SSH客户端进行TCP端口转发。TCP端口转发是通过SSH隧道在本地主机和远程主机之间传输数据的功能。通过禁用这一功能，可以限制用户在SSH会话中的数据传输和访问范围，从而增强系统的安全性。</p>
<p>配置后具体影响如下：</p>
<ol>
<li>限制数据传输： 禁用TCP端口转发可以防止用户在SSH会话中传输数据，从而降低了可能的数据泄露风险。</li>
<li>减少攻击面：开启TCP端口转发可能会引入一些安全风险，如允许攻击者绕过网络安全措施或访问受限制的服务。禁用这一功能可以减少系统的攻击面。</li>
<li>避免资源滥用：TCP端口转发可能占用服务器资源和带宽，禁用它可以避免资源被滥用。</li>
<li>符合安全最佳实践：在某些情况下，如高度安全性要求的环境，禁用TCP端口转发可能是安全最佳实践之一。</li>
</ol>
<p><strong>规则影响：</strong></p>
<p>禁用TCP端口转发可能会影响某些应用和用例，例如需要远程访问受限服务的情况。</p>
<p><strong>检查方法：</strong></p>
<p>执行以下命令，验证SSH的allowtcpforwarding配置是否正确（同时满足如下两个命令行的检查）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sshd -T -C user=root -C host=&quot;$(hostname)&quot; -C addr=&quot;$(grep $(hostname) /etc/hosts | awk &#x27;&#123;print $1&#125;&#x27;)&quot; | grep allowtcpforwarding</span></span><br><span class="line">allowtcpforwarding no</span><br><span class="line"><span class="comment"># grep -Ei &#x27;^\s*AllowTcpForwarding\s+yes\b&#x27; /etc/ssh/sshd_config</span></span><br><span class="line">Nothing is returned</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>编辑&#x2F;etc&#x2F;ssh&#x2F;sshd_config配置文件，修改AllowTcpForwarding参数，或添加以下代码，对AllowTcpForwarding参数进行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">AllowTcpForwarding no</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-22-应当正确配置认证黑白名单"><a href="#3-3-22-应当正确配置认证黑白名单" class="headerlink" title="3.3.22 应当正确配置认证黑白名单"></a>3.3.22 应当正确配置认证黑白名单</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SSH提供了黑白名单功能，可以设置账号或用户组的清单，允许或禁止某些账号或用户组的用户登录SSH，openEuler默认不配置，相关字段如下：</p>
<p>AllowUsers <userlist></p>
<p>userlist是空格分割的允许登录的账号，不支持uid，可以是user@host格式，user和host将被单独检查，限制特定账号从特定主机上登录，名称里面可使用通配符*和?。配置后将自动禁止系统其他非授权账号登录ssh服务。</p>
<p>AllowGroups <grouplist></p>
<p>grouplist是空格分隔的允许登录的用户组名称，不支持gid</p>
<p>DenyUsers <userlist></p>
<p>userlist是空格分隔的拒绝登录的账号，不支持uid</p>
<p>DenyGroups <grouplist></p>
<p>grouplist是空格分隔的拒绝登录的用户组名称，不支持gid</p>
<p>建议直接删除不使用的用户账号或用户组，而不是通过DenyUsers&#x2F;DenyGroups进行拒绝登录。如果针对某个账号只允许或拒绝在某些客户端登录，可以通过user@host方式配置Allow或Deny规则。</p>
<p>Allow或Deny规则如果同时设置，则取并集，也就是说如果设置了Allow规则，那么被允许的用户账号或用户组之外的，都不允许登录；同时设置了Deny规则，那么在遵循Allow规则后，允许登录的用户账号或用户组范围内再匹配是否符合Deny规则，排除以后剩下的才是可以登录的。</p>
<p><strong>规则影响：</strong></p>
<p>配置Allow规则，被允许的用户账号或用户组之外的，都不允许登录；配置Deny规则，拒绝登录的用户账号或用户组将无法登录。</p>
<p><strong>检查方法：</strong></p>
<p>使用grep命令检查是否存在配置，如果无返回信息，则表示没有任何配置，否则返回配置内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^AllowUsers\|^AllowGroups\|^DenyUsers\|^DenyGroups&quot; /etc/ssh/sshd_config</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>根据业务实际场景，在&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件中添加相关Allow或Deny字段，重启sshd服务，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ssh/sshd_config</span></span><br><span class="line">AllowUsers root <span class="built_in">test</span></span><br><span class="line">DenyUsers test1</span><br><span class="line"><span class="comment"># systemctl restart sshd</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4-定时任务"><a href="#3-4-定时任务" class="headerlink" title="3.4 定时任务"></a>3.4 定时任务</h2><h3 id="3-4-1-确保crontab执行的脚本非属主用户不可写"><a href="#3-4-1-确保crontab执行的脚本非属主用户不可写" class="headerlink" title="3.4.1 确保crontab执行的脚本非属主用户不可写"></a>3.4.1 确保crontab执行的脚本非属主用户不可写</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>crontab 是系统用来执行定时任务的配置文件，配置文件路径为&#x2F;etc&#x2F;crontab。管理员会根据实际的业务需要定义定时任务，操作系统会自动执行该任务。所以crontabs配置文件中配置的执行脚本（程序）应该只有该脚本（程序）的属主可写，不能配置其他低权限用户可写的脚本，否则其他用户可以通过修改该脚本实现提权操作。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查crontabs配置文件&#x2F;etc&#x2F;crontab，检查执行脚本（程序）是否为其他低权限用户可写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line">  *  *  *  *  * user-name  /bin/xxx.sh</span><br><span class="line"><span class="comment"># ll /bin/xxx.sh</span></span><br><span class="line">-rw-------. 1 root root 451 Mar 27 17:00 /bin/xxx.sh</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果&#x2F;etc&#x2F;crontab配置文件中的执行脚本（程序）为其他低权限用户可写，则需要根据实际的业务场景进行修复：</p>
<ul>
<li><p>修复方法1</p>
<p>修改&#x2F;etc&#x2F;crontab配置文件中的执行脚本（程序）的文件权限，去除掉其他低特权用户的可写权限，以防止提权操作。</p>
</li>
<li><p>修复方法2</p>
<p>修改&#x2F;etc&#x2F;crontab配置文件，删除该执行脚本（程序）的配置项，防止提权操作。</p>
</li>
</ul>
<h3 id="3-4-2-确保cron守护进程正常启用"><a href="#3-4-2-确保cron守护进程正常启用" class="headerlink" title="3.4.2 确保cron守护进程正常启用"></a>3.4.2 确保cron守护进程正常启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>cron 守护进程用于在系统上执行批处理作业。</p>
<p>即使操作系统目前可能没有需要运行的用户作业，也会有系统作业需要运行，其中就可能包括安全监控等重要作业，而 cron 守护进程就是用来执行这些作业的。cron守护进程未正常启用的影响：</p>
<ol>
<li>定时任务无法运行： 最直接的影响是配置在 cron 中的定时任务将无法自动运行。这可能会导致一些计划性的任务未能按时执行，如日志清理、备份、系统维护等。</li>
<li>计划性任务延迟： 如果定时任务未能按时执行，可能会导致任务的延迟。这对于某些关键任务来说，可能会影响系统的正常运行和性能。</li>
<li>系统维护和自动化受阻： 自动化任务通常用于监视系统状态、应用程序的运行情况等。如果这些任务未能按时执行，系统可能会错过对潜在问题的检测和处理。</li>
<li>日志分析受影响： 许多系统管理员使用定时任务来执行日志分析、报告生成等任务。如果这些任务无法运行，可能会错过对系统运行情况的重要洞察。</li>
<li>备份延误： 许多备份任务都是通过定时任务实现的。如果定时任务未运行，备份可能会受到影响，导致数据备份不及时或不完整。</li>
</ol>
<p><strong>规则影响：</strong><br>无</p>
<p><strong>检查方法：</strong></p>
<p>执行以下命令来确定 cron 守护进程是否正常启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled crond</span></span><br><span class="line">enabled</span><br></pre></td></tr></table></figure>

<p>如结果为enabled，则视为通过此项检查。</p>
<p><strong>修复方法：</strong></p>
<p>执行以下命令来启用 cron 进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now enable crond</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-3-确保at、cron配置正确"><a href="#3-4-3-确保at、cron配置正确" class="headerlink" title="3.4.3 确保at、cron配置正确"></a>3.4.3 确保at、cron配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>at服务用于进行简单的一次性任务执行，cron服务用于执行系统中的周期性定时任务。&#x2F;etc&#x2F;cron.deny是cron命令的黑名单配置文件，&#x2F;etc&#x2F;cron.allow是cron命令的白名单配置文件，默认不存在，白名单出现时，黑名单失效，只有root账号和写在白名单中的账号可以使用cron命令。</p>
<p>如果使用黑名单机制管理cron定时任务，有可能在添加了新账号之后忘记将其加入黑名单中，增大了系统潜在的安全攻击面。如果cron相关配置文件属主不为root，或者允许group和other用户访问，可能导致系统管理员以外的用户进行cron配置，带来系统安全隐患。如果系统无需启用at、cron配置，此配置项无需检查。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>首先要确保系统中cron服务已经启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled crond</span></span><br></pre></td></tr></table></figure>

<p>请确认返回结果是enabled。</p>
</li>
<li><p>确认&#x2F;etc&#x2F;crontab文件和&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.d目录的UID和GID都是0，且不允许group和other用户访问：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stat /etc/crontab</span></span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认黑名单文件&#x2F;etc&#x2F;cron.deny和&#x2F;etc&#x2F;at.deny不存在，确认白名单文件&#x2F;etc&#x2F;cron.allow和&#x2F;etc&#x2F;at.allow设置了正确的权限，即UID和GID都是0，且不允许group和other用户访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stat /etc/cron.allow</span></span><br><span class="line">Access: (0600/-rwx------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>如果没有启用cron服务，使用以下命令启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl --now enable crond</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置&#x2F;etc&#x2F;crontab文件和&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.d目录的UID&#x2F;GID及权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown root:root /etc/crontab</span></span><br><span class="line"><span class="comment"># chmod og-rwx /etc/crontab</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除&#x2F;etc&#x2F;cron.deny和&#x2F;etc&#x2F;at.deny文件，创建&#x2F;etc&#x2F;cron.allow和&#x2F;etc&#x2F;at.allow文件并设置正确的权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm /etc/cron.deny /etc/at.deny</span></span><br><span class="line"><span class="comment"># touch /etc/cron.allow /etc/at.allow</span></span><br><span class="line"><span class="comment"># chmod og-rwx /etc/cron.allow</span></span><br><span class="line"><span class="comment"># chmod og-rwx /etc/at.allow</span></span><br><span class="line"><span class="comment"># chown root:root /etc/cron.allow</span></span><br><span class="line"><span class="comment"># chown root:root /etc/at.allow</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-5-内核"><a href="#3-5-内核" class="headerlink" title="3.5 内核"></a>3.5 内核</h2><h3 id="3-5-1-确保内核ASLR已启用"><a href="#3-5-1-确保内核ASLR已启用" class="headerlink" title="3.5.1 确保内核ASLR已启用"></a>3.5.1 确保内核ASLR已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>ASLR通过每次将栈的起始位置、函数库和程序本身移至略微不同的位置，使得缓冲溢出攻击无法猜测正确的位置，导致攻击无法成功实施。linux内核中ASLR分为0,1,2三级通过&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space文件配置查看，各级对应的效果：</p>
<p>0：不存在随机化，表示一切都将位于静态地址中</p>
<p>1：只有共享函数库、栈、mmap’ed 内存、VDSO以及堆是随机的</p>
<p>2：完全随机化。使用brk()进行的旧式内存配置也将是随机的</p>
<p>进程中栈的地址被随机化，降低缓冲溢出攻击的风险</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>输入以下命令并检查相应的命令返回是否为2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改randomize_va_space值为2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 2 &gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-确保dmesg访问权限配置正确"><a href="#3-5-2-确保dmesg访问权限配置正确" class="headerlink" title="3.5.2 确保dmesg访问权限配置正确"></a>3.5.2 确保dmesg访问权限配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>限制访问 dmesg 信息权限，无特权的用户无法查看系统信息，从而可以避免任何人从系统信息获取敏感信息，进而对系统进行攻击的行为。仅允许具有 CAP_SYSLOG 能力的进程查看内核日志信息。从而控制关键信息的最小权限，保障系统更加安全。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;sysctl.conf文件中是否已经配置相关字段，“kernel.dmesg_restrict&#x3D;1”表示已经设置dmesg的访问限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep kernel.dmesg_restrict /etc/sysctl.conf</span></span><br><span class="line">kernel.dmesg_restrict=1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>打开&#x2F;etc&#x2F;sysctl.conf文件，设置kernel.dmesg_restrict为1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line">kernel.dmesg_restrict=1</span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-确保正确配置内核参数kptr-restrict"><a href="#3-5-3-确保正确配置内核参数kptr-restrict" class="headerlink" title="3.5.3 确保正确配置内核参数kptr_restrict"></a>3.5.3 确保正确配置内核参数kptr_restrict</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>kptr_restrict的作用是保护内核符号地址，保护等级低时普通用户可以访问得到内核符号地址容易被攻击者利用，增加了攻击面降低了系统安全性。</p>
<p>当前kptr_restrict可以选择如下参数：</p>
<p>0：普通用户和带有CAP_SYSLOG特权的用户均可以读取（读取地址为内核符号地址经哈希运算后的值）。</p>
<p>1：只有带有CAP_SYSLOG特权的用户有读取权限（读取地址为内核符号实际地址），普通用户读取后内核符号地址打印为全零。</p>
<p>2：普通用户及带有CAP_SYSLOG特权的用户均无权限读取，读取后内核符号地址打印为全零。</p>
<p>考虑到易维护性、可定位性，openEuler发行版默认配置kptr_restrict参数为0，请根据实际场景按需配置。</p>
<p><strong>规则影响：</strong></p>
<p>普通用户无法获取内核符号地址。</p>
<p><strong>检查方法：</strong></p>
<p>输入以下命令并检查相应的命令返回值是否为1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl kernel.kptr_restrict</span></span><br><span class="line">kernel.kptr_restrict = 1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>建议设置kptr_restrict的值为1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/kptr_restrict</span></span><br></pre></td></tr></table></figure>

<p>或者修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl –p &#x2F;etc&#x2F;sysctl.conf：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.kptr_restrict=1</span><br></pre></td></tr></table></figure>
<h3 id="3-5-4-确保内核SMAP已启用"><a href="#3-5-4-确保内核SMAP已启用" class="headerlink" title="3.5.4 确保内核SMAP已启用"></a>3.5.4 确保内核SMAP已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>内核参数SMAP(Supervisor Mode Access Prevention，管理模式访问保护)，开启后禁止内核访问用户空间的数据。若不开启SMAP内核参数，攻击者可以利用通过内核态代码重定向的方式访问用户空间数据，增加了攻击面降低了系统安全性。</p>
<p>openEuler默认开启SMAP。</p>
<p><strong>规则影响：</strong></p>
<p>内核不能访问用户空间数据。</p>
<p><strong>检查方法：</strong></p>
<p>输入以下命令并检查是否有返回值，如果有返回值则说明cpu支持SMAP，反之则说明不支持SMAP：<br>注：仅X86架构支持SMAP特性（物理机、虚拟机均支持），其他架构可忽略该项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cpuinfo | grep &quot;smap&quot;</span></span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology cpuid tsc_known_freq pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap xsaveopt arat umip arch_capabilities</span><br></pre></td></tr></table></figure>

<p>通过检查启动参数检验是否开启SMAP，若有返回值则说明未开启，反之则说明开启。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cmdline | grep -i &quot;nosmap&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>若关闭了SMAP选项，需要编辑grub.cfg文件,在启动参数中删除nosmap选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /boot/efi/EFI/openEuler/grub.cfg</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-5-确保内核SMEP已启用"><a href="#3-5-5-确保内核SMEP已启用" class="headerlink" title="3.5.5 确保内核SMEP已启用"></a>3.5.5 确保内核SMEP已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>内核参数SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)，开启后禁止内核执行用户空间代码。若不开启SMEP内核参数，攻击者可以利用通过内核态代码重定向的方式执行用户空间代码，增加了攻击面降低了系统安全性。</p>
<p>openEuler默认开启SMEP。</p>
<p><strong>规则影响：</strong></p>
<p>内核不能执行用户空间代码。</p>
<p><strong>检查方法：</strong></p>
<p>输入以下命令并检查是否有返回值，如果有返回值则说明cpu支持SMEP，反之则说明不支持SMEP：<br>注：仅X86架构支持SMEP特性（物理机、虚拟机均支持），其他架构可忽略该项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cpuinfo | grep &quot;smep&quot;</span></span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology cpuid tsc_known_freq pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap xsaveopt arat umip arch_capabilities</span><br></pre></td></tr></table></figure>

<p>通过检查启动参数检验是否开启SMEP，若有返回值则说明未开启，反之则说明开启。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cmdline | grep -i &quot;nosmep&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>若关闭了SMEP选项，需要编辑grub.cfg文件,在启动参数中删除nosmep选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /boot/efi/EFI/openEuler/grub.cfg</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-6-禁止系统响应ICMP广播报文"><a href="#3-5-6-禁止系统响应ICMP广播报文" class="headerlink" title="3.5.6 禁止系统响应ICMP广播报文"></a>3.5.6 禁止系统响应ICMP广播报文</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>ICMP是网络控制消息协议，主要用于传递查询报文与差错报文，通过设置是否接受ICMP广播报文对ICMP报文攻击进行防护。</p>
<p>该参数决定设备是否要回应ICMP echo消息和时间戳请求，对这些消息和请求来说，目的地址就是广播地址。无论是哪台设备发送的报文，报文都会发送到网络上的每一台设备上去。如果源地址是伪造的，就可能会导致网络上所有的设备发送恶意的echo报文给受害者（被伪造地址的设备）。</p>
<p><strong>规则影响：</strong></p>
<p>系统不响应ICMP广播报文。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令并检查icmp_echo_ignore_broadcasts参数的返回值，如果icmp_echo_ignore_broadcasts参数返回值为1，表示系统禁止响应ICMP报文。如果icmp_echo_ignore_broadcasts参数返回值为0，表示系统未禁止响应ICMP报文。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.icmp_echo_ignore_broadcasts</span></span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为1，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置(值为1)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;net.ipv4.icmp_echo_ignore_broadcasts&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts=1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入命令禁止系统响应ICMP广播报文：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_broadcasts=1</span><br></pre></td></tr></table></figure>
<h3 id="3-5-7-禁止接收ICMP重定向报文"><a href="#3-5-7-禁止接收ICMP重定向报文" class="headerlink" title="3.5.7 禁止接收ICMP重定向报文"></a>3.5.7 禁止接收ICMP重定向报文</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>ICMP重定向消息是传递路由信息并告诉系统通过备用路径发送数据包。这是一种允许外部路由设备更新系统路由表的方法。通过将net.ipv4.conf.all.accept_redirects和net.ipv6.conf.all.accept_redirects设置为0，系统不会接受任何ICMP重定向报文。通过将net.ipv4.conf.all.secure_redirects和net.ipv4.conf.default.send_redirects设置为0，系统不会从网关接收ICMP重定向报文（IPv6无此配置项）。</p>
<p>攻击者可以利用伪造的ICMP重定向消息恶意更改系统路由表，使它们向错误的网络发送数据包，从而获取相应的敏感数据。</p>
<p><strong>规则影响：</strong></p>
<p>系统不接收ICMP重定向报文。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。输入命令查看返回值是否为0：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.conf.all.accept_redirects &amp;&amp; sysctl net.ipv6.conf.all.accept_redirects &amp;&amp; sysctl net.ipv4.conf.all.secure_redirects &amp;&amp; sysctl net.ipv4.conf.default.secure_redirects</span></span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv6.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.all.secure_redirects = 0</span><br><span class="line">net.ipv4.conf.default.seure_redirects = 0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为0，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置(值为0)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;net.ipv4.conf.all.accept_redirects&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.conf.all.accept_redirects=0</span><br><span class="line"><span class="comment"># grep &quot;net.ipv6.conf.all.accept_redirects&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv6.conf.all.accept_redirects=0</span><br><span class="line"><span class="comment"># grep &quot;net.ipv4.conf.all.secure_redirects&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">/etc/sysctl.conf:net.ipv4.conf.all.secure_redirects=0</span><br><span class="line">/etc/sysctl.d/99-sysctl.conf:net.ipv4.conf.all.secure_redirects=0</span><br><span class="line"><span class="comment"># grep &quot;net.ipv4.conf.default.secure_redirects&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">/etc/sysctl.conf:net.ipv4.conf.default.secure_redirects=0</span><br><span class="line">/etc/sysctl.d/99-sysctl.conf:net.ipv4.conf.default.secure_redirects=0</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入命令禁止接收ICMP重定向报文：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.all.accept_redirects=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv6.conf.all.accept_redirects=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.all.secure_redirects=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.default.secure_redirects=0</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_redirects=0</span><br><span class="line">net.ipv6.conf.all.accept_redirects=0</span><br><span class="line">net.ipv4.conf.all.secure_redirects=0</span><br><span class="line">net.ipv4.conf.default.secure_redirects=0</span><br></pre></td></tr></table></figure>
<h3 id="3-5-8-禁止转发ICMP重定向报文"><a href="#3-5-8-禁止转发ICMP重定向报文" class="headerlink" title="3.5.8 禁止转发ICMP重定向报文"></a>3.5.8 禁止转发ICMP重定向报文</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>ICMP重定向用于向其他主机发送路由信息。由于主机本身不充当路由器，因此没有必要转发ICMP重定向数据包。</p>
<p>攻击者可以利用受到攻击的主机向其他路由器设备发送无效的ICMP重定向，试图破坏路由，并让用户访问错误的系统。</p>
<p><strong>规则影响：</strong></p>
<p>系统不转发ICMP重定向报文。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令并检查send_redirects参数的返回值，如果send_redirects参数返回值为1，表示系统转发ICMP重定向报文。如果send_redirects参数返回值为0，表示系统不转发ICMP重定向报文。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.conf.all.send_redirects</span></span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br><span class="line"><span class="comment"># sysctl net.ipv4.conf.default.send_redirects</span></span><br><span class="line">net.ipv4.conf.default.send_redirects = 0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为0，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置(值为0)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;net.ipv4.conf.all.send_redirects&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.conf.all.send_redirects=0</span><br><span class="line"><span class="comment"># grep &quot;net.ipv4.conf.default.send_redirects&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.conf.default.send_redirects=0</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入命令禁止转发ICMP重定向报文：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.all.send_redirects=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.default.send_redirects=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.route.flush=1</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.send_redirects=0</span><br><span class="line">net.ipv4.conf.default.send_redirects=0</span><br></pre></td></tr></table></figure>
<h3 id="3-5-9-应当忽略所有ICMP请求"><a href="#3-5-9-应当忽略所有ICMP请求" class="headerlink" title="3.5.9 应当忽略所有ICMP请求"></a>3.5.9 应当忽略所有ICMP请求</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>通过忽略所有ICMP请求，禁止外界通过ping命令访问系统。</p>
<p>攻击者可以通过ping命令的返回来感知系统所处的网址位置。</p>
<p><strong>规则影响：</strong></p>
<p>系统忽略所有ICMP请求。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令并检查icmp_echo_ignore_all参数的返回值，如果icmp_echo_ignore_all参数返回值为1，表示系统忽略所有ICMP请求。如果icmp_echo_ignore_all参数返回值为0，表示系统响应ICMP请求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.icmp_echo_ignore_all</span></span><br><span class="line">net.ipv4.icmp_echo_ignore_all = 0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为1，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置(值为0)，建议用户在配置文件中添加正确配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;net.ipv4.icmp_echo_ignore_all&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入命令禁止转发ICMP重定向报文：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.icmp_echo_ignore_all=1</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_all=1</span><br></pre></td></tr></table></figure>
<h3 id="3-5-10-确保丢弃伪造的ICMP报文，不记录日志"><a href="#3-5-10-确保丢弃伪造的ICMP报文，不记录日志" class="headerlink" title="3.5.10 确保丢弃伪造的ICMP报文，不记录日志"></a>3.5.10 确保丢弃伪造的ICMP报文，不记录日志</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>将icmp_ignore_bogus_error_responses设置为1可以防止内核记录广播重复数据包的响应，从而避免文件系统填充无用的日志信息。</p>
<p>一些攻击者会发送违反RFC-1122的ICMP报文，并试图用大量无用的错误信息填充日志文件系统。</p>
<p><strong>规则影响：</strong></p>
<p>系统丢弃伪造的ICMP报文，不记录日志</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令并检查icmp_ignore_bogus_error_responses参数的返回值，如果icmp_ignore_bogus_error_responses参数返回值为1，表示系统忽略ICMP错误响应。如果icmp_ignore_bogus_error_responses参数返回值为0，表示系统处理ICMP错误响应。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.icmp_ignore_bogus_error_responses</span></span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为1，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置(值为1)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;net.ipv4.icmp_ignore_bogus_error_responses&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入丢弃伪造的ICMP报文规则的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.route.flush=1</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br></pre></td></tr></table></figure>
<h3 id="3-5-11-确保反向地址过滤已启用"><a href="#3-5-11-确保反向地址过滤已启用" class="headerlink" title="3.5.11 确保反向地址过滤已启用"></a>3.5.11 确保反向地址过滤已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>将net.ipv4.conf.all.rp_filter和net.ipv4.conf.default.rp_filter设置为1，强制Linux内核对接收到的数据包使用反向路径过滤，检查报文源地址的合法性，如果反查源地址的路由表，发现源地址下一跳的最佳出接口并不是收到报文的入接口，则将报文丢弃。</p>
<p>攻击者可以实施IP地址欺骗，在目前网络攻击中使用比较多。通过反向地址过滤在收到数据包时，取出源IP地址，然后查看该路由器的路由表中是否有该数据包的路由信息。如果路由表中没有其用于数据返回的路由信息，那么极有可能是某人伪造了该数据包，于是路由便把它丢弃。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令，检查rp_filter参数的返回值是否为1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.conf.all.rp_filter</span></span><br><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line"><span class="comment"># sysctl net.ipv4.conf.default.rp_filter</span></span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为1，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置(值为1)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;net.ipv4.conf.all.rp_filter&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line"><span class="comment"># grep &quot;net.ipv4.conf.default.rp_filter&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入启用反向地址过滤的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.all.rp_filter=1</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.default.rp_filter=1</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.route.flush=1</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br></pre></td></tr></table></figure>
<h3 id="3-5-12-禁止IP转发"><a href="#3-5-12-禁止IP转发" class="headerlink" title="3.5.12 禁止IP转发"></a>3.5.12 禁止IP转发</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>如果该结点不作为网关服务器，则应禁用IP转发功能。否则攻击者可将此系统作为路由器使用。</p>
<p>对于容器场景，如果容器内部需要通过宿主机转发网络报文，则可以例外。</p>
<p><strong>规则影响：</strong></p>
<p>系统不允许IP转发</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令并检查ip_forward参数的返回值，如果ip_forward参数返回值为0，表示禁用IP转发。如果ip_forward参数返回值为1，表示启用IP转发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line"><span class="comment"># sysctl net.ipv6.conf.all.forwarding</span></span><br><span class="line">net.ipv6.conf.all.forwarding = 0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为0，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置(值为0)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -E -s &quot;^\s*net\.ipv4\.ip_forward\s*=\s*1&quot; /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf</span></span><br><span class="line">无任何输出</span><br><span class="line"><span class="comment"># grep -E -s &quot;^\s*net\.ipv6\.conf\.all\.forwarding\s*=\s*1&quot; /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf</span></span><br><span class="line">无任何输出</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入禁止IP转发的命令并修改配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -Els &quot;^\s*net\.ipv4\.ip_forward\s*=\s*1&quot; /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf | while read filename; do sed -ri &quot;s/^\s*(net\.ipv4\.ip_forward\s*)(=)(\s*\S+\b).*$/# *REMOVED* \1/&quot; $filename; done; sysctl -w net.ipv4.ip_forward=0; sysctl -w net.ipv4.route.flush=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grep -Els &quot;^\s*net\.ipv6\.conf\.all\.forwarding\s*=\s*1&quot; /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf | while read filename; do sed -ri &quot;s/^\s*(net\.ipv6\.conf\.all\.forwarding\s*)(=)(\s*\S+\b).*$/# *REMOVED* \1/&quot; $filename; done; sysctl -w net.ipv6.conf.all.forwarding=0; sysctl -w net.ipv6.route.flush=1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-13-禁止报文源路由"><a href="#3-5-13-禁止报文源路由" class="headerlink" title="3.5.13 禁止报文源路由"></a>3.5.13 禁止报文源路由</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong></p>
<p>在网络中，源路由允许发送方部分或全部指定数据包通过网络的路由，而常规路由中，网络中的路由器根据数据包的目的地确定路径。大量报文被篡改后通过指定路由，则可以对内部网络进行定向攻击，可导致指定路由器负载过高，正常业务流量中断。</p>
<p>攻击者可以伪造一些合法的IP地址，通过合适的设置源路由选项及合法的路由器，蒙混进入网络。另外，如果允许源路由数据包，则通过构造中间路由地址，可以用于访问专用地址系统；如果攻击者对原始报文截取，并利用源路由进行地址欺骗，则可以强制指定回传的报文都通过攻击者的设备进行路由返回，这样攻击者就可以成功接收到双向的数据包。所以，应禁用报文源路由，减小攻击面。</p>
<p><strong>规则影响：</strong></p>
<p>系统禁用报文源路由</p>
<p><strong>检查方法：</strong></p>
<p>输入以下命令并检查相应的命令返回，如果返回值不为0，建议修改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.conf.all.accept_source_route</span></span><br><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line"><span class="comment"># sysctl net.ipv4.conf.default.accept_source_route</span></span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line"><span class="comment"># sysctl net.ipv6.conf.all.accept_source_route</span></span><br><span class="line">net.ipv6.conf.all.accept_source_route = 0</span><br><span class="line"><span class="comment"># sysctl net.ipv6.conf.default.accept_source_route</span></span><br><span class="line">net.ipv6.conf.default.accept_source_route = 0</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>输入禁止报文源路由的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.all.accept_source_route=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.default.accept_source_route=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv6.conf.all.accept_source_route=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv6.conf.default.accept_source_route=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.route.flush=1</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv6.route.flush=1</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv6.conf.all.accept_source_route = 0</span><br><span class="line">net.ipv6.conf.default.accept_source_route = 0</span><br></pre></td></tr></table></figure>
<h3 id="3-5-14-确保TCP-SYN-cookie保护已启用"><a href="#3-5-14-确保TCP-SYN-cookie保护已启用" class="headerlink" title="3.5.14 确保TCP-SYN cookie保护已启用"></a>3.5.14 确保TCP-SYN cookie保护已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>TCP-SYN cookie保护减轻了系统在遭受SYN Flooding攻击时受到的影响。</p>
<p>攻击者使用SYN泛洪攻击时，快速耗尽内核中半开连接队列，阻止合法连接。但启用SYN cookie，即使受到拒绝服务攻击仍允许系统继续接受合法连接。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令并检查tcp_syncookies参数的返回值，如果tcp_syncookies参数返回值为1，表示启用TCP-SYN cookie保护机制。如果tcp_syncookies参数返回值为0，表示未启用TCP-SYN cookie保护机制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.tcp_syncookies</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为1，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置（值为1）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^net.ipv4.tcp_syncookies&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.tcp_syncookies=1</span><br><span class="line">/etc/sysctl.d/99-sysctl.conf:net.ipv4.tcp_syncookies=1</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>启用保护，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.tcp_syncookies=1</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.route.flush=1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies=1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-15-应当记录仿冒、源路由以及重定向报文日志"><a href="#3-5-15-应当记录仿冒、源路由以及重定向报文日志" class="headerlink" title="3.5.15 应当记录仿冒、源路由以及重定向报文日志"></a>3.5.15 应当记录仿冒、源路由以及重定向报文日志</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>记录欺骗的包、源路由包和发给系统的重定向包有助于发现攻击源与制定防护措施。</p>
<p><strong>规则影响：</strong></p>
<p>开启后会记录带有不允许的地址的数据到内核日志中，存在冲日志风险。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令并检查log_martians参数的返回值，如果log_martians参数返回值为1，表示开启记录仿冒、源路由以及重定向报文日志。如果log_martians参数返回值为0，表示系统关闭记录机制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.conf.all.log_martians</span></span><br><span class="line">net.ipv4.conf.all.log_martians = 0</span><br><span class="line"><span class="comment"># sysctl net.ipv4.conf.default.log_martians</span></span><br><span class="line">net.ipv4.conf.default.log_martians = 0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为1，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置（值为0），建议用户在配置文件中添加正确配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^net.ipv4.conf.all.log_martians&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line"><span class="comment"># grep &quot;^net.ipv4.conf.default.log_martians&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>打开记录，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.all.log_martians=1</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.default.log_martians=1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.log_martians=1</span><br><span class="line">net.ipv4.conf.default.log_martians=1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-16-避免开启tcp-timestamps"><a href="#3-5-16-避免开启tcp-timestamps" class="headerlink" title="3.5.16 避免开启tcp_timestamps"></a>3.5.16 避免开启tcp_timestamps</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>tcp_timestamps用于记录TCP数据包的发送时间，可用于RTT测量（RTTM）和保护序号绕回（PAWS），是一个双向的选项，只有在客户端和服务端同时启用时才使能。启用该选项可能遭受拒绝服务攻击。</p>
<p><strong>规则影响：</strong></p>
<p>关闭此项会影响TCP在极端情况下超时重传的可靠性。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置，执行以下命令并检查tcp_timestamps参数的返回值，如果tcp_timestamps参数返回值为1，表示开启tcp_timestamps机制。如果参数返回值为0，表示关闭tcp_timestamps机制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.tcp_timestamps</span></span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为0，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置（默认值为1），建议用户在配置文件中添加正确配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^net.ipv4.tcp_timestamps&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>关闭tcp_timestamps，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.tcp_timestamps=0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps=0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-17-确保TIME-WAIT-TCP协议等待时间已配置"><a href="#3-5-17-确保TIME-WAIT-TCP协议等待时间已配置" class="headerlink" title="3.5.17 确保TIME_WAIT TCP协议等待时间已配置"></a>3.5.17 确保TIME_WAIT TCP协议等待时间已配置</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>TIME_WAIT是TCP协议等待连接销毁的时间，设置过长会导致存在大量未关闭的TCP连接，导致遭受拒绝服务攻击，建议配置不大于60。</p>
<p><strong>规则影响：</strong></p>
<p>TIME_WAIT时间设置过长会导致遭受拒绝服务攻击</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核中TIME_WAIT值的设置，执行以下命令并检查tcp_fin_timeout参数的返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.tcp_fin_timeout</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 60</span><br></pre></td></tr></table></figure>
<p>其次，执行如下命令，如果返回值与内核参数不一致，建议根据需求进行修改。如果返回值为空，表示系统使用默认配置（默认值为60）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^net.ipv4.tcp_fin_timeout&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>设置TIME_WAIT tcp协议等待时间，建议不大于60，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.tcp_fin_timeout=60</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout=60</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-18-应当正确配置SYN-RECV状态队列数量"><a href="#3-5-18-应当正确配置SYN-RECV状态队列数量" class="headerlink" title="3.5.18 应当正确配置SYN_RECV状态队列数量"></a>3.5.18 应当正确配置SYN_RECV状态队列数量</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SYN_RECV队列保存尚未获得对方确认的TCP连接请求，值越大表示可以容纳更多等待连接的网络连接数。如果配置值太小，容易被TCP SYN泛洪攻击，导致正常连接被拒绝服务；配置太大，则会消耗更多系统资源。建议队列数量设置为256。</p>
<p><strong>规则影响：</strong></p>
<p>从安全角度，建议配置较大值以消减TCP SYN泛洪攻击，但配置太大，则会消耗更多系统资源，对内存较小环境，可能会影响正常业务。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核中SYN_RECV队列数量的设置，执行以下命令并检查tcp_fin_timeout参数的返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.tcp_max_syn_backlog</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 256</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值与内核参数不一致，建议根据需求进行修改。如果返回值为空，表示系统使用默认配置（默认值为256）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^net.ipv4.tcp_max_syn_backlog&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog=256</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>设置SYN_RECV状态队列数量，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.tcp_max_syn_backlog=256</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog=256</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-19-禁止使用ARP代理"><a href="#3-5-19-禁止使用ARP代理" class="headerlink" title="3.5.19 禁止使用ARP代理"></a>3.5.19 禁止使用ARP代理</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>ARP代理允许系统代表连接到某个接口的主机向另一个接口上的ARP请求发送响应。禁用ARP代理不仅可以防止未经授权的信息共享还可以防止连接的网络区段之间寻址信息泄露。所以应关闭ARP代理以避免ARP报文攻击对系统造成影响。</p>
<p>openEuler默认禁止使用ARP代理，用户可根据业务需求进行配置。</p>
<p><strong>规则影响：</strong></p>
<p>依赖于ARP代理的程序执行受限制</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置，执行以下命令并检查proxy_arp参数的返回值，如果proxy_arp参数返回值为1，表示开启ARP代理。如果proxy_arp参数返回值为0，表示禁止使用ARP代理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl net.ipv4.conf.all.proxy_arp</span></span><br><span class="line">net.ipv4.conf.all.proxy_arp = 0</span><br><span class="line"><span class="comment"># sysctl net.ipv4.conf.default.proxy_arp</span></span><br><span class="line">net.ipv4.conf.default.proxy_arp = 0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为0，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置（值为0）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^net.ipv4.conf.all.proxy_arp&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line"><span class="comment"># grep &quot;^net.ipv4.conf.default.proxy_arp&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br></pre></td></tr></table></figure>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>关闭ARP代理的命令，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.all.proxy_arp=0</span></span><br><span class="line"><span class="comment"># sysctl -w net.ipv4.conf.default.proxy_arp=0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.conf.all.proxy_arp=0</span><br><span class="line">net.ipv4.conf.default.proxy_arp=0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-20-确保core-dump配置正确"><a href="#3-5-20-确保core-dump配置正确" class="headerlink" title="3.5.20 确保core dump配置正确"></a>3.5.20 确保core dump配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>Core dump是当程序运行过程中异常终止或崩溃时，把内存状态记录下来的行为，有助于事后定位，但可能会包含进程内存里的敏感信息。有时用户需要开启core dump功能记录当时产生问题的原因，对于需要开启core dump功能的用户需对日志输入的路径进行限制，同时需限制路径只允许特定用户访问。</p>
<p>启用core dump有助于程序异常终止或崩溃的事后定位，但容易泄露内存中的敏感信息。openEuler默认打开，用户需要根据业务场景，关闭core dump或对日志输入的路径和访问用户进行限制。</p>
<p><strong>规则影响：</strong></p>
<p>关闭core dump后，程序异常时缺少日志记录，不利于问题定位。</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>禁用场景的检查方法：</p>
<p>输入以下命令并检查相应的命令返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -c</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>或者检查文件&#x2F;etc&#x2F;security&#x2F;limits.conf，是否包含配置行“* hard core 0”。</p>
</li>
<li><p>限制场景的检查方法：</p>
<p>执行以下脚本成功返回（无内容输出），表示已限制了core dump目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">core_path=$(sysctl kernel.core_pattern | awk -F<span class="string">&quot;^[[:space:]]*kernel.core_pattern[[:space:]]*=[[:space:]]*&quot;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">[[ <span class="string">&quot;<span class="variable">$&#123;core_path&#125;</span>&quot;</span> =~ ^/.+ ]] || &#123; <span class="built_in">echo</span> <span class="string">&quot;kernel.core_pattern[<span class="variable">$&#123;core_path&#125;</span>] must be started with /&quot;</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line">core_dir=$(<span class="built_in">dirname</span> <span class="string">&quot;<span class="variable">$&#123;core_path&#125;</span>&quot;</span>)</span><br><span class="line">[[ -d <span class="string">&quot;<span class="variable">$&#123;core_dir&#125;</span>&quot;</span> ]] || &#123; <span class="built_in">echo</span> <span class="string">&quot;kernel.core_pattern dir[<span class="variable">$&#123;core_dir&#125;</span>] not exist&quot;</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line">rights_digit=$(<span class="built_in">stat</span> -c%a <span class="string">&quot;<span class="variable">$&#123;core_dir&#125;</span>&quot;</span>)</span><br><span class="line">[[ <span class="string">&quot;<span class="variable">$&#123;rights_digit&#125;</span>&quot;</span> =~ ^700$ || <span class="string">&quot;<span class="variable">$&#123;rights_digit&#125;</span>&quot;</span> =~ ^1770$ || <span class="string">&quot;<span class="variable">$&#123;rights_digit&#125;</span>&quot;</span> =~ ^1777$ ]] || &#123; <span class="built_in">echo</span> <span class="string">&quot;rights[<span class="variable">$&#123;rights_digit&#125;</span>] of dir[<span class="variable">$&#123;core_dir&#125;</span>] not safe, must be 700 or 1770 or 1777&quot;</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>禁用方法</p>
<p>使用如下命令对当前会话禁止系统支持生成core dump</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -c 0</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;security&#x2F;limits.conf文件，添加或修改配置，使其永久生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* hard core 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制使用方法：<br>1、ulimit -c不为0，比如：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -c 10485760</span></span><br></pre></td></tr></table></figure>

<p>2、设置core dump日志文件保存位置和文件格式<br>  通过修改&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern可以控制core dump日志文件保存位置和文件格式。<br>  下例为将所有的core dump日志文件生成到&#x2F;corefiles目录下（绝对路径），文件名的格式为core-命令名-pid-时间戳：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl &quot;kernel.core_pattern=/corefiles/core-%e-%p-%t&quot;</span></span><br></pre></td></tr></table></figure>

<p>  修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.core_pattern=/corefiles/core-%e-%p-%t</span><br></pre></td></tr></table></figure>

<p>  建议为&#x2F;corefiles建立独立分区，禁止&#x2F;corefiles目录占用系统分区或业务分区，避免因为core dump日志文件过多导致分区满而影响系统运行或业务运行。</p>
<p>3、限制目录访问权限：<br>  可根据业务需要限制目录的访问用户范围。<br>  a、限制单个用户（比如admin）访问</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown admin /corefiles</span></span><br><span class="line"><span class="comment"># chmod 700 /corefiles</span></span><br></pre></td></tr></table></figure>

<p>  b、使用粘滞位保护技术，限制同组用户（比如core_group）访问</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown root:core_group /corefiles</span></span><br><span class="line"><span class="comment"># chmod 1770 /corefiles</span></span><br></pre></td></tr></table></figure>

<p>  c、使用粘滞位保护技术，限制所有用户访问：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chown root:root /corefiles</span></span><br><span class="line"><span class="comment"># chmod 1777 /corefiles</span></span><br></pre></td></tr></table></figure>

<p>  注：粘滞位对目录的作用，使得目录下A用户不能访问B用户的文件，除非B用户的文件权限允许A用户访问。</p>
<p>4、建议禁止setuid的应用支持生成core dump：<br>  使用如下命令对当前运行系统禁止setuid的应用支持生成core dump</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w &quot;fs.suid_dumpable=0&quot;</span></span><br></pre></td></tr></table></figure>

<p>  修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，使其永久生效</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.suid_dumpable=0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-21-禁止使用SysRq键"><a href="#3-5-21-禁止使用SysRq键" class="headerlink" title="3.5.21 禁止使用SysRq键"></a>3.5.21 禁止使用SysRq键</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SysRq使得具有物理访问的用户能够访问计算机中危险的系统级命令，需要对SysRq的功能使用进行限制。</p>
<p>如果没有禁用SysRq键，则可以通过键盘触发SysRq的调用，可能造成直接发送命令到内核，对系统造成影响。</p>
<p>openEuler默认禁止使用SysRq键。</p>
<p><strong>规则影响：</strong></p>
<p>系统下sysRq相关命令无法使用</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置。执行以下命令，如果sysrq参数返回值为0，表示禁用SysRq键。否则，表示配置不正确，建议修改配置文件内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/kernel/sysrq</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为0，表示配置不正确，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置（值为0）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^kernel.sysrq&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br><span class="line">/etc/sysctl.conf:kernel.sysrq=0</span><br><span class="line">/etc/sysctl.d/99-sysctl.conf:kernel.sysrq=0</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>禁用SysRq，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 0 &gt; /proc/sys/kernel/sysrq</span></span><br></pre></td></tr></table></figure>
<p>  或</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w kernel.sysrq=0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq=0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-22-应当正确配置内核参数ptrace-scope"><a href="#3-5-22-应当正确配置内核参数ptrace-scope" class="headerlink" title="3.5.22 应当正确配置内核参数ptrace_scope"></a>3.5.22 应当正确配置内核参数ptrace_scope</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>ptrace是一种系统调用用于进程跟踪，提供了父进程可以观察并控制子进程的能力。Linux Kernel 3.4以及更高版本支持完全限制或禁用ptrace功能，根据Linux Kernel Yama Documentation，ptrace_scope可以选择如下参数：</p>
<p>0：进程可以将PTRACE_ATTACH传递给任何其他进程，只要它是可转储的（即没有转换uid，没有特权启动或没有调用prctl）。</p>
<p>1：进程如果要调用PTRACE_ATTACH，必须有预先的定义关系。默认情况下满足上述条件时，预定义的关系仅为子进程的关系。若要改变关系，子进程可以调用prctl调整这种关系。</p>
<p>2：只有具有CAP_SYS_PTRACE的进程通过PTRACE_ATTACH或通过子进程调用PTRACE_TRACEME才能使用ptrace。</p>
<p>3：任何进程都不能将ptrace与PTRACE_ATTACH一起使用，也不能通过PTRACE_TRACEME使用。</p>
<p>openEuler默认参数为0，用户可根据实际使用场景进行配置，建议配置值为2。</p>
<p><strong>规则影响：</strong></p>
<p>该参数的配置将影响ptrace的使用，当配置参数为2时，只有CAP_SYS_PTRACE的进程才能使用ptrace，这样会有效防止攻击者恶意提权，但同时会导致用户ptrace部分功能受到影响。</p>
<p><strong>检查方法：</strong></p>
<p>首先，检查当前系统内核参数的设置，执行以下命令并检查log_martians参数的返回值与业务场景需求是否一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl kernel.yama.ptrace_scope</span></span><br><span class="line">kernel.yama.ptrace_scope = 0</span><br></pre></td></tr></table></figure>

<p>其次，执行如下命令，如果返回值不为2，建议修改配置文件内容。如果返回值为空，表示系统使用默认配置（值为0），建议用户在配置文件中添加正确配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^kernel.yama.ptrace_scope&quot; /etc/sysctl.conf /etc/sysctl.d/*</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>设置ptrace_scope的值，可使用如下命令临时设置，重启后恢复默认值：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 2 &gt; /proc/sys/kernel/yama/ptrace_scope</span></span><br></pre></td></tr></table></figure>
<p>  或</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sysctl -w kernel.randomize_va_space=2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件，添加或修改配置，并执行# sysctl -p &#x2F;etc&#x2F;sysctl.conf，使其永久生效：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.yama.ptrace_scope=2</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5-23-应当启用seccomp"><a href="#3-5-23-应当启用seccomp" class="headerlink" title="3.5.23 应当启用seccomp"></a>3.5.23 应当启用seccomp</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>seccomp（全称：secure computing mode），在刚引入linux内核时，将进程可用的系统调用限制为四种：read，write，_exit，sigreturn。最初的这种白名单方式，除了已打开的文件描述符允许的四种系统调用，如果尝试其他系统调用，内核就会使用SIGKILL或SIGSYS终止该进程。</p>
<p>白名单方式由于限制太强，实际作用并不大，在实际应用中需要更加精细的限制，为了解决此问题，引入了BPF。seccomp和BPF规则的结合，它允许用户使用可配置的策略过滤系统调用，该策略使用Berkeley Packet Filter规则实现，它可以对任意系统调用及其参数进行过滤。</p>
<p>openEuler内核默认已经提供seccomp功能支持，同时提供了libseccomp外围包，帮助用户态程序可以方便的设置seccomp规则。</p>
<p><strong>规则影响：</strong></p>
<p>seccomp并不能全局设置启闭或规则，而是针对于每一个进程的，也就是进程可以自己设置启用seccomp，作用于自身以及所有子线程，但不影响其他进程。</p>
<p>如果进程启用了seccomp，在进行系统调用时会有性能损失，用户需要根据实际业务场景确定性能损失是否可接受。</p>
<p><strong>检查方法：</strong></p>
<p>检查目标进程是否启用了seccomp模式，此处以检查test_seccomp进程为例，首先确定进程号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -aux | grep &quot;test_seccomp&quot; </span></span><br><span class="line">root  [PID_num]  0.0  0.0   2688   976 pts/0    S    12:35   0:00 ./test_seccomp</span><br></pre></td></tr></table></figure>

<p>根据获取的pid号查询进程是否启用了seccomp功能，若返回值为0代表未开启seccomp功能，1代表开启seccomp STRICT模式，2则代表该进程启用了seccomp FILTER模式。如果用户需要开启seccomp FILTER模式，则建议用户根据实际业务场景设置合理的规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/[pid]/status | grep &quot;Seccomp&quot;</span></span><br><span class="line">Seccomp:        2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>可以在业务进程中通过调用libseccomp接口进行seccomp相关规则的配置，具体配置方法，可以参考libseccomp的开源帮助文档。</p>
<h2 id="3-6-时间同步"><a href="#3-6-时间同步" class="headerlink" title="3.6 时间同步"></a>3.6 时间同步</h2><h3 id="3-6-1-应当正确配置ntpd服务"><a href="#3-6-1-应当正确配置ntpd服务" class="headerlink" title="3.6.1 应当正确配置ntpd服务"></a>3.6.1 应当正确配置ntpd服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>集群场景下，服务器时间是否准确、是否一致比较关键。例如当时间不一致时，可能会导致不同服务器间产生的数据，在根据时间进行排序或比较时，产生的结果不准确。</p>
<p>即使我们在初始时使用date命令把所有服务器时间配置成一致的，随着时间的推移，服务器的时间还是会出现不准确、不一致。所以为保证环境中所有机器的时间同步且准确，必须有一个可以同步的时间服务器，网络内的其他服务器都向该服务器进行时间同步。</p>
<p>当使用ntpd服务实现时间同步时，如果没有正确配置ntpd服务，则服务器时间可能不准确，导致不同服务器间的时间可能不一致。</p>
<p>服务器时间不准确时，对于类似财务、订单等时间敏感的数据会有很大问题。例如因为时间不准确可能导致一笔记账数据落在了错误的财务周期，从而导致资产负债表期末余额不平。</p>
<p>服务器之间的时间不一致时，每个主机产生的报文的时间就存在偏差，如果多个服务器间数据流存在一定处理顺序，后一个环节的服务器时间小于前一个服务器的时间时，可能会导致收到的报文因为时间大于本地时间而丢弃。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>检查ntpd服务是否启动，Active字段返回“active (running)”表示服务已经启动，返回“inactive (dead)”表示未启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ntpd status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">   Active: inactive (dead)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过grep命令查看&#x2F;etc&#x2F;ntp.conf中restrict的配置，获取ntp权限控制配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^restrict&quot; /etc/ntp.conf </span></span><br><span class="line">restrict default nomodify notrap nopeer noquery</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过grep命令查看&#x2F;etc&#x2F;ntp.conf中server|pool的配置（<IP or domain name>表示具体的服务器IP或域名），获取ntp服务器配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -E &quot;^(server|pool)&quot; /etc/ntp.conf</span></span><br><span class="line">server &lt;IP or domain name&gt; iburst</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>将本机配置为时间源，在&#x2F;etc&#x2F;ntp.conf文件中增加ntp权限控制配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ntp.conf </span></span><br><span class="line">restrict &lt;IP or netmask_IP&gt; &lt;parameter&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>IP or netmask_IP：权限控制的IP地址，可以是default表示所有IP；可以是不带mask的某一个具体IP地址，例如“192.168.1.2”；也可以是IP+mask表示某一段IP地址，例如“192.168.0.0 mask 255.255.255.0”，表示192.168.0.1至192.168.0.154的所有地址的服务器都可以连接本服务器获取ntp服务。</li>
<li>Parameter：权限控制的具体参数。</li>
</ul>
<p>例如：restrict default nomodify notrap nopeer noquery，表示允许所有IP地址的服务器与本机时间源进行时间同步，但不允许在此系统上查询或修改服务。</p>
</li>
<li><p>本机作为客户端，配置时间源服务器（remote-server为远端时间源服务器地址），在&#x2F;etc&#x2F;ntp.conf文件中增加配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ntp.conf </span></span><br><span class="line">server &lt;remote-server&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在进行前两项配置后（可以同时配置，既作为客户端从远端服务器获取授时，也作为服务端，给其他服务器授时），使用service ntpd restart命令重启ntpd服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service ntpd restart</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-6-2-应当正确配置chronyd服务"><a href="#3-6-2-应当正确配置chronyd服务" class="headerlink" title="3.6.2 应当正确配置chronyd服务"></a>3.6.2 应当正确配置chronyd服务</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>授时服务器配置不正确，可能导致本地服务器时间同周边其他服务器不同步，同标准时间不同步，对于一些强依赖于时间同步的服务，如市场交易等，可能造成业务中断、错误，甚至被攻击者利用时间差进行数据篡改、伪造。</p>
<p>chrony是一个开源的自由软件，同传统NTP服务一样，它能保持系统时钟与授时服务器同步，让时间保持精确，由两个程序组成：chronyd和chronyc。</p>
<p>chronyd是一个后台运行的守护进程，用于调整内核中运行的系统时钟和授时服务器同步，它确定计算机增减时间的比率，并对此进行补偿。</p>
<p>chronyc提供了一个用户界面，用于监控性能并进行多样化的配置，它可以在运行chronyd服务的计算机上工作，也可以在一台不同的远程计算机上工作。</p>
<p>如果根据业务场景选择使用chronyd作为时间同步服务，需正确配置远端授时服务器并启用chronyd服务。</p>
<p>chrony同NTP可互相替换，openEuler默认启用chronyd服务。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>使用grep命令查看&#x2F;etc&#x2F;chrony.conf文件中是否正确配置了授时服务器地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^server\|^pool&quot; /etc/chrony.conf</span></span><br><span class="line">server &lt;IP address&gt;</span><br><span class="line">pool &lt;IP address&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ps命令查看是否已启动chronyd服务，如果返回“&#x2F;usr&#x2F;sbin&#x2F;chronyd”进程，表示已经启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -ef | grep chronyd</span></span><br><span class="line">chrony   1569550       1  0 18:39 ?        00:00:00 /usr/sbin/chronyd</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>修改&#x2F;etc&#x2F;chrony.conf文件，在pool或server字段添加正确的授时服务器地址，如果有多个授时服务器，可以按照优先顺序配置多条：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/chrony.conf</span></span><br><span class="line">server &lt;IP address&gt;</span><br><span class="line">server &lt;IP address&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用service命令启动chronyd服务，并查看服务启动状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service chronyd start</span></span><br><span class="line">Redirecting to /bin/systemctl start chronyd.service</span><br><span class="line"><span class="comment"># service chronyd status 2&gt;&amp;1 | grep Active</span></span><br><span class="line">   Active: active (running) since Tue 2020-12-01 14:47:49 CST; 1min 6s ago</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-日志审计"><a href="#4-日志审计" class="headerlink" title="4 日志审计"></a>4 日志审计</h2><h2 id="4-1-Audit"><a href="#4-1-Audit" class="headerlink" title="4.1 Audit"></a>4.1 Audit</h2><h3 id="4-1-1-确保auditd审计已启用"><a href="#4-1-1-确保auditd审计已启用" class="headerlink" title="4.1.1 确保auditd审计已启用"></a>4.1.1 确保auditd审计已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>auditd组件是Linux审计框架的用户空间组件，auditd组件提供了auditctl、ausearch、aureport三个程序完成审计和查看日志功能。配置审计规则是通过auditctl程序完成的，该程序启动时从&#x2F;etc&#x2F;audit&#x2F;audit.rules读取这些规则。后台程序本身可以通过设置&#x2F;etc&#x2F;audit&#x2F;auditd.conf 文件来进行定制。其他两个组件分别是audispd和autrace。audispd用于给其他应用发送事件通知，而autrace则通过与strace类似的方式对系统调用进行追踪。系统中一些文件是非常重要的，是不可以轻意修改的，对于这类文件使用auditd组件对其进行审计是非常有必要的。</p>
<p>openEuler默认要求启用audit审计功能。</p>
<p><strong>规则影响：</strong> </p>
<p>审计系统提供了一种记录系统安全信息的方法，为系统管理员在用户违反系统规则时提供及时的警告信息，但启用后对性能有一定影响。</p>
<p><strong>检查方法：</strong></p>
<p>执行如下命令，查看auditd.service服务默认状态是否为enable</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled auditd.service</span></span><br><span class="line">enabled</span><br></pre></td></tr></table></figure>
<p>执行如下命令，查看auditd.service服务当前是否已经启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl status auditd.service | grep active</span></span><br><span class="line">Active: active (running) since Fri 2023-10-13 08:00:00 CST; 2 days ago</span><br></pre></td></tr></table></figure>
<p><strong>修复方法：</strong></p>
<p>使能并启动auditd.service：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl enable auditd.service</span></span><br><span class="line"><span class="comment"># systemctl start auditd.service</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-确保审计日志rotate已启用"><a href="#4-1-2-确保审计日志rotate已启用" class="headerlink" title="4.1.2 确保审计日志rotate已启用"></a>4.1.2 确保审计日志rotate已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>max_log_file_action用于配置日志文件到达大小上限时该如何处理，openEuler默认配置ROTATE，表示单个文件写满后会重新创建日志文件进行记录，不会删除原先的日志文件。</p>
<p>num_logs表示基于ROTATE机制，最多可以创建多少个日志文件，如果日志文件数量达到上限，则会依次覆盖最早创建的文件。openEuler默认配置为5。</p>
<p>num_logs取值范围为0~99，其中0和1表示不做rotate。</p>
<p>max_log_file_action一共有5种可选配置项：</p>
<p>IGNORE：表示忽略日志文件大小上限，继续在该文件上记录日志。</p>
<p>SYSLOG：同IGNORE类似，只是达到上限时会记录一条syslog日志。</p>
<p>SUSPEND：达到日志文件大小上限，auditd服务进程停止日志记录。</p>
<p>ROTATE：达到日志文件大小上限，新建日志文件继续记录，如果文件数达到num_logs，则覆盖旧文件。</p>
<p>KEEP_LOGS：同ROTATE类似，只是不受num_logs限制，会一直新建文件。</p>
<p><strong>规则影响：</strong></p>
<p>rotate会按照配置，在日志文件达到写入上限之后依次覆盖最早创建的文件。</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令检查当前配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -iE &quot;max_log_file_action|num_logs&quot; /etc/audit/auditd.conf</span></span><br><span class="line">num_logs = 5</span><br><span class="line">max_log_file_action = ROTATE</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;audit&#x2F;auditd.conf文件中max_log_file_action和num_logs字段的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/auditd.conf</span></span><br><span class="line">num_logs = &lt;file numbers&gt;</span><br><span class="line">max_log_file_action = &lt;action <span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-应当配置登录审计规则"><a href="#4-1-3-应当配置登录审计规则" class="headerlink" title="4.1.3 应当配置登录审计规则"></a>4.1.3 应当配置登录审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>用户成功登录时会在&#x2F;var&#x2F;log&#x2F;lastlog文件中刷新记录，所以只要对该文件进行审计监控，就可以记录用户登录事件。如果不配置登录审计，管理员无法从audit日志中追溯登录事件。</p>
<p>openEuler默认不配置登录审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置登录审计，由于在文件操作时需要记录审计日志，对性能有轻微影响，但由于登录动作本身不应快速、频繁发生，用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>通过执行如下指令，检查用户登录的审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;lastlog&quot;</span></span><br><span class="line">-w /var/log/lastlog -p wa -k logins</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如logins.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/logins.rules</span></span><br><span class="line">-w /var/log/lastlog -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4-应当配置账号信息修改审计规则"><a href="#4-1-4-应当配置账号信息修改审计规则" class="headerlink" title="4.1.4 应当配置账号信息修改审计规则"></a>4.1.4 应当配置账号信息修改审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>通常情况下，业务部署完成后，用户账号、用户组已经固定，不会变更，口令由于有效期的缘故，会定期修改，但也不频繁。建议对这些认证授权关键数据进行审计监控，如果有变更，事后也可进行追溯。修改账号、用户组、口令等行为，在攻击行为中比较常见，建议配置审计规则，以便事后追溯。</p>
<p>openEuler默认不配置账号信息修改审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在操作对应配置文件时需要进行审计日志记录，对性能有轻微影响，但对用户账号、用户组以及口令的修改应不频繁，实际对用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下命令，检查修改账号信息的审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;passwd|group|shadow&quot;</span></span><br><span class="line">-w /etc/group -p wa -k usermgn</span><br><span class="line">-w /etc/passwd -p wa -k usermgn</span><br><span class="line">-w /etc/gshadow -p wa -k usermgn</span><br><span class="line">-w /etc/shadow -p wa -k usermgn</span><br><span class="line">-w /etc/security/opasswd -p wa -k usermgn</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如usermgn.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/usermgn.rules</span></span><br><span class="line">-w /etc/group -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /etc/passwd -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /etc/gshadow -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /etc/shadow -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /etc/security/opasswd -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-5-应当配置提权命令审计规则"><a href="#4-1-5-应当配置提权命令审计规则" class="headerlink" title="4.1.5 应当配置提权命令审计规则"></a>4.1.5 应当配置提权命令审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>普通用户通过调用提权命令（设置了SUID&#x2F;SGID）可以获得超级管理员权限，所以提权命令的使用具有较高风险，往往被攻击者利用用于对系统进行攻击行为。</p>
<p>建议对提权命令进行审计监控，以便事后追溯。</p>
<p>openEuler默认不配置提权命令审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在使用提权命令时需要进行审计日志记录，对性能有轻微影响，如果用户业务存在大量、频繁调用提权命令的场景，则可能存在累积效果。</p>
<p><strong>检查方法：</strong></p>
<p>使用如下脚本检查提权命令的审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array=`find / -xdev -<span class="built_in">type</span> f \( -perm -4000 -o -perm -2000 \) | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ret=`auditctl -l | grep <span class="string">&quot;<span class="variable">$element</span> &quot;</span>`</span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$element</span> not set&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$ret</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>如果系统中提权命令已经配置audit策略，则该脚本执行后打印出对应策略行，如果未配置，则打印出“&lt;file path&gt; not set”字样，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sh check.sh</span></span><br><span class="line">/root/test.sh not <span class="built_in">set</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/write -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/pkexec -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/fusermount -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/at -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/newgidmap -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/wall -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/newuidmap -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/libexec/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/libexec/dbus-1/dbus-daemon-launch-helper -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/libexec/utempter/utempter -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/lib/polkit-1/polkit-agent-helper-1 -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/sbin/mount.nfs -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br><span class="line">-a always,<span class="built_in">exit</span> -S all -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=-1 -F key=privileged</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>通过如下方法，查找系统中所有可提权（SUID&#x2F;SGID）命令，并按照配置格式输出到&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;privileged.rules文件中，此处&lt;min uid&gt;是&#x2F;etc&#x2F;login.defs文件中UID_MIN的值，openEuler上可设置为1000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -xdev -type f \( -perm -4000 -o -perm -2000 \) | awk &#x27;&#123;print &quot;-a always,exit -F path=&quot; $1 &quot; -F perm=x -F auid&gt;=&lt;min uid&gt; -F auid!=unset -k &lt;rules name&gt;&quot; &#125;&#x27; &gt; /etc/audit/rules.d/privileged.rules</span></span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-6-应当配置内核模块变更审计规则"><a href="#4-1-6-应当配置内核模块变更审计规则" class="headerlink" title="4.1.6 应当配置内核模块变更审计规则"></a>4.1.6 应当配置内核模块变更审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>通常情况下，业务部署完成后，内核模块挂载已经固定，不会变更。如果发生变更，可能存在攻击行为，建议对内核模块变更进行审计监控，事后也可进行追溯。</p>
<p>openEuler默认不配置内核模块变更审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在内核模块挂载、卸载时需要进行审计日志记录，对性能有轻微影响，但内核模块挂载、卸载相关操作应不频繁，实际对用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>如果是32位系统，通过如下命令检查内核模块变更的审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;insmod|rmmod|modprobe|init_module|delete_module&quot;</span></span><br><span class="line">-w /sbin/insmod -p x -k module</span><br><span class="line">-w /sbin/rmmod -p x -k module</span><br><span class="line">-w /sbin/modprobe -p x -k module</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S init_module,delete_module -F key=module</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，还需有如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S init_module,delete_module -F key=module</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果是32位系统，在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如module.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/module.rules</span></span><br><span class="line">-w /sbin/insmod -p x -k &lt;rules name&gt;</span><br><span class="line">-w /sbin/rmmod -p x -k &lt;rules name&gt;</span><br><span class="line">-w /sbin/modprobe -p x -k &lt;rules name&gt;</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S init_module -S delete_module -k &lt;rules name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是64位系统，需要再添加arch&#x3D;b64相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S init_module -S delete_module -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，64位系统中arch&#x3D;b32相关配置必须保留。 </p>
<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>

<h3 id="4-1-7-应当配置管理员特权操作审计规则"><a href="#4-1-7-应当配置管理员特权操作审计规则" class="headerlink" title="4.1.7 应当配置管理员特权操作审计规则"></a>4.1.7 应当配置管理员特权操作审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>openEuler系统中sudo提取命令操作日志默认记录在&#x2F;var&#x2F;log&#x2F;secure日志文件中，该文件中还记录有其他认证相关的安全日志，如果用户希望对sudo提取命令进行audit审计，建议将sudo相关日志单独记录，输出到&#x2F;var&#x2F;log&#x2F;sudo.log中，然后再对sudo日志文件进行审计监控。sudo提权属于高危操作，在攻击行为中比较常见，建议配置审计规则，以便事后追溯。</p>
<p>openEuler默认不配置管理员特权操作审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在进行任何sudo提权操作时都需要进行审计日志记录，对性能有轻微影响，如果用户业务场景中存在大量、频繁的sudo操作，对性能影响有累积效果。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下命令检查管理员特权操作的审计规则，其中sudo输出日志路径根据实际配置情况可能有变化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;sudo\.log&quot;</span></span><br><span class="line">-w /var/log/sudo.log -p wa -k sudoaction</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;sudoers文件，配置sudo日志独立记录到&#x2F;var&#x2F;log&#x2F;sudo.log文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br><span class="line">Defaults logfile=/var/log/sudo.log</span><br></pre></td></tr></table></figure>

<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如sudoaction.rules，在文件中添加审计规则，此处审计的文件“&#x2F;var&#x2F;log&#x2F;sudo.log”必须是&#x2F;etc&#x2F;sudoers中配置的日志输出文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/audit/rules.d/sudoaction.rules</span><br><span class="line">-w /var/log/sudo.log -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-8-应当在启动阶段启用auditd"><a href="#4-1-8-应当在启动阶段启用auditd" class="headerlink" title="4.1.8 应当在启动阶段启用auditd"></a>4.1.8 应当在启动阶段启用auditd</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>在启动阶段启用auditd，可以对操作系统启动过程中，auditd服务完成启动前的事件进行审计。启动过程中如果不启用审计，如果攻击者在启动过程中添加一些攻击行为，可能就无法被审计到。</p>
<p>openEuler默认不配置，建议用户可根据实际场景，确定是否在内核启动参数中添加“audit&#x3D;1”字段，以便在操作系统启动阶段使能审计功能。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>执行如下命令，查看内核启动参数中是否已经添加“audit&#x3D;1”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cmdline | grep &quot;audit=1&quot;</span></span><br><span class="line">BOOT_IMAGE=/vmlinuz-&lt;kernel version&gt; root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M quiet audit=1 </span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>修改grub.cfg文件，直接在对应内核启动参数后面添加，需要注意的是，grub.cfg文件所在目录根据系统安装配置会有不同，大部分情况存在于&#x2F;boot&#x2F;grub2&#x2F;或&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;openeuler&#x2F;目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /boot/efi/EFI/openeuler/grub.cfg</span></span><br><span class="line">linuxefi	/vmlinuz-&lt;kernel version&gt; root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M quiet audit=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者修改配置文件&#x2F;etc&#x2F;default&#x2F;grub，在GRUB_CMDLINE_LINUX字段添加“audit&#x3D;1”，然后重新生成grub.cfg文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/default/grub</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;/dev/mapper/openeuler-swap rd.lvm=openeuler/root rd.lvm.lv=openeuler/swap crashkernel quiet audit=1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改后重启系统生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reboot</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-1-9-应当正确配置audit-backlog-limit"><a href="#4-1-9-应当正确配置audit-backlog-limit" class="headerlink" title="4.1.9 应当正确配置audit_backlog_limit"></a>4.1.9 应当正确配置audit_backlog_limit</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>audit_backlog_limit用于限制audit事件在发往auditd服务进行处理之前在内核中的缓存队列的大小，该值默认为64，如果队列满，则开始丢弃audit事件，并打印告警日志，提示队列满。如果该值配置过小，则可能导致audit事件丢失。</p>
<p>如果在操作系统启动阶段已经配置了启用auditd，则建议将audit_backlog_limit适当配置为较大值，因为内核启动过程中auditd服务尚未启动，此时所有事件都是通过队列缓存的。</p>
<p>openEuler默认不配置，建议用户根据实际场景，设置audit_backlog_limit参数的大小。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>执行如下命令，查看内核启动参数中是否已经添加“audit_backlog_limit&#x3D;&lt;size&gt;”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cmdline | grep &quot;audit_backlog_limit&quot;</span></span><br><span class="line">BOOT_IMAGE=/vmlinuz-&lt;kernel version&gt; root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M quiet audit=1 audit_backlog_limit=8192</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<ul>
<li><p>修改grub.cfg文件，直接在对应内核启动参数后面添加，需要注意的是，grub.cfg文件所在目录根据系统安装配置会有不同，大部分情况存在于&#x2F;boot&#x2F;grub2&#x2F;或&#x2F;boot&#x2F;efi&#x2F;EFI&#x2F;openEuler&#x2F;目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /boot/grub2/grub.cfg</span></span><br><span class="line">linuxefi	/vmlinuz-&lt;kernel version&gt; root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M quiet audit=1 audit_backlog_limit=&lt;size&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者修改配置文件&#x2F;etc&#x2F;default&#x2F;grub，在GRUB_CMDLINE_LINUX字段添加“audit_backlog_limit&#x3D;&lt;size&gt;”，然后重新生成grub.cfg文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/default/grub</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;/dev/mapper/openeuler-swap rd.lvm=openeuler/root rd.lvm.lv=openeuler/swap crashkernel quiet audit=1 audit_backlog_limit=&lt;size&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改后重启系统生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reboot</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-1-10-避免使用auditctl设置auditd规则"><a href="#4-1-10-避免使用auditctl设置auditd规则" class="headerlink" title="4.1.10 避免使用auditctl设置auditd规则"></a>4.1.10 避免使用auditctl设置auditd规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>auditd服务规则可以在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下的规则文件中配置后，重启服务器生效，也可以通过auditctl命令设置，并立即生效。&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录权限为750，而auditctl权限为755，所以禁止通过auditctl命令修改auditd服务规则，可以缩小攻击面，防止低权限攻击者通过命令行修改规则并立即实施攻击行为。</p>
<p>openEuler，默认不禁止通过auditctl命令修改auditd服务规则，建议用户根据业务场景，禁用auditctl方式设置。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过grep命令，检查&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下是否存在特定的rules文件，包含有“-e 2”字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;-e 2&quot; /etc/audit/rules.d/*.rules</span></span><br><span class="line">/etc/audit/rules.d/immutable.rules:-e 2</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建以.rules为后缀的规则文件（可随意命名），添加“-e 2”字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/immutable.rules</span></span><br><span class="line">-e 2</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-11-确保日志大小限制配置正确"><a href="#4-1-11-确保日志大小限制配置正确" class="headerlink" title="4.1.11 确保日志大小限制配置正确"></a>4.1.11 确保日志大小限制配置正确</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>audit日志文件需要配置大小限制，达到限制后通过rotate机制，新建日志文件重新记录，可以防止单个文件过大问题，便于管理和追溯。配置上限过大，容易导致单个日志文件过大，不利于管理；配置上限过小，则容易导致过多的日志文件或者日志文件因rotate机制被频繁覆盖，不利于事后追溯。</p>
<p>openEuler默认配置8MB，用户可根据实际场景修改配置。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>使用如下命令查看当前配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep &quot;^max_log_file&quot; /etc/audit/auditd.conf</span></span><br><span class="line">max_log_file = 8</span><br><span class="line">max_log_file_action = ROTATE</span><br></pre></td></tr></table></figure>
<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;audit&#x2F;auditd.conf文件中max_log_file字段的值（单位是MB）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/auditd.conf</span></span><br><span class="line">max_log_file = &lt;numeric value <span class="keyword">in</span> megabytes&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-12-应当正确配置硬盘空间阈值"><a href="#4-1-12-应当正确配置硬盘空间阈值" class="headerlink" title="4.1.12 应当正确配置硬盘空间阈值"></a>4.1.12 应当正确配置硬盘空间阈值</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>在auditd记录日志过程中，如果硬盘空间被写满，可能导致业务无法正常执行，所以需要提前设置相关配置项，确保硬盘在即将写满或已经写满的情况下不至于引起更加严重的系统问题。</p>
<p>配置文件&#x2F;etc&#x2F;audit&#x2F;auditd.conf的如下相关项openEuler已配置默认值，用户可根据业务场景修改：</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>space_left</td>
<td>75</td>
<td>配置硬盘空间下限告警动作阈值，如低于75MB，则触发space_left_action定义的告警动作</td>
</tr>
<tr>
<td>space_left_action</td>
<td>SYSLOG</td>
<td>硬盘空间低于space_left时，触发告警事件，可选：IGNORE、SYSLOG、EMAIL、SUSPEND、SINGLE、HALT。  openEuler默认设置为SYSLOG，表示不会阻止继续记录日志，但会通过syslog记录一次告警。</td>
</tr>
<tr>
<td>admin_space_left</td>
<td>50</td>
<td>配置硬盘空间下限管理动作阈值，如低于50MB，则触发admin_space_left_action定义的操作动作，admin_space_left设置值不能大于space_left的值。</td>
</tr>
<tr>
<td>admin_space_left_action</td>
<td>SUSPEND</td>
<td>硬盘空间低于admin_space_left时，触发管理事件，可选：IGNORE、SYSLOG、EMAIL、SUSPEND、SINGLE、HALT。  openEuler默认设置为SUSPEND，表示auditd服务停止向硬盘输出日志记录。</td>
</tr>
<tr>
<td>disk_full_action</td>
<td>SUSPEND</td>
<td>表示如果系统检测到硬盘已经写满，则触发处理动作，可选：IGNORE、SYSLOG、SUSPEND、SINGLE、HALT。  openEuler默认设置为SUSPEND，表示auditd服务停止向硬盘输出日志记录。</td>
</tr>
<tr>
<td>disk_error_action</td>
<td>SUSPEND</td>
<td>表示如果在记录audit日志时，检测到硬盘错误，则触发处理动作，可选：IGNORE、SYSLOG、SUSPEND、SINGLE、HALT。  openEuler默认设置为SUSPEND，表示auditd服务停止向硬盘输出日志记录。</td>
</tr>
</tbody></table>
<p>如果告警阈值和管理阈值配置过大，则可能硬盘还有较大空间时audit日志就无法正常输出，如果配置过小，则会因为日志输出而将硬盘空间耗尽，影响正常业务，所以建议一方用户根据实际场景配置合理值，另一方面建议将日志输出到单独分区，避免日志过大影响业务。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方法检查&#x2F;etc&#x2F;audit&#x2F;auditd.conf文件是否配置正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/audit/auditd.conf | grep -iE &quot;space_left|space_left_action|admin_space_left|admin_space_left_action|disk_full_action|disk_error_action&quot;</span></span><br><span class="line">space_left = 75</span><br><span class="line">space_left_action = SYSLOG</span><br><span class="line">admin_space_left = 50</span><br><span class="line">admin_space_left_action = SUSPEND</span><br><span class="line">disk_full_action = SUSPEND</span><br><span class="line">disk_error_action = SUSPEND</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;audit&#x2F;auditd.conf文件，配置对应字段内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/auditd.conf</span></span><br><span class="line">space_left = &lt;numeric value <span class="keyword">in</span> megabytes&gt;</span><br><span class="line">space_left_action = &lt;action&gt;</span><br><span class="line">admin_space_left = &lt;numeric value <span class="keyword">in</span> megabytes&gt;</span><br><span class="line">admin_space_left_action = &lt;action&gt;</span><br><span class="line">disk_full_action = &lt;action&gt;</span><br><span class="line">disk_error_action = &lt;action&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-13-应当配置sudoers审计规则"><a href="#4-1-13-应当配置sudoers审计规则" class="headerlink" title="4.1.13 应当配置sudoers审计规则"></a>4.1.13 应当配置sudoers审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>sudo命令允许普通用户提权执行root管理员权限相关的操作，属于高危操作，攻击者一般无法直接获取root权限，但通过sudo命令提权，相对比较容易。建议配置对&#x2F;etc&#x2F;sudoers文件以及&#x2F;etc&#x2F;sudoers.d&#x2F;目录审计，记录读、写操作的审计日志，从而追溯是否有配置修改或读取操作（提权操作需要读取配置）。如果不配置sudoers审计，发生非法提权操作时不利于追溯。</p>
<p>openEuler默认不配置sudoers审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置sudoers审计，由于在文件操作时需要记录审计日志，对性能有轻微影响。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方法，检查是否存在针对&#x2F;etc&#x2F;sudoers文件以及&#x2F;etc&#x2F;sudoers.d&#x2F;目录的审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep &quot;sudoers&quot;</span></span><br><span class="line">-w /etc/sudoers -p wa -k sudoers</span><br><span class="line">-w /etc/sudoers.d -p wa -k sudoers</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如sudoers.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/sudoers.rules</span></span><br><span class="line">-w /etc/sudoers -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /etc/sudoers.d -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-14-应当配置会话审计规则"><a href="#4-1-14-应当配置会话审计规则" class="headerlink" title="4.1.14 应当配置会话审计规则"></a>4.1.14 应当配置会话审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>建议对&#x2F;var&#x2F;run&#x2F;utmp、&#x2F;var&#x2F;log&#x2F;wtmp、&#x2F;var&#x2F;log&#x2F;btmp三个文件进行审计监控，utmp文件记录了当前所有的登录事件信息；wtmp文件记录了所有的登录、登出、关机、重启事件信息，btmp记录了登录失败事件信息。如果不配置会话审计，管理员无法从audit日志中追溯登录、登出等事件，或可追溯信息不够。</p>
<p>openEuler默认不配置会话审计规则，建议用户根据实际业务场景进行配置。</p>
<p><strong>规则影响：</strong></p>
<p>配置会话审计，由于在文件操作时需要记录审计日志，对性能有轻微影响，但由于登录、登出动作本身不应快速、频繁发生，用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下方法，检查是否存在针对&#x2F;var&#x2F;run&#x2F;utmp、&#x2F;var&#x2F;log&#x2F;wtmp、&#x2F;var&#x2F;log&#x2F;btmp文件的审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;utmp|wtmp|btmp&quot;</span></span><br><span class="line">-w /var/run/utmp -p wa -k session</span><br><span class="line">-w /var/log/wtmp -p wa -k session</span><br><span class="line">-w /var/log/btmp -p wa -k session</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如session.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/session.rules</span></span><br><span class="line">-w /var/run/utmp -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /var/log/wtmp -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /var/log/btmp -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-15-应当配置时间修改审计规则"><a href="#4-1-15-应当配置时间修改审计规则" class="headerlink" title="4.1.15 应当配置时间修改审计规则"></a>4.1.15 应当配置时间修改审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>系统时间是否准确，影响着业务的正常运行。除了通过时间同步服务器确保时间同步之外，还需要关注管理员通过手工命令方式修改系统时间，后者往往伴随着攻击风险，如攻击者通过修改系统时间使某些保护策略失效（例如口令过期），达成攻击目的。</p>
<p>建议通过审计系统调用（adjtimex、settimeofday、clock_settime），对系统时间修改进行日志记录，同时对&#x2F;etc&#x2F;localtime文件进行审计，记录时区变更日志。如果不配置时间修改审计，管理员无法从audit日志中追溯时间变更事件。</p>
<p>openEuler默认不配置时间修改审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置时间变更审计，由于在文件操作或系统调用时需要记录审计日志，对性能有轻微影响，但由于时间变更动作本身不应快速、频繁发生，用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>如果是32位系统，通过如下命令检查配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;adjtimex|settimeofday|clock_settime|localtime&quot;</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S stime,settimeofday,adjtimex,clock_settime -F key=time</span><br><span class="line">-w /etc/localtime -p wa -k time</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，还需有如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S settimeofday,adjtimex,clock_settime -F key=time</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果是32位系统，在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如time.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/time.rules</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S stime -S settimeofday -S adjtimex -S clock_settime -k &lt;rules name&gt;</span><br><span class="line">-w /etc/localtime -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，需要再添加arch&#x3D;b64相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S settimeofday -S adjtimex -S clock_settime -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，64位系统中arch&#x3D;b32相关配置必须保留。</p>
<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-16-应当配置SELinux审计规则"><a href="#4-1-16-应当配置SELinux审计规则" class="headerlink" title="4.1.16 应当配置SELinux审计规则"></a>4.1.16 应当配置SELinux审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>SELinux是Linux平台提供的强制访问控制功能组件，用于对进程、文件等进行细粒度的权限控制。建议对SELinux配置文件、策略文件等配置审计，记录修改日志。如果不配置SELinux审计，如果发生非法策略修改，不利于追溯。</p>
<p>openEuler默认不配置SELinux审计规则，建议用户根据实际业务场景进行配置。</p>
<p><strong>规则影响：</strong></p>
<p>配置SELinux审计，由于在策略文件操作时需要记录审计日志，对性能有轻微影响。</p>
<p><strong>检查方法：</strong></p>
<p>通过如下命令检查selinux相关审计配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;selinux&quot;</span></span><br><span class="line">-w /etc/selinux -p wa -k selinux</span><br><span class="line">-w /usr/share/selinux -p wa -k selinux</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如selinux.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/selinux.rules</span></span><br><span class="line">-w /etc/selinux/ -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /usr/share/selinux/ -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>

<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-17-应当配置网络环境审计规则"><a href="#4-1-17-应当配置网络环境审计规则" class="headerlink" title="4.1.17 应当配置网络环境审计规则"></a>4.1.17 应当配置网络环境审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>攻击者可能通过修改系统域名、主机名等实施攻击行为，比如主机欺骗等，建议用户通过设置对系统调用setdomainname、sethostname的审计，以及文件&#x2F;etc&#x2F;hosts的审计，监控系统域名、主机名的修改；通过设置对&#x2F;etc&#x2F;issue、&#x2F;etc&#x2F;issue.net文件的审计，监控登录提示信息的修改。</p>
<p>如果不配置相关审计，如果发生非法修改，不利于追溯。</p>
<p>openEuler默认不配置网络环境审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在文件操作时需要记录审计日志，对性能有轻微影响，但由于域名、主机名以及登录提示信息不应被频繁修改，实际对用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>如果是32位系统，通过如下命令检查配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;setdomainname|sethostname|hosts|issue&quot;</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S sethostname,setdomainname -F key=hostnet</span><br><span class="line">-w /etc/hosts -p wa -k hostnet</span><br><span class="line">-w /etc/issue -p wa -k hostnet</span><br><span class="line">-w /etc/issue.net -p wa -k hostnet</span><br></pre></td></tr></table></figure>

<p>如果是64位系统，还需有如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S sethostname,setdomainname -F key=hostnet</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果是32位系统，在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如hostnet.rules，在文件中添加审计规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/hostnet.rules</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S setdomainname -S sethostname -k &lt;rules name&gt;</span><br><span class="line">-w /etc/hosts -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /etc/issue -p wa -k &lt;rules name&gt;</span><br><span class="line">-w /etc/issue.net -p wa -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，需要再添加arch&#x3D;b64相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S setdomainname -S sethostname -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，64位系统中arch&#x3D;b32相关配置必须保留。</p>
<p>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-18-应当配置文件访问控制权限审计规则"><a href="#4-1-18-应当配置文件访问控制权限审计规则" class="headerlink" title="4.1.18 应当配置文件访问控制权限审计规则"></a>4.1.18 应当配置文件访问控制权限审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>文件访问权限控制是Linux中基础的权限管理，不同用户被授权可以访问不同的文件，防止用户之间敏感信息泄露或文件数据被篡改，也可以防止普通用户越权访问系统高权限文件或配置。</p>
<p>建议对操作系统中修改文件权限、文件属主的系统调用进行审计监控。如果不配置相关审计，如果发生非法修改，不利于追溯。</p>
<p>openEuler默认不配置文件访问控制权限审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在文件权限、属主修改时需要记录审计日志，对性能有轻微影响，但由于此类操作不应被频繁执行，实际对用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>如果是32位系统，通过如下命令检查配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;chmod|chown|setxattr|exattr&quot;</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S <span class="built_in">chmod</span>,fchmod,fchmodat -F auid&gt;=1000 -F auid!=-1 -F key=fileperm</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S <span class="built_in">chown</span>,fchown,lchown,fchownat -F auid&gt;=1000 -F auid!=-1 -F key=fileperm</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid&gt;=1000 -F auid!=-1 -F key=fileperm</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，还需有如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S <span class="built_in">chmod</span>,fchmod,fchmodat -F auid&gt;=1000 -F auid!=-1 -F key=fileperm</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S <span class="built_in">chown</span>,fchown,lchown,fchownat -F auid&gt;=1000 -F auid!=-1 -F key=fileperm</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid&gt;=1000 -F auid!=-1 -F key=fileperm</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果是32位系统，在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如fileperm.rules，在文件中添加审计规则，此处&lt;min uid&gt;是&#x2F;etc&#x2F;login.defs文件中UID_MIN（UID_MIN为通过useradd方式添加用户，用户uid的最小值），openEuler上默认是1000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/fileperm.rules</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S <span class="built_in">chmod</span> -S fchmod -S fchmodat -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S <span class="built_in">chown</span> -S fchown -S fchownat -S lchown -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，需要再添加arch&#x3D;b64相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S <span class="built_in">chmod</span> -S fchmod -S fchmodat -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S <span class="built_in">chown</span> -S fchown -S fchownat -S lchown -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，64位系统中arch&#x3D;b32相关配置必须保留。<br>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-19-应当配置文件访问失败审计规则"><a href="#4-1-19-应当配置文件访问失败审计规则" class="headerlink" title="4.1.19 应当配置文件访问失败审计规则"></a>4.1.19 应当配置文件访问失败审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>通过对open、truncate、ftruncate、create、openat等系统调用进行审计监控，如果这些系统调用返回“-EACCES”或“-EPERM”错误，则表示文件无权访问，需要记录审计日志。由于权限问题导致文件访问失败的场景，在攻击行为中比较常见，建议配置审计规则，以便事后追溯。</p>
<p>openEuler默认不配置文件访问失败审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在文件访问失败时需要进行审计日志记录，对性能有轻微影响，但在实际场景中，文件访问失败的场景较少，影响有限。</p>
<p><strong>检查方法：</strong></p>
<p>如果是32位系统，通过如下命令检查配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;EACCES|EPERM&quot;</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S open,<span class="built_in">truncate</span>,ftruncate,creat,openat -F <span class="built_in">exit</span>=-EACCES -F auid&gt;=1000 -F auid!=-1 -F key=fileaccess</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S open,<span class="built_in">truncate</span>,ftruncate,creat,openat -F <span class="built_in">exit</span>=-EPERM -F auid&gt;=1000 -F auid!=-1 -F key=fileaccess</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，还需有如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S open,<span class="built_in">truncate</span>,ftruncate,creat,openat -F <span class="built_in">exit</span>=-EACCES -F auid&gt;=1000 -F auid!=-1 -F key=fileaccess</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S open,<span class="built_in">truncate</span>,ftruncate,creat,openat -F <span class="built_in">exit</span>=-EPERM -F auid&gt;=1000 -F auid!=-1 -F key=fileaccess</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果是32位系统，在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如fileaccess.rules，在文件中添加审计规则，此处&lt;min uid&gt;是&#x2F;etc&#x2F;login.defs文件中UID_MIN的值，openEuler上默认是1000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/fileaccess.rules</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S creat -S open -S openat -S <span class="built_in">truncate</span> -S ftruncate -F <span class="built_in">exit</span>=-EACCES -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S creat -S open -S openat -S <span class="built_in">truncate</span> -S ftruncate -F <span class="built_in">exit</span>=-EPERM -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，需要再添加arch&#x3D;b64相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S creat -S open -S openat -S <span class="built_in">truncate</span> -S ftruncate -F <span class="built_in">exit</span>=-EACCES -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S creat -S open -S openat -S <span class="built_in">truncate</span> -S ftruncate -F <span class="built_in">exit</span>=-EPERM -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，64位系统中arch&#x3D;b32相关配置必须保留。<br>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-20-应当配置文件删除审计规则"><a href="#4-1-20-应当配置文件删除审计规则" class="headerlink" title="4.1.20 应当配置文件删除审计规则"></a>4.1.20 应当配置文件删除审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>操作系统中文件删除操作一般都属于高危操作，管理员误操作或者攻击者攻击行为，都可能导致严重的系统故障，建议通过对rename、unlink、unlinkat、renameat等系统调用进行审计监控，记录删除操作日志。删除系统或业务文件，在攻击行为中比较常见，建议配置审计规则，以便事后追溯。</p>
<p>openEuler默认不配置文件删除审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在文件删除时需要进行审计日志记录，对性能有轻微影响，如果实际业务场景存在大量文件删除操作，则累积影响可能较大。</p>
<p><strong>检查方法：</strong></p>
<p>如果是32位系统，通过如下命令检查配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;unlink|unlinkat|rename|renameat&quot;</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S rename,<span class="built_in">unlink</span>,unlinkat,renameat -F auid&gt;=1000 -F auid!=-1 -F key=filedelete</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，还需有如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S rename,<span class="built_in">unlink</span>,unlinkat,renameat -F auid&gt;=1000 -F auid!=-1 -F key=filedelete</span><br></pre></td></tr></table></figure>
<p><strong>修复方法：</strong></p>
<p>如果是32位系统，在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如filedelete.rules，在文件中添加审计规则，此处&lt;min uid&gt;是&#x2F;etc&#x2F;login.defs文件中UID_MIN的值，openEuler上默认是1000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/filedelete.rules</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S <span class="built_in">unlink</span> -S unlinkat -S rename -S renameat -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，需要再添加arch&#x3D;b64相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S <span class="built_in">unlink</span> -S unlinkat -S rename -S renameat -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，64位系统中arch&#x3D;b32相关配置必须保留。<br>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h3 id="4-1-21-应当配置文件系统挂载审计规则"><a href="#4-1-21-应当配置文件系统挂载审计规则" class="headerlink" title="4.1.21 应当配置文件系统挂载审计规则"></a>4.1.21 应当配置文件系统挂载审计规则</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>通常情况下，业务部署完成后，文件系统挂载已经固定，不会变更。如果发生变更，可能存在攻击行为，建议对这些文件系统挂载进行审计监控，如果有变更，事后也可进行追溯。</p>
<p>openEuler默认不配置文件系统挂载审计规则，建议用户根据实际业务场景配置相应规则。</p>
<p><strong>规则影响：</strong></p>
<p>配置审计，由于在文件系统挂载时需要进行审计日志记录，对性能有轻微影响，但文件系统挂载相关操作应不频繁，实际对用户无感知。</p>
<p><strong>检查方法：</strong></p>
<p>如果是32位系统，通过如下命令检查配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># auditctl -l | grep -iE &quot;mount&quot;</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S mount -F auid&gt;=1000 -F auid!=-1 -F key=mount</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，还需有如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S mount -F auid&gt;=1000 -F auid!=-1 -F key=mount</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>如果是32位系统，在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;目录下新建规则文件，例如mount.rules，在文件中添加审计规则，此处&lt;min uid&gt;是&#x2F;etc&#x2F;login.defs文件中UID_MIN的值，openEuler上默认是1000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/audit/rules.d/mount.rules</span></span><br><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b32 -S mount -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>如果是64位系统，需要再添加arch&#x3D;b64相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a always,<span class="built_in">exit</span> -F <span class="built_in">arch</span>=b64 -S mount -F auid&gt;=&lt;min uid&gt; -F auid!=<span class="built_in">unset</span> -k &lt;rules name&gt;</span><br></pre></td></tr></table></figure>
<p>考虑兼容性，64位系统中arch&#x3D;b32相关配置必须保留。<br>重启auditd服务，使规则生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service auditd restart</span></span><br><span class="line">Stopping logging: [  OK  ]</span><br><span class="line">Redirecting start to /bin/systemctl start auditd.service</span><br></pre></td></tr></table></figure>
<h2 id="4-2-Rsyslog"><a href="#4-2-Rsyslog" class="headerlink" title="4.2 Rsyslog"></a>4.2 Rsyslog</h2><h3 id="4-2-1-确保rsyslog服务已启用"><a href="#4-2-1-确保rsyslog服务已启用" class="headerlink" title="4.2.1 确保rsyslog服务已启用"></a>4.2.1 确保rsyslog服务已启用</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>当前系统日志默认存储在内存，若不开启rsyslog服务，系统日志无法转储到持久性存储设备，系统重启后，会导致日志丢失。</p>
<p>rsyslog服务用于转储、分发系统日志，具有以下特点：</p>
<ul>
<li>多线程工作</li>
<li>支持UDP、TCP、SSL、TLS、RELP</li>
<li>支持将日志存储到MySQL、PGSQL、Oracle等多种关系数据库中</li>
<li>支持日志信息过滤</li>
<li>自定义输出格式</li>
</ul>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<ul>
<li><p>执行如下命令，查看rsyslog.service服务默认状态是否为enable</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl is-enabled rsyslog.service</span></span><br><span class="line">enabled</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行如下命令，查看rsyslog.service服务是否已经启动成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl status rsyslog.service | grep Active</span></span><br><span class="line">Active: active (running) since Tue 2020-12-01 16:33:25 CST; 2h 46min ago</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<ul>
<li><p>执行如下命令，使能rsyslog.service</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chkconfig rsyslog on</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl enable rsyslog.service</span></span><br></pre></td></tr></table></figure></li>
<li><p>执行如下命令，启动rsyslog.service</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl start rsyslog.service</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-2-确保系统认证相关事件日志已记录"><a href="#4-2-2-确保系统认证相关事件日志已记录" class="headerlink" title="4.2.2 确保系统认证相关事件日志已记录"></a>4.2.2 确保系统认证相关事件日志已记录</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>必须记录系统认证相关的事件，以便帮助分析用户登录、root权限使用以及监视系统的可疑动作等情况。</p>
<p>不记录系统认证相关事件日志，会导致无法从日志上分析可疑的攻击动作，例如攻击者尝试猜测管理员口令，而进行的登录动作。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;rsyslog.conf文件中是否已经配置auth相关字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep auth /etc/rsyslog.conf | grep -v &quot;^#&quot;</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none           /var/log/messages</span><br><span class="line">authpriv.*                                         /var/log/secure</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;rsyslog.conf文件添加如下设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.conf</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none           /var/log/messages</span><br><span class="line">authpriv.*                                         /var/log/secure</span><br></pre></td></tr></table></figure>

<p>执行如下命令，重启服务，使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rsyslog.service</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-确保cron服务日志已记录"><a href="#4-2-3-确保cron服务日志已记录" class="headerlink" title="4.2.3 确保cron服务日志已记录"></a>4.2.3 确保cron服务日志已记录</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>linux系统计划任务一般由cron来承担，由于cron可能会被黑客利用来加载恶意代码，因此需要全部记录cron的日志信息，以便跟踪系统异常状况。</p>
<p>不记录cron日志，当出现攻击者恶意操作时，将无法从日志信息中查看异常，进而无法跟踪系统异常状况。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;rsyslog.conf文件中是否已经配置相关字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep /var/log/cron /etc/rsyslog.conf</span></span><br><span class="line">cron.*                                                  /var/log/cron</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;rsyslog.conf文件，添加cron相关配置字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.conf</span></span><br><span class="line">cron.*                                                  /var/log/cron</span><br></pre></td></tr></table></figure>

<p>执行如下命令，重启服务，使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rsyslog.service</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-4-应当正确配置rsyslog默认文件权限"><a href="#4-2-4-应当正确配置rsyslog默认文件权限" class="headerlink" title="4.2.4 应当正确配置rsyslog默认文件权限"></a>4.2.4 应当正确配置rsyslog默认文件权限</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>日志文件记录了系统的行为，日志工具rsyslog能将日志记录到设定的文件中。当设定的日志文件在系统中不存在时，rsyslog能创建新日志文件。新创建的日志文件权限可在rsyslog配置文件中进行配置，通过设置默认文件权限以确保新创建的日志文件具有合理安全的权限。</p>
<p>若日志文件权限过大，普通用户也能读取日志，则增加了日志信息泄漏和被篡改的风险。合理的日志文件权限确保敏感的日志数据能得到保护。建议将日志权限设置为0600。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;rsyslog.conf或&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf配置文件是否配置了合理的默认文件权限，如果指令存在返回值且FileCreateMode的值不为0600，则说明系统日志信息存在泄露和被篡改的风险，需对日志文件权限进行修复。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^\$FileCreateMode /etc/rsyslog.conf /etc/rsyslog.d/*.conf</span></span><br><span class="line">/etc/rsyslog.d/sysalarm.conf:<span class="variable">$FileCreateMode</span> 0600</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;rsyslog.conf或&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf，为$FileCreateMode设置合理的权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.d/test.conf</span></span><br><span class="line"><span class="variable">$FileCreateMode</span> 0600</span><br></pre></td></tr></table></figure>

<p>rsyslog.conf中默认会包含&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf中的配置，因此配置任何一处即可。</p>
<p>执行如下命令，重启服务，使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rsyslog.service</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-5-应当正确配置各服务日志记录"><a href="#4-2-5-应当正确配置各服务日志记录" class="headerlink" title="4.2.5 应当正确配置各服务日志记录"></a>4.2.5 应当正确配置各服务日志记录</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>配置日志记录，这样系统的重要行为及安全相关的信息将使用rsyslog进行记录。配置文件&#x2F;etc&#x2F;rsyslog.conf及&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf中可以指定记录日志的规则及哪些文件将用于记录特定类型的日志。</p>
<p>若不配置日志记录，系统的行为无法记录，在出现问题时无法进行问题定位及审计。</p>
<p><strong>规则影响：</strong></p>
<p>配置日志记录后，如果不及时清理日志，日志可能占满当前分区，导致其他进程或系统故障风险。</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;rsyslog.conf及&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf中是否配置了合理的日志记录规则，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep \/var\/log /etc/rsyslog.conf /etc/rsyslog.d/*.conf</span></span><br><span class="line">/etc/rsyslog.conf:*.info;mail.none;authpriv.none;cron.none        /var/log/messages</span><br><span class="line">/etc/rsyslog.conf:authpriv.*                                 /var/log/secure</span><br><span class="line">/etc/rsyslog.conf:mail.*                                    /var/log/maillog</span><br><span class="line">/etc/rsyslog.conf:cron.*                                    /var/log/cron</span><br><span class="line">/etc/rsyslog.conf:uucp,news.crit                             /var/log/spooler</span><br><span class="line">/etc/rsyslog.conf:local7.*                                  /var/log/boot.log</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;rsyslog.conf及&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf中配置合理的日志记录规则，以&#x2F;etc&#x2F;rsyslog.conf为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.conf</span></span><br><span class="line">/etc/rsyslog.conf:*.info;mail.none;authpriv.none;cron.none        /var/log/messages</span><br><span class="line">/etc/rsyslog.conf:authpriv.*                                 /var/log/secure</span><br><span class="line">/etc/rsyslog.conf:mail.*                                    /var/log/maillog</span><br><span class="line">/etc/rsyslog.conf:cron.*                                    /var/log/cron</span><br><span class="line">/etc/rsyslog.conf:uucp,news.crit                             /var/log/spooler</span><br><span class="line">/etc/rsyslog.conf:local7.*                                  /var/log/boot.log</span><br></pre></td></tr></table></figure>

<p>系统管理员在配置日志规则时，按需进行合理配置。以mail日志为例，“*”表示所有级别的日志；“&#x2F;var&#x2F;log&#x2F;maillog”意思是mail相关的日志记录到该文件中。具体的日志配置规则可参考rsyslog标准。</p>
<p>执行如下命令，重启服务，使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rsyslog.service</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-6-确保rsyslog转储journald日志已配置"><a href="#4-2-6-确保rsyslog转储journald日志已配置" class="headerlink" title="4.2.6 确保rsyslog转储journald日志已配置"></a>4.2.6 确保rsyslog转储journald日志已配置</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>系统采用journald进行日志收集，日志可能存在易失性存储设备上，也有可能存储在持久性存储设备上，存在日志丢失或者日志占满磁盘等问题，及时对日志进行转储，保障日志与系统更加安全。</p>
<p><strong>规则影响：</strong></p>
<p>日志如果存在易失性存储设备，不及时对日志进行转储，可能导致日志丢失。如果存在持久性存储设备上，日志量可能非常大，不及时对日志进行转储，有可能导致日志占满当前分区，导致其他进程或系统故障风险。</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;rsyslog.conf文件中是否已经配置相关字段，如果返回结果不为空，表示已配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep imjournal /etc/rsyslog.conf</span></span><br><span class="line">module(load=<span class="string">&quot;imjournal&quot;</span>   <span class="comment"># provides access to the systemd journal</span></span><br><span class="line">StateFile=<span class="string">&quot;/run/log/imjournal.state&quot;</span>) <span class="comment"># File to store the position in the journal</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>打开&#x2F;etc&#x2F;rsyslog.conf文件，新增如下设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.conf</span></span><br><span class="line">module(load=<span class="string">&quot;imjournal&quot;</span>   <span class="comment"># provides access to the systemd journal</span></span><br><span class="line">StateFile=<span class="string">&quot;/run/log/imjournal.state&quot;</span>) <span class="comment"># File to store the position in the journal</span></span><br></pre></td></tr></table></figure>

<p>执行如下命令，重启服务，使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rsyslog.service</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-7-确保rsyslog日志rotate已配置"><a href="#4-2-7-确保rsyslog日志rotate已配置" class="headerlink" title="4.2.7 确保rsyslog日志rotate已配置"></a>4.2.7 确保rsyslog日志rotate已配置</h3><p><strong>级别：</strong> 要求</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>rsyslog负责从系统中收集日志记录到文件中，logrotate负责定期或定量对日志文件进行拷贝、压缩，以确保不会因为日志文件过大而导致占用过多的硬盘资源，甚至日志文件不可维护。</p>
<p>如果不配置rotate策略，日志文件会一直增长，最终可能导致日志所在硬盘分区空间耗尽，轻则影响日志记录，重则可能导致系统和业务无法继续正常执行。</p>
<p>openEuler默认已经在&#x2F;etc&#x2F;logrotate.d&#x2F;rsyslog文件中配置rsyslog的rotate策略如下：</p>
<ul>
<li><p>rotate日志文件</p>
<p>&#x2F;var&#x2F;log&#x2F;cron</p>
<p>&#x2F;var&#x2F;log&#x2F;maillog</p>
<p>&#x2F;var&#x2F;log&#x2F;messages</p>
<p>&#x2F;var&#x2F;log&#x2F;secure</p>
<p>&#x2F;var&#x2F;log&#x2F;spooler</p>
</li>
<li><p>日志文件最大保留期限365天；</p>
</li>
<li><p>日志文件最多保留30个；</p>
</li>
<li><p>日志文件采用压缩方式保留；</p>
</li>
<li><p>日志文件达到4MB，进行rotate操作。</p>
</li>
</ul>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;logrotate.d&#x2F;rsyslog文件中是否已经配置相关字段，此处“&#x2F;var&#x2F;log&#x2F;*”是&#x2F;etc&#x2F;rsyslog.conf文件中配置的rsyslog日志输出路径，两者需要匹配一致：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/logrotate.d/rsyslog | grep -iE &quot;\/var\/log|maxage|\&lt;rotate\&gt;|compress|size&quot;</span></span><br><span class="line">/var/log/cron</span><br><span class="line">/var/log/maillog</span><br><span class="line">/var/log/messages</span><br><span class="line">/var/log/secure</span><br><span class="line">/var/log/spooler</span><br><span class="line">    maxage 365</span><br><span class="line">    rotate 30</span><br><span class="line">    compress</span><br><span class="line">    size +4096k</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;logrotate.d目录下创建配置文件，比如&#x2F;etc&#x2F;logrotate.d&#x2F;rsyslog文件，检查并新增如下设置，其中&lt;log file paths&gt;是&#x2F;etc&#x2F;rsyslog.conf文件中配置的rsyslog日志输出路径，两者需要匹配一致：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/logrotate.d/rsyslog</span></span><br><span class="line">&lt;<span class="built_in">log</span> file paths&gt;</span><br><span class="line">&#123;</span><br><span class="line">    maxage &lt;days&gt;</span><br><span class="line">    rotate &lt;files counts&gt;</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    copytruncate</span><br><span class="line">    missingok</span><br><span class="line">    size +&lt;numeric value <span class="keyword">in</span> kilobyte&gt;k</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        /bin/kill -HUP `<span class="built_in">cat</span> /var/run/rsyslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || <span class="literal">true</span></span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-8-应当配置远程日志服务器"><a href="#4-2-8-应当配置远程日志服务器" class="headerlink" title="4.2.8 应当配置远程日志服务器"></a>4.2.8 应当配置远程日志服务器</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>rsyslog日志服务可以将本地日志发送到远端日志服务器统一保存，有利于组网环境下日志集中管理，防止本地日志占用过多硬盘空间的同时，也可以防止日志在本地被篡改。</p>
<p>如果不配置远程日志存储，则rsyslog日志会保存在本地文件中，管理员正确配置日志存储路径以及rotate参数的情况下，对系统及业务无影响。如果配置了远程日志存储，就必须保证日志传输过程安全，如传输日志前进行加密、通过开启安全加密通道（TCP+TLS1.2及更高版本）等方法进行日志传输。</p>
<p>openEuler默认不配置远程日志存储，建议用户根据实际业务场景进行配置。</p>
<p><strong>规则影响：</strong></p>
<p>配置远程日志存储，则需要确保日志服务器有足够的硬盘空间用于存储组网环境下所有服务器上报的日志。</p>
<p><strong>检查方法：</strong></p>
<p>检查&#x2F;etc&#x2F;rsyslog.d&#x2F;目录下配置文件中是否已经配置相关字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep -irE &quot;^*.*@*:[0-9]+$&quot; /etc/rsyslog.d/*.conf</span></span><br><span class="line">/etc/rsyslog.d/server.conf:*.* @@9.82.213.138:11514</span><br></pre></td></tr></table></figure>

<p><strong>修复方法：</strong></p>
<p>在&#x2F;etc&#x2F;rsyslog.d&#x2F;目录下新建以conf为后缀的配置文件，例如server.conf，然后加入配置如下，其中“*.*” 指将所有的日志都打印到服务器（含义是：日志类型.日志级别，mail.info就表示只将mail的info日志打印到服务器），“@”表示使用UDP协议，“@@”表示使用TCP协议：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.d/server.conf</span></span><br><span class="line">*.* @@&lt;remote IP&gt;:&lt;remote port&gt;</span><br><span class="line"><span class="comment"># 如果是IPv6，则添加如下配置:</span></span><br><span class="line">*.* @@[&lt;remove IPv6&gt;%&lt;interface name&gt;]:&lt;remote port&gt;</span><br></pre></td></tr></table></figure>

<p>执行如下命令，重启服务，使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rsyslog.service</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-9-应当仅在指定的日志主机上接受远程rsyslog消息"><a href="#4-2-9-应当仅在指定的日志主机上接受远程rsyslog消息" class="headerlink" title="4.2.9 应当仅在指定的日志主机上接受远程rsyslog消息"></a>4.2.9 应当仅在指定的日志主机上接受远程rsyslog消息</h3><p><strong>级别：</strong> 建议</p>
<p><strong>适用版本：</strong> 全部</p>
<p><strong>规则说明：</strong> </p>
<p>默认情况下，rsyslog不会监听来自远程系统的日志消息。rsyslog需加载imtcp.so模块才能通过TCP监听，同理需要加载imudp.so模块才能通过UDP监听，两者都需要指定监听的TCP&#x2F;UDP端口。确保只在指定的日志主机上接收远程rsyslog消息，以便管理员集中管理，但需要确保日志服务器有足够的硬盘空间用于存储组网环境下所有服务器上报的日志。</p>
<p><strong>规则影响：</strong></p>
<p>无</p>
<p><strong>检查方法：</strong></p>
<p>运行如下命令检查&#x2F;etc&#x2F;rsyslog.conf及&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf配置文件：</p>
<ul>
<li><p>检查TCP配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^\$ModLoad /etc/rsyslog.conf /etc/rsyslog.d/*.conf | grep imtcp</span></span><br><span class="line">/etc/rsyslog.conf:<span class="variable">$ModLoad</span> imtcp</span><br><span class="line"><span class="comment"># grep ^\$InputTCPServerRun /etc/rsyslog.conf /etc/rsyslog.d/*.conf</span></span><br><span class="line">/etc/rsyslog.conf:<span class="variable">$InputTCPServerRun</span> 11514</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查UDP配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep ^\$ModLoad /etc/rsyslog.conf /etc/rsyslog.d/*.conf | grep imudp</span></span><br><span class="line">/etc/rsyslog.conf:<span class="variable">$ModLoad</span> imudp</span><br><span class="line"><span class="comment"># grep ^\$InputUDPServerRun /etc/rsyslog.conf /etc/rsyslog.d/*.conf</span></span><br><span class="line">/etc/rsyslog.conf:<span class="variable">$InputUDPServerRun</span> 11514</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>修复方法：</strong></p>
<p>修改&#x2F;etc&#x2F;rsyslog.conf或&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf，配置接受远程rsyslog消息，并根据客户端IP单独存放在不同目录，可以自定义指定目录：</p>
<ul>
<li><p>修复TCP配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.conf</span></span><br><span class="line"><span class="variable">$ModLoad</span> imtcp</span><br><span class="line"><span class="variable">$InputTCPServerRun</span> 11514</span><br><span class="line"><span class="variable">$template</span> Remote, <span class="string">&quot;/var/log/syslog/%fromhost-ip%/%<span class="variable">$YEAR</span>%-%<span class="variable">$MONTH</span>%-%<span class="variable">$DAY</span>%.log&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修复UDP配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/rsyslog.conf</span></span><br><span class="line"><span class="variable">$ModLoad</span> imudp</span><br><span class="line"><span class="variable">$InputUDPServerRun</span> 11514</span><br><span class="line"><span class="variable">$template</span> Remote, <span class="string">&quot;/var/log/syslog/%fromhost-ip%/%<span class="variable">$YEAR</span>%-%<span class="variable">$MONTH</span>%-%<span class="variable">$DAY</span>%.log&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行如下命令，重启服务，使配置生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rsyslog.service</span></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2024/01/17/8abcbf98bed2ccbc.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2024/01/17/8abcbf98bed2ccbc.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">馒头馅儿大肉包</div><div class="post-copyright__author_desc">要努力鸭,为了想要的生活。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://blog.techcat.cc/posts/ec805823.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://blog.techcat.cc/posts/ec805823.html')">openEuler安全配置基线</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://blog.techcat.cc/posts/ec805823.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=openEuler安全配置基线&amp;url=http://blog.techcat.cc/posts/ec805823.html&amp;pic=https://s3.bmp.ovh/imgs/2023/08/27/70d5dea4dd88dfc1.webp?_r_=bb7c0e92-ec43-67b0-e72e-a37c058b5b71" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.techcat.cc" target="_blank">馒头馅儿大肉包</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%BA%BF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>安全配置基线<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/217c81a9.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2023/08/27/70d5dea4dd88dfc1.webp?_r_=fd5b3c10-d4a6-2363-b3f4-b7310b500e1d" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux常用配置项</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2024/01/17/8abcbf98bed2ccbc.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">馒头馅儿大肉包</h1><div class="author-info__desc">要努力鸭,为了想要的生活。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/techcatnip" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/5070155" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#openEuler%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%BA%BF-v1-0"><span class="toc-number">1.</span> <span class="toc-text">openEuler安全配置基线 v1.0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E9%83%A8%E7%BD%B2"><span class="toc-number">1.1.</span> <span class="toc-text">1 初始部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E7%A6%81%E6%AD%A2%E5%AD%98%E5%9C%A8%E6%97%A0%E5%B1%9E%E4%B8%BB%E6%88%96%E5%B1%9E%E7%BB%84%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1.1 禁止存在无属主或属组的文件或目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E7%A6%81%E6%AD%A2%E5%AD%98%E5%9C%A8%E7%A9%BA%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.1.2 禁止存在空链接文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E7%A6%81%E6%AD%A2%E5%AD%98%E5%9C%A8%E9%9A%90%E8%97%8F%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.1.3 禁止存在隐藏的可执行文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E7%A1%AE%E4%BF%9D%E5%85%A8%E5%B1%80%E5%8F%AF%E5%86%99%E7%9B%AE%E5%BD%95%E5%B7%B2%E8%AE%BE%E7%BD%AEsticky%E4%BD%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.1.4 确保全局可写目录已设置sticky位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-%E7%A1%AE%E4%BF%9DUMASK%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.1.5 确保UMASK配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-6-%E7%A6%81%E6%AD%A2%E5%AD%98%E5%9C%A8%E5%85%A8%E5%B1%80%E5%8F%AF%E5%86%99%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.6.</span> <span class="toc-text">1.1.6 禁止存在全局可写的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-7-%E7%A1%AE%E4%BF%9D%E7%A7%BB%E9%99%A4%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E6%94%AF%E6%8C%81"><span class="toc-number">1.2.7.</span> <span class="toc-text">1.1.7 确保移除不需要的文件系统挂载支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-8-%E7%A1%AE%E4%BF%9D%E6%97%A0%E9%9C%80%E4%BF%AE%E6%94%B9%E7%9A%84%E5%88%86%E5%8C%BA%E4%BB%A5%E5%8F%AA%E8%AF%BB%E6%96%B9%E5%BC%8F%E6%8C%82%E8%BD%BD"><span class="toc-number">1.2.8.</span> <span class="toc-text">1.1.8 确保无需修改的分区以只读方式挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-9-%E7%A1%AE%E4%BF%9D%E6%97%A0%E9%9C%80%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E5%8C%BA%E4%BB%A5nodev%E6%96%B9%E5%BC%8F%E6%8C%82%E8%BD%BD"><span class="toc-number">1.2.9.</span> <span class="toc-text">1.1.9 确保无需挂载设备的分区以nodev方式挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-10-%E7%A1%AE%E4%BF%9D%E6%97%A0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E5%8C%BA%E4%BB%A5noexec%E6%96%B9%E5%BC%8F%E6%8C%82%E8%BD%BD"><span class="toc-number">1.2.10.</span> <span class="toc-text">1.1.10 确保无可执行文件的分区以noexec方式挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-11-%E7%A1%AE%E4%BF%9D%E5%8F%AF%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%88%86%E5%8C%BA%E4%BB%A5noexec%E3%80%81nodev%E6%96%B9%E5%BC%8F%E6%8C%82%E8%BD%BD"><span class="toc-number">1.2.11.</span> <span class="toc-text">1.1.11 确保可移动设备分区以noexec、nodev方式挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-12-%E7%A1%AE%E4%BF%9D%E6%97%A0%E9%9C%80SUID-SGID%E7%9A%84%E5%88%86%E5%8C%BA%E4%BB%A5nosuid%E6%96%B9%E5%BC%8F%E6%8C%82%E8%BD%BD"><span class="toc-number">1.2.12.</span> <span class="toc-text">1.1.12 确保无需SUID&#x2F;SGID的分区以nosuid方式挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-13-%E7%A1%AE%E4%BF%9D%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84SUID%E5%92%8CSGID%E4%BD%8D"><span class="toc-number">1.2.13.</span> <span class="toc-text">1.1.13 确保删除文件不必要的SUID和SGID位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-14-%E7%A1%AE%E4%BF%9D%E5%85%B3%E9%94%AE%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="toc-number">1.2.14.</span> <span class="toc-text">1.1.14 确保关键文件、目录权限最小化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-15-%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7%E5%8F%AF%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.2.15.</span> <span class="toc-text">1.1.15 确保用户可打开文件数量配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-16-%E7%A1%AE%E4%BF%9D%E8%BD%AF%E3%80%81%E7%A1%AC%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.2.16.</span> <span class="toc-text">1.1.16 确保软、硬链接文件保护配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-17-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8USB%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.17.</span> <span class="toc-text">1.1.17 避免使用USB存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-18-%E5%BA%94%E5%BD%93%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.18.</span> <span class="toc-text">1.1.18 应当分区管理硬盘数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-19-%E7%A1%AE%E4%BF%9DLD-LIBRARY-PATH%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.2.19.</span> <span class="toc-text">1.1.19 确保LD_LIBRARY_PATH变量定义正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-20-%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7PATH%E5%8F%98%E9%87%8F%E8%A2%AB%E4%B8%A5%E6%A0%BC%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.20.</span> <span class="toc-text">1.1.20 确保用户PATH变量被严格定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85FTP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.2.1 禁止安装FTP客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85TFTP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.2.2 禁止安装TFTP客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85Telnet%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.2.3 禁止安装Telnet客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84SNMP%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.2.4 禁止安装不安全的SNMP协议版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85python2"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.2.5 禁止安装python2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-%E7%A1%AE%E4%BF%9Dyum%E6%BA%90%E9%85%8D%E7%BD%AEGPG%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.3.6.</span> <span class="toc-text">1.2.6 确保yum源配置GPG校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-7-%E7%A6%81%E6%AD%A2%E5%90%AF%E7%94%A8debug-shell%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.7.</span> <span class="toc-text">1.2.7 禁止启用debug-shell服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-8-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85rsync%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.8.</span> <span class="toc-text">1.2.8 禁止安装rsync服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-9-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85avahi%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.9.</span> <span class="toc-text">1.2.9 禁止安装avahi服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-10-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85LDAP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.10.</span> <span class="toc-text">1.2.10 禁止安装LDAP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-11-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85%E6%89%93%E5%8D%B0%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.11.</span> <span class="toc-text">1.2.11 禁止安装打印服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-12-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85NIS%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.3.12.</span> <span class="toc-text">1.2.12 禁止安装NIS服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-13-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85NIS%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.13.</span> <span class="toc-text">1.2.13 禁止安装NIS客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-14-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85LDAP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.14.</span> <span class="toc-text">1.2.14 禁止安装LDAP客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-15-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2%E7%B1%BB%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.15.</span> <span class="toc-text">1.2.15 禁止安装网络嗅探类工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-16-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85%E8%B0%83%E6%B5%8B%E7%B1%BB%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.16.</span> <span class="toc-text">1.2.16 禁止安装调测类工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-17-%E7%A6%81%E6%AD%A2%E5%AE%89%E8%A3%85%E5%BC%80%E5%8F%91%E7%BC%96%E8%AF%91%E7%B1%BB%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.17.</span> <span class="toc-text">1.2.17 禁止安装开发编译类工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-18-%E9%81%BF%E5%85%8D%E5%AE%89%E8%A3%85X-Window%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.18.</span> <span class="toc-text">1.2.18 避免安装X Window系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-19-%E9%81%BF%E5%85%8D%E5%AE%89%E8%A3%85HTTP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.19.</span> <span class="toc-text">1.2.19 避免安装HTTP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-20-%E9%81%BF%E5%85%8D%E5%AE%89%E8%A3%85samba%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.20.</span> <span class="toc-text">1.2.20 避免安装samba服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-21-%E9%81%BF%E5%85%8D%E5%90%AF%E7%94%A8DNS%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.21.</span> <span class="toc-text">1.2.21 避免启用DNS服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-22-%E9%81%BF%E5%85%8D%E5%90%AF%E7%94%A8NFS%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.22.</span> <span class="toc-text">1.2.22 避免启用NFS服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-23-%E9%81%BF%E5%85%8D%E5%90%AF%E7%94%A8RPC%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.23.</span> <span class="toc-text">1.2.23 避免启用RPC服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-24-%E9%81%BF%E5%85%8D%E5%90%AF%E7%94%A8DHCP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.24.</span> <span class="toc-text">1.2.24 避免启用DHCP服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.</span> <span class="toc-text">2 安全访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%B4%A6%E6%88%B7"><span class="toc-number">1.5.</span> <span class="toc-text">2.1 账户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%A6%81%E6%AD%A2%E6%97%A0%E9%9C%80%E7%99%BB%E5%BD%95%E7%9A%84%E8%B4%A6%E5%8F%B7%E8%AE%BE%E7%BD%AE%E7%99%BB%E5%BD%95%E8%83%BD%E5%8A%9B"><span class="toc-number">1.5.1.</span> <span class="toc-text">2.1.1 禁止无需登录的账号设置登录能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%A6%81%E6%AD%A2%E5%AD%98%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B4%A6%E5%8F%B7"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.1.2 禁止存在不使用的账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E7%A1%AE%E4%BF%9D%E4%B8%8D%E5%90%8C%E8%B4%A6%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%88%86%E9%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%84ID"><span class="toc-number">1.5.3.</span> <span class="toc-text">2.1.3 确保不同账号初始分配不同的组ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E7%A6%81%E6%AD%A2%E5%AD%98%E5%9C%A8UID%E4%B8%BA0%E7%9A%84%E9%9D%9Eroot%E8%B4%A6%E5%8F%B7"><span class="toc-number">1.5.4.</span> <span class="toc-text">2.1.4 禁止存在UID为0的非root账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E7%A1%AE%E4%BF%9D%E8%B4%A6%E5%8F%B7%E3%80%81%E7%BB%84%E5%8F%8A%E5%8F%A3%E4%BB%A4%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.5.5.</span> <span class="toc-text">2.1.5 确保账号、组及口令文件权限正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E7%A1%AE%E4%BF%9D%E8%B4%A6%E5%8F%B7%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84Home%E7%9B%AE%E5%BD%95"><span class="toc-number">1.5.6.</span> <span class="toc-text">2.1.6 确保账号拥有自己的Home目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7-%E7%A1%AE%E4%BF%9D-etc-passwd%E4%B8%AD%E7%9A%84%E7%BB%84%E9%83%BD%E5%AD%98%E5%9C%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">2.1.7 确保&#x2F;etc&#x2F;passwd中的组都存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-8-%E7%A1%AE%E4%BF%9DUID%E5%94%AF%E4%B8%80"><span class="toc-number">1.5.8.</span> <span class="toc-text">2.1.8 确保UID唯一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-9-%E7%A1%AE%E4%BF%9D%E8%B4%A6%E5%8F%B7%E5%90%8D%E5%94%AF%E4%B8%80"><span class="toc-number">1.5.9.</span> <span class="toc-text">2.1.9 确保账号名唯一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-10-%E7%A1%AE%E4%BF%9DGID%E5%94%AF%E4%B8%80"><span class="toc-number">1.5.10.</span> <span class="toc-text">2.1.10 确保GID唯一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-11-%E7%A1%AE%E4%BF%9D%E7%BB%84%E5%90%8D%E5%94%AF%E4%B8%80"><span class="toc-number">1.5.11.</span> <span class="toc-text">2.1.11 确保组名唯一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-12-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E8%AE%BE%E7%BD%AE%E8%B4%A6%E5%8F%B7%E6%9C%89%E6%95%88%E6%9C%9F"><span class="toc-number">1.5.12.</span> <span class="toc-text">2.1.12 应当正确设置账号有效期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-13-%E9%81%BF%E5%85%8DHome%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%AD%98%E5%9C%A8-forward%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.13.</span> <span class="toc-text">2.1.13 避免Home目录下存在.forward文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-14-%E9%81%BF%E5%85%8DHome%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%AD%98%E5%9C%A8-netrc%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.14.</span> <span class="toc-text">2.1.14 避免Home目录下存在.netrc文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%A3%E4%BB%A4"><span class="toc-number">1.6.</span> <span class="toc-text">2.2 口令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%A1%AE%E4%BF%9D%E5%8F%A3%E4%BB%A4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.6.1.</span> <span class="toc-text">2.2.1 确保口令复杂度设置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%8E%86%E5%8F%B2%E5%8F%A3%E4%BB%A4"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.2.2 禁止使用历史口令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7%E4%BF%AE%E6%94%B9%E8%87%AA%E8%BA%AB%E5%8F%A3%E4%BB%A4%E6%97%B6%E9%9C%80%E9%AA%8C%E8%AF%81%E6%97%A7%E5%8F%A3%E4%BB%A4"><span class="toc-number">1.6.3.</span> <span class="toc-text">2.2.3 确保用户修改自身口令时需验证旧口令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E7%A1%AE%E4%BF%9D%E5%8F%A3%E4%BB%A4%E4%B8%AD%E4%B8%8D%E5%8C%85%E5%90%AB%E8%B4%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.4.</span> <span class="toc-text">2.2.4 确保口令中不包含账号字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E7%A1%AE%E4%BF%9D%E5%8F%A3%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%BC%BAHash%E7%AE%97%E6%B3%95%E5%8A%A0%E5%AF%86"><span class="toc-number">1.6.5.</span> <span class="toc-text">2.2.5 确保口令使用强Hash算法加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E7%A1%AE%E4%BF%9D%E5%BC%B1%E5%8F%A3%E4%BB%A4%E5%AD%97%E5%85%B8%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.6.6.</span> <span class="toc-text">2.2.6 确保弱口令字典设置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-7-%E7%A1%AE%E4%BF%9D%E5%8F%A3%E4%BB%A4%E6%9C%89%E6%95%88%E6%9C%9F%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.6.7.</span> <span class="toc-text">2.2.7 确保口令有效期设置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-8-%E7%A6%81%E6%AD%A2%E7%A9%BA%E5%8F%A3%E4%BB%A4%E7%99%BB%E5%BD%95"><span class="toc-number">1.6.8.</span> <span class="toc-text">2.2.8 禁止空口令登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-9-%E7%A1%AE%E4%BF%9DGrub%E5%B7%B2%E8%AE%BE%E7%BD%AE%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.6.9.</span> <span class="toc-text">2.2.9 确保Grub已设置口令保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-10-%E7%A1%AE%E4%BF%9D%E5%8D%95%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%B7%B2%E8%AE%BE%E7%BD%AE%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.6.10.</span> <span class="toc-text">2.2.10 确保单用户模式已设置口令保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-11-%E7%A1%AE%E4%BF%9D%E8%B4%A6%E5%8F%B7%E5%9C%A8%E9%A6%96%E6%AC%A1%E7%99%BB%E5%BD%95%E6%97%B6%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9%E5%8F%A3%E4%BB%A4"><span class="toc-number">1.6.11.</span> <span class="toc-text">2.2.11 确保账号在首次登录时强制修改口令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">1.7.</span> <span class="toc-text">2.3 身份认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E7%A1%AE%E4%BF%9D%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E4%B8%80%E5%AE%9A%E6%AC%A1%E6%95%B0%E5%90%8E%E9%94%81%E5%AE%9A%E8%B4%A6%E5%8F%B7"><span class="toc-number">1.7.1.</span> <span class="toc-text">2.3.1 确保登录失败一定次数后锁定账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E7%A1%AE%E4%BF%9D%E4%BC%9A%E8%AF%9D%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.3.2 确保会话超时时间设置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E7%A1%AE%E4%BF%9DWarning-Banners%E5%8C%85%E5%90%AB%E5%90%88%E7%90%86%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.3.</span> <span class="toc-text">2.3.3 确保Warning Banners包含合理的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEBanner%E8%B7%AF%E5%BE%84"><span class="toc-number">1.7.4.</span> <span class="toc-text">2.3.4 应当正确配置Banner路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.8.</span> <span class="toc-text">2.4 访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E9%99%90%E5%88%B6%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%E6%95%B0%E9%87%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">2.4.1 限制历史命令记录数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8enforce%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">2.4.2 应当启用enforce模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AESELinux%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.3.</span> <span class="toc-text">2.4.3 应当正确配置SELinux策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E7%A1%AE%E4%BF%9Dsu%E5%8F%97%E9%99%90%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">2.4.4 确保su受限使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E7%A1%AE%E4%BF%9D%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E9%80%9A%E8%BF%87sudo%E8%BF%90%E8%A1%8C%E7%89%B9%E6%9D%83%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.8.5.</span> <span class="toc-text">2.4.5 确保普通用户通过sudo运行特权程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E7%A1%AE%E4%BF%9Dsudoers%E4%B8%8D%E8%83%BD%E9%85%8D%E7%BD%AE%E4%BD%8E%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%E5%8F%AF%E5%86%99%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="toc-number">1.8.6.</span> <span class="toc-text">2.4.6 确保sudoers不能配置低权限用户可写的脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-%E7%A1%AE%E4%BF%9D%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%B8%8D%E8%83%BD%E5%80%9F%E5%8A%A9pkexec%E9%85%8D%E7%BD%AE%E6%8F%90%E6%9D%83root"><span class="toc-number">1.8.7.</span> <span class="toc-text">2.4.7 确保普通用户不能借助pkexec配置提权root</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-8-%E7%A1%AE%E4%BF%9Dsu%E5%91%BD%E4%BB%A4%E7%BB%A7%E6%89%BF%E7%94%A8%E6%88%B7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%E5%BC%95%E5%85%A5%E6%8F%90%E6%9D%83"><span class="toc-number">1.8.8.</span> <span class="toc-text">2.4.8 确保su命令继承用户环境变量不会引入提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-9-%E9%81%BF%E5%85%8Droot%E7%94%A8%E6%88%B7%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%85%A5%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.8.9.</span> <span class="toc-text">2.4.9 避免root用户本地接入系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-10-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E4%B8%BAunconfined-service-t%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.8.10.</span> <span class="toc-text">2.4.10 避免使用标签为unconfined_service_t的程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">1.9.</span> <span class="toc-text">2.5 完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8IMA%E5%BA%A6%E9%87%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">2.5.1 应当启用IMA度量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8aide%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.5.2 应当启用aide入侵检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-number">1.10.</span> <span class="toc-text">2.6 数据安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8haveged%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.10.1.</span> <span class="toc-text">2.6.1 应当启用haveged服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E5%BA%94%E5%BD%93%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E4%B8%8D%E4%BD%8E%E4%BA%8EDEFAULT"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.6.2 应当设置全局加解密策略配置不低于DEFAULT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.11.</span> <span class="toc-text">3 运行和服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.12.</span> <span class="toc-text">3.1 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.12.1.</span> <span class="toc-text">3.1.1 避免使用不常见网络服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C"><span class="toc-number">1.12.2.</span> <span class="toc-text">3.1.2 避免使用无线网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-number">1.13.</span> <span class="toc-text">3.2 防火墙</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8firewalld%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.13.1.</span> <span class="toc-text">3.2.1 应当启用firewalld服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.13.2.</span> <span class="toc-text">3.2.2 应当配置正确的默认区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E5%BA%94%E5%BD%93%E7%A1%AE%E4%BF%9D%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%AD%A3%E7%A1%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.13.3.</span> <span class="toc-text">3.2.3 应当确保网络接口绑定正确区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E9%81%BF%E5%85%8D%E5%BC%80%E5%90%AF%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.13.4.</span> <span class="toc-text">3.2.4 避免开启不必要的服务和端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8iptables%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.13.5.</span> <span class="toc-text">3.2.5 应当启用iptables服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEiptables%E9%BB%98%E8%AE%A4%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.6.</span> <span class="toc-text">3.2.6 应当正确配置iptables默认拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-7-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEiptables-loopback%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.7.</span> <span class="toc-text">3.2.7 应当正确配置iptables loopback策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-8-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEiptables-INPUT%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.8.</span> <span class="toc-text">3.2.8 应当正确配置iptables INPUT策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-9-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEiptables-OUTPUT%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.9.</span> <span class="toc-text">3.2.9 应当正确配置iptables OUTPUT策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-10-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEiptables-INPUT%E3%80%81OUTPUT%E5%85%B3%E8%81%94%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.10.</span> <span class="toc-text">3.2.10 应当正确配置iptables INPUT、OUTPUT关联策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-11-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8nftables%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.13.11.</span> <span class="toc-text">3.2.11 应当启用nftables服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-12-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AEnftables%E9%BB%98%E8%AE%A4%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.12.</span> <span class="toc-text">3.2.12 应当配置nftables默认拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-13-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AEnftables-loopback%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.13.</span> <span class="toc-text">3.2.13 应当配置nftables loopback策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-14-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEnftables-input%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.14.</span> <span class="toc-text">3.2.14 应当正确配置nftables input策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-15-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEnftables-output%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.15.</span> <span class="toc-text">3.2.15 应当正确配置nftables output策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-16-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEnftables-input%E3%80%81output%E5%85%B3%E8%81%94%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.16.</span> <span class="toc-text">3.2.16 应当正确配置nftables input、output关联策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-SSH"><span class="toc-number">1.14.</span> <span class="toc-text">3.3 SSH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E7%A1%AE%E4%BF%9DSSH%E6%9C%8D%E5%8A%A1%E7%89%88%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.14.1.</span> <span class="toc-text">3.3.1 确保SSH服务版本配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E7%A1%AE%E4%BF%9DSSH%E6%9C%8D%E5%8A%A1%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.14.2.</span> <span class="toc-text">3.3.2 确保SSH服务认证方式配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E7%A1%AE%E4%BF%9DSSH%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.14.3.</span> <span class="toc-text">3.3.3 确保SSH密钥交换算法配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E7%AE%97%E6%B3%95%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.14.4.</span> <span class="toc-text">3.3.4 确保用户认证密钥算法配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5-%E7%A1%AE%E4%BF%9DPAM%E8%AE%A4%E8%AF%81%E4%BD%BF%E8%83%BD"><span class="toc-number">1.14.5.</span> <span class="toc-text">3.3.5 确保PAM认证使能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-6-%E7%A1%AE%E4%BF%9DSSH%E6%9C%8D%E5%8A%A1MACs%E7%AE%97%E6%B3%95%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.14.6.</span> <span class="toc-text">3.3.6 确保SSH服务MACs算法配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-7-%E7%A1%AE%E4%BF%9DSSH%E6%9C%8D%E5%8A%A1%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.14.7.</span> <span class="toc-text">3.3.7 确保SSH服务密码算法配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-8-%E7%A6%81%E6%AD%A2SSH%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%A6%86%E7%9B%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.14.8.</span> <span class="toc-text">3.3.8 禁止SSH服务配置加密算法覆盖策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-9-%E7%A1%AE%E4%BF%9D%E7%A6%81%E7%94%A8root%E7%94%A8%E6%88%B7%E9%80%9A%E8%BF%87SSH%E7%99%BB%E5%BD%95"><span class="toc-number">1.14.9.</span> <span class="toc-text">3.3.9 确保禁用root用户通过SSH登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-10-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AESSH%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-number">1.14.10.</span> <span class="toc-text">3.3.10 应当正确配置SSH服务日志级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-11-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AESSH%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.14.11.</span> <span class="toc-text">3.3.11 应当正确配置SSH服务接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-12-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AESSH%E5%B9%B6%E5%8F%91%E6%9C%AA%E8%AE%A4%E8%AF%81%E8%BF%9E%E6%8E%A5%E6%95%B0"><span class="toc-number">1.14.12.</span> <span class="toc-text">3.3.12 应当正确配置SSH并发未认证连接数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-13-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E5%8D%95%E4%B8%AASSH%E8%BF%9E%E6%8E%A5%E5%85%81%E8%AE%B8%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BC%9A%E8%AF%9D%E6%95%B0"><span class="toc-number">1.14.13.</span> <span class="toc-text">3.3.13 应当正确配置单个SSH连接允许的并发会话数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-14-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8X11-Forwarding"><span class="toc-number">1.14.14.</span> <span class="toc-text">3.3.14 禁止使用X11 Forwarding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-15-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEMaxAuthTries"><span class="toc-number">1.14.15.</span> <span class="toc-text">3.3.15 应当正确配置MaxAuthTries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-16-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8PermitUserEnvironment"><span class="toc-number">1.14.16.</span> <span class="toc-text">3.3.16 禁止使用PermitUserEnvironment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-17-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AELoginGraceTime"><span class="toc-number">1.14.17.</span> <span class="toc-text">3.3.17 应当正确配置LoginGraceTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-18-%E7%A6%81%E6%AD%A2SSH%E6%9C%8D%E5%8A%A1%E9%A2%84%E8%AE%BE%E7%BD%AEauthorized-keys"><span class="toc-number">1.14.18.</span> <span class="toc-text">3.3.18 禁止SSH服务预设置authorized_keys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-19-%E7%A6%81%E6%AD%A2SSH%E6%9C%8D%E5%8A%A1%E9%A2%84%E8%AE%BE%E7%BD%AEknown-hosts"><span class="toc-number">1.14.19.</span> <span class="toc-text">3.3.19 禁止SSH服务预设置known_hosts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-20-%E7%A6%81%E6%AD%A2SSH%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%BC%83%E7%94%A8%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">1.14.20.</span> <span class="toc-text">3.3.20 禁止SSH服务配置弃用的选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-21-%E7%A1%AE%E4%BF%9D%E7%A6%81%E7%94%A8SSH%E7%9A%84TCP%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD"><span class="toc-number">1.14.21.</span> <span class="toc-text">3.3.21 确保禁用SSH的TCP转发功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-22-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E8%AE%A4%E8%AF%81%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95"><span class="toc-number">1.14.22.</span> <span class="toc-text">3.3.22 应当正确配置认证黑白名单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.15.</span> <span class="toc-text">3.4 定时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E7%A1%AE%E4%BF%9Dcrontab%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC%E9%9D%9E%E5%B1%9E%E4%B8%BB%E7%94%A8%E6%88%B7%E4%B8%8D%E5%8F%AF%E5%86%99"><span class="toc-number">1.15.1.</span> <span class="toc-text">3.4.1 确保crontab执行的脚本非属主用户不可写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E7%A1%AE%E4%BF%9Dcron%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%AD%A3%E5%B8%B8%E5%90%AF%E7%94%A8"><span class="toc-number">1.15.2.</span> <span class="toc-text">3.4.2 确保cron守护进程正常启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E7%A1%AE%E4%BF%9Dat%E3%80%81cron%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.15.3.</span> <span class="toc-text">3.4.3 确保at、cron配置正确</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%86%85%E6%A0%B8"><span class="toc-number">1.16.</span> <span class="toc-text">3.5 内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E7%A1%AE%E4%BF%9D%E5%86%85%E6%A0%B8ASLR%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.16.1.</span> <span class="toc-text">3.5.1 确保内核ASLR已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E7%A1%AE%E4%BF%9Ddmesg%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.16.2.</span> <span class="toc-text">3.5.2 确保dmesg访问权限配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0kptr-restrict"><span class="toc-number">1.16.3.</span> <span class="toc-text">3.5.3 确保正确配置内核参数kptr_restrict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E7%A1%AE%E4%BF%9D%E5%86%85%E6%A0%B8SMAP%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.16.4.</span> <span class="toc-text">3.5.4 确保内核SMAP已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E7%A1%AE%E4%BF%9D%E5%86%85%E6%A0%B8SMEP%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.16.5.</span> <span class="toc-text">3.5.5 确保内核SMEP已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-6-%E7%A6%81%E6%AD%A2%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94ICMP%E5%B9%BF%E6%92%AD%E6%8A%A5%E6%96%87"><span class="toc-number">1.16.6.</span> <span class="toc-text">3.5.6 禁止系统响应ICMP广播报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-7-%E7%A6%81%E6%AD%A2%E6%8E%A5%E6%94%B6ICMP%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87"><span class="toc-number">1.16.7.</span> <span class="toc-text">3.5.7 禁止接收ICMP重定向报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-8-%E7%A6%81%E6%AD%A2%E8%BD%AC%E5%8F%91ICMP%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87"><span class="toc-number">1.16.8.</span> <span class="toc-text">3.5.8 禁止转发ICMP重定向报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-9-%E5%BA%94%E5%BD%93%E5%BF%BD%E7%95%A5%E6%89%80%E6%9C%89ICMP%E8%AF%B7%E6%B1%82"><span class="toc-number">1.16.9.</span> <span class="toc-text">3.5.9 应当忽略所有ICMP请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-10-%E7%A1%AE%E4%BF%9D%E4%B8%A2%E5%BC%83%E4%BC%AA%E9%80%A0%E7%9A%84ICMP%E6%8A%A5%E6%96%87%EF%BC%8C%E4%B8%8D%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">1.16.10.</span> <span class="toc-text">3.5.10 确保丢弃伪造的ICMP报文，不记录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-11-%E7%A1%AE%E4%BF%9D%E5%8F%8D%E5%90%91%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.16.11.</span> <span class="toc-text">3.5.11 确保反向地址过滤已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-12-%E7%A6%81%E6%AD%A2IP%E8%BD%AC%E5%8F%91"><span class="toc-number">1.16.12.</span> <span class="toc-text">3.5.12 禁止IP转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-13-%E7%A6%81%E6%AD%A2%E6%8A%A5%E6%96%87%E6%BA%90%E8%B7%AF%E7%94%B1"><span class="toc-number">1.16.13.</span> <span class="toc-text">3.5.13 禁止报文源路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-14-%E7%A1%AE%E4%BF%9DTCP-SYN-cookie%E4%BF%9D%E6%8A%A4%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.16.14.</span> <span class="toc-text">3.5.14 确保TCP-SYN cookie保护已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-15-%E5%BA%94%E5%BD%93%E8%AE%B0%E5%BD%95%E4%BB%BF%E5%86%92%E3%80%81%E6%BA%90%E8%B7%AF%E7%94%B1%E4%BB%A5%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87%E6%97%A5%E5%BF%97"><span class="toc-number">1.16.15.</span> <span class="toc-text">3.5.15 应当记录仿冒、源路由以及重定向报文日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-16-%E9%81%BF%E5%85%8D%E5%BC%80%E5%90%AFtcp-timestamps"><span class="toc-number">1.16.16.</span> <span class="toc-text">3.5.16 避免开启tcp_timestamps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-17-%E7%A1%AE%E4%BF%9DTIME-WAIT-TCP%E5%8D%8F%E8%AE%AE%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E5%B7%B2%E9%85%8D%E7%BD%AE"><span class="toc-number">1.16.17.</span> <span class="toc-text">3.5.17 确保TIME_WAIT TCP协议等待时间已配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-18-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AESYN-RECV%E7%8A%B6%E6%80%81%E9%98%9F%E5%88%97%E6%95%B0%E9%87%8F"><span class="toc-number">1.16.18.</span> <span class="toc-text">3.5.18 应当正确配置SYN_RECV状态队列数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-19-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8ARP%E4%BB%A3%E7%90%86"><span class="toc-number">1.16.19.</span> <span class="toc-text">3.5.19 禁止使用ARP代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-20-%E7%A1%AE%E4%BF%9Dcore-dump%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.16.20.</span> <span class="toc-text">3.5.20 确保core dump配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-21-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8SysRq%E9%94%AE"><span class="toc-number">1.16.21.</span> <span class="toc-text">3.5.21 禁止使用SysRq键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-22-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0ptrace-scope"><span class="toc-number">1.16.22.</span> <span class="toc-text">3.5.22 应当正确配置内核参数ptrace_scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-23-%E5%BA%94%E5%BD%93%E5%90%AF%E7%94%A8seccomp"><span class="toc-number">1.16.23.</span> <span class="toc-text">3.5.23 应当启用seccomp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5"><span class="toc-number">1.17.</span> <span class="toc-text">3.6 时间同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEntpd%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.17.1.</span> <span class="toc-text">3.6.1 应当正确配置ntpd服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEchronyd%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.17.2.</span> <span class="toc-text">3.6.2 应当正确配置chronyd服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1"><span class="toc-number">1.18.</span> <span class="toc-text">4 日志审计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Audit"><span class="toc-number">1.19.</span> <span class="toc-text">4.1 Audit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%A1%AE%E4%BF%9Dauditd%E5%AE%A1%E8%AE%A1%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.19.1.</span> <span class="toc-text">4.1.1 确保auditd审计已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%A1%AE%E4%BF%9D%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97rotate%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.19.2.</span> <span class="toc-text">4.1.2 确保审计日志rotate已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E7%99%BB%E5%BD%95%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.3.</span> <span class="toc-text">4.1.3 应当配置登录审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E8%B4%A6%E5%8F%B7%E4%BF%A1%E6%81%AF%E4%BF%AE%E6%94%B9%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.4.</span> <span class="toc-text">4.1.4 应当配置账号信息修改审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E6%8F%90%E6%9D%83%E5%91%BD%E4%BB%A4%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.5.</span> <span class="toc-text">4.1.5 应当配置提权命令审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%8F%98%E6%9B%B4%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.6.</span> <span class="toc-text">4.1.6 应当配置内核模块变更审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98%E7%89%B9%E6%9D%83%E6%93%8D%E4%BD%9C%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.7.</span> <span class="toc-text">4.1.7 应当配置管理员特权操作审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-8-%E5%BA%94%E5%BD%93%E5%9C%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%90%AF%E7%94%A8auditd"><span class="toc-number">1.19.8.</span> <span class="toc-text">4.1.8 应当在启动阶段启用auditd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-9-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AEaudit-backlog-limit"><span class="toc-number">1.19.9.</span> <span class="toc-text">4.1.9 应当正确配置audit_backlog_limit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-10-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8auditctl%E8%AE%BE%E7%BD%AEauditd%E8%A7%84%E5%88%99"><span class="toc-number">1.19.10.</span> <span class="toc-text">4.1.10 避免使用auditctl设置auditd规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-11-%E7%A1%AE%E4%BF%9D%E6%97%A5%E5%BF%97%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E9%85%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.19.11.</span> <span class="toc-text">4.1.11 确保日志大小限制配置正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-12-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%A9%BA%E9%97%B4%E9%98%88%E5%80%BC"><span class="toc-number">1.19.12.</span> <span class="toc-text">4.1.12 应当正确配置硬盘空间阈值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-13-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AEsudoers%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.13.</span> <span class="toc-text">4.1.13 应当配置sudoers审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-14-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E4%BC%9A%E8%AF%9D%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.14.</span> <span class="toc-text">4.1.14 应当配置会话审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-15-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E6%97%B6%E9%97%B4%E4%BF%AE%E6%94%B9%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.15.</span> <span class="toc-text">4.1.15 应当配置时间修改审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-16-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AESELinux%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.16.</span> <span class="toc-text">4.1.16 应当配置SELinux审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-17-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.17.</span> <span class="toc-text">4.1.17 应当配置网络环境审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-18-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.18.</span> <span class="toc-text">4.1.18 应当配置文件访问控制权限审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-19-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.19.</span> <span class="toc-text">4.1.19 应当配置文件访问失败审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-20-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.20.</span> <span class="toc-text">4.1.20 应当配置文件删除审计规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-21-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E5%AE%A1%E8%AE%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.19.21.</span> <span class="toc-text">4.1.21 应当配置文件系统挂载审计规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Rsyslog"><span class="toc-number">1.20.</span> <span class="toc-text">4.2 Rsyslog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%A1%AE%E4%BF%9Drsyslog%E6%9C%8D%E5%8A%A1%E5%B7%B2%E5%90%AF%E7%94%A8"><span class="toc-number">1.20.1.</span> <span class="toc-text">4.2.1 确保rsyslog服务已启用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%A1%AE%E4%BF%9D%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3%E4%BA%8B%E4%BB%B6%E6%97%A5%E5%BF%97%E5%B7%B2%E8%AE%B0%E5%BD%95"><span class="toc-number">1.20.2.</span> <span class="toc-text">4.2.2 确保系统认证相关事件日志已记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E7%A1%AE%E4%BF%9Dcron%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E5%B7%B2%E8%AE%B0%E5%BD%95"><span class="toc-number">1.20.3.</span> <span class="toc-text">4.2.3 确保cron服务日志已记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AErsyslog%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">1.20.4.</span> <span class="toc-text">4.2.4 应当正确配置rsyslog默认文件权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E5%BA%94%E5%BD%93%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E5%90%84%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">1.20.5.</span> <span class="toc-text">4.2.5 应当正确配置各服务日志记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-%E7%A1%AE%E4%BF%9Drsyslog%E8%BD%AC%E5%82%A8journald%E6%97%A5%E5%BF%97%E5%B7%B2%E9%85%8D%E7%BD%AE"><span class="toc-number">1.20.6.</span> <span class="toc-text">4.2.6 确保rsyslog转储journald日志已配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E7%A1%AE%E4%BF%9Drsyslog%E6%97%A5%E5%BF%97rotate%E5%B7%B2%E9%85%8D%E7%BD%AE"><span class="toc-number">1.20.7.</span> <span class="toc-text">4.2.7 确保rsyslog日志rotate已配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-8-%E5%BA%94%E5%BD%93%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.20.8.</span> <span class="toc-text">4.2.8 应当配置远程日志服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-9-%E5%BA%94%E5%BD%93%E4%BB%85%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%BB%E6%9C%BA%E4%B8%8A%E6%8E%A5%E5%8F%97%E8%BF%9C%E7%A8%8Brsyslog%E6%B6%88%E6%81%AF"><span class="toc-number">1.20.9.</span> <span class="toc-text">4.2.9 应当仅在指定的日志主机上接受远程rsyslog消息</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ec805823.html" title="openEuler安全配置基线"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2023/08/27/70d5dea4dd88dfc1.webp?_r_=bb7c0e92-ec43-67b0-e72e-a37c058b5b71" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="openEuler安全配置基线"/></a><div class="content"><a class="title" href="/posts/ec805823.html" title="openEuler安全配置基线">openEuler安全配置基线</a><time datetime="2024-09-25T09:21:30.000Z" title="发表于 2024-09-25 17:21:30">2024-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/217c81a9.html" title="Linux常用配置项"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2023/08/27/70d5dea4dd88dfc1.webp?_r_=fd5b3c10-d4a6-2363-b3f4-b7310b500e1d" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux常用配置项"/></a><div class="content"><a class="title" href="/posts/217c81a9.html" title="Linux常用配置项">Linux常用配置项</a><time datetime="2024-01-19T10:14:54.000Z" title="发表于 2024-01-19 18:14:54">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ec80583f.html" title="Linux配置软件源"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.loli.net/2021/06/24/rOoZB9lxw47F1uE.jpg?_r_=e5fbc293-b424-421b-3df2-fec094d233e6" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux配置软件源"/></a><div class="content"><a class="title" href="/posts/ec80583f.html" title="Linux配置软件源">Linux配置软件源</a><time datetime="2024-01-19T09:21:30.000Z" title="发表于 2024-01-19 17:21:30">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfa35092.html" title="kubectl备忘录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2024/01/16/a41bb3528af27677.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kubectl备忘录"/></a><div class="content"><a class="title" href="/posts/dfa35092.html" title="kubectl备忘录">kubectl备忘录</a><time datetime="2024-01-17T04:08:09.000Z" title="发表于 2024-01-17 12:08:09">2024-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7c4b9639.html" title="ubuntu"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s3.bmp.ovh/imgs/2024/01/16/2e7f9a9a386f638e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ubuntu"/></a><div class="content"><a class="title" href="/posts/7c4b9639.html" title="ubuntu">ubuntu</a><time datetime="2024-01-17T03:27:46.000Z" title="发表于 2024-01-17 11:27:46">2024-01-17</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a><a class="github-badge" target="_blank" href="https://app.netlify.com/sites/techcatnip/deploys" style="margin-inline:5px" data-title="Netlify Status" title="Netlify Status"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://api.netlify.com/api/v1/badges/14025ac2-19c0-4e5b-a0db-8920be3c92eb/deploy-status" alt="Netlify Status"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="馒头馅儿大肉包" target="_blank">馒头馅儿大肉包</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.techcat.cc/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://index.anheyu.com/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2748ef34.jpg" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=6681991756&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>1</sup></a><a href="/tags/Linux%E8%84%9A%E6%9C%AC%E7%BB%83%E4%B9%A0/" style="font-size: 0.88rem;">Linux脚本练习<sup>1</sup></a><a href="/tags/Markdown/" style="font-size: 0.88rem;">Markdown<sup>1</sup></a><a href="/tags/apt/" style="font-size: 0.88rem;">apt<sup>1</sup></a><a href="/tags/centos/" style="font-size: 0.88rem;">centos<sup>1</sup></a><a href="/tags/if%E5%88%A4%E6%96%AD/" style="font-size: 0.88rem;">if判断<sup>1</sup></a><a href="/tags/k8s/" style="font-size: 0.88rem;">k8s<sup>1</sup></a><a href="/tags/kubectl/" style="font-size: 0.88rem;">kubectl<sup>1</sup></a><a href="/tags/kubernetes/" style="font-size: 0.88rem;">kubernetes<sup>1</sup></a><a href="/tags/selinux/" style="font-size: 0.88rem;">selinux<sup>1</sup></a><a href="/tags/systemd/" style="font-size: 0.88rem;">systemd<sup>1</sup></a><a href="/tags/ubuntu/" style="font-size: 0.88rem;">ubuntu<sup>2</sup></a><a href="/tags/yum/" style="font-size: 0.88rem;">yum<sup>1</sup></a><a href="/tags/yum%E6%BA%90/" style="font-size: 0.88rem;">yum源<sup>1</sup></a><a href="/tags/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/" style="font-size: 0.88rem;">外挂标签<sup>1</sup></a><a href="/tags/%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%BA%BF/" style="font-size: 0.88rem;">安全配置基线<sup>1</sup></a><a href="/tags/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/" style="font-size: 0.88rem;">常用配置项<sup>1</sup></a><a href="/tags/%E7%A4%BA%E4%BE%8B/" style="font-size: 0.88rem;">示例<sup>1</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E6%BA%90/" style="font-size: 0.88rem;">软件源<sup>1</sup></a><a href="/tags/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/" style="font-size: 0.88rem;">遍历文件<sup>1</sup></a><a href="/tags/%E9%85%8D%E7%BD%AEIP%E5%9C%B0%E5%9D%80/" style="font-size: 0.88rem;">配置IP地址<sup>1</sup></a><a href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" style="font-size: 0.88rem;">防火墙<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7815766992" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/7815766992&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 馒头馅儿大肉包 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.cbd.int/katex@0.16.0/dist/katex.min.css"><script src="https://cdn.cbd.int/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    anzhiyu.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://leafy-dasik-1bfebc.netlify.app/.netlify/functions/twikoo',
      region: 'ap-east-1',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://leafy-dasik-1bfebc.netlify.app/.netlify/functions/twikoo',
      region: 'ap-east-1',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://leafy-dasik-1bfebc.netlify.app/.netlify/functions/twikoo',
        region: 'ap-east-1',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/bangumis/"]):not([href="/album/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>